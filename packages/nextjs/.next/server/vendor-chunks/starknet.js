"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/starknet";
exports.ids = ["vendor-chunks/starknet"];
exports.modules = {

/***/ "(ssr)/./node_modules/starknet/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/starknet/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   BlockStatus: () => (/* binding */ BlockStatus),\n/* harmony export */   BlockTag: () => (/* binding */ BlockTag),\n/* harmony export */   CairoCustomEnum: () => (/* binding */ CairoCustomEnum),\n/* harmony export */   CairoOption: () => (/* binding */ CairoOption),\n/* harmony export */   CairoOptionVariant: () => (/* binding */ CairoOptionVariant),\n/* harmony export */   CairoResult: () => (/* binding */ CairoResult),\n/* harmony export */   CairoResultVariant: () => (/* binding */ CairoResultVariant),\n/* harmony export */   CallData: () => (/* binding */ CallData),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory),\n/* harmony export */   ContractInterface: () => (/* binding */ ContractInterface),\n/* harmony export */   CustomError: () => (/* binding */ CustomError),\n/* harmony export */   EntryPointType: () => (/* binding */ EntryPointType),\n/* harmony export */   GatewayError: () => (/* binding */ GatewayError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LibraryError: () => (/* binding */ LibraryError),\n/* harmony export */   Litteral: () => (/* binding */ Litteral),\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   ProviderInterface: () => (/* binding */ ProviderInterface),\n/* harmony export */   RPC: () => (/* binding */ rpc_exports),\n/* harmony export */   RpcProvider: () => (/* binding */ RpcProvider),\n/* harmony export */   SIMULATION_FLAG: () => (/* binding */ SIMULATION_FLAG),\n/* harmony export */   Sequencer: () => (/* binding */ sequencer_exports),\n/* harmony export */   SequencerProvider: () => (/* binding */ SequencerProvider),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignerInterface: () => (/* binding */ SignerInterface),\n/* harmony export */   TransactionExecutionStatus: () => (/* binding */ TransactionExecutionStatus),\n/* harmony export */   TransactionFinalityStatus: () => (/* binding */ TransactionFinalityStatus),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionType: () => (/* binding */ TransactionType),\n/* harmony export */   Uint: () => (/* binding */ Uint),\n/* harmony export */   ValidateType: () => (/* binding */ ValidateType),\n/* harmony export */   addAddressPadding: () => (/* binding */ addAddressPadding),\n/* harmony export */   buildUrl: () => (/* binding */ buildUrl),\n/* harmony export */   cairo: () => (/* binding */ cairo_exports),\n/* harmony export */   constants: () => (/* binding */ constants_exports),\n/* harmony export */   contractClassResponseToLegacyCompiledContract: () => (/* binding */ contractClassResponseToLegacyCompiledContract),\n/* harmony export */   defaultProvider: () => (/* binding */ defaultProvider),\n/* harmony export */   ec: () => (/* binding */ ec_exports),\n/* harmony export */   encode: () => (/* binding */ encode_exports),\n/* harmony export */   events: () => (/* binding */ events_exports),\n/* harmony export */   extractContractHashes: () => (/* binding */ extractContractHashes),\n/* harmony export */   fixProto: () => (/* binding */ fixProto),\n/* harmony export */   fixStack: () => (/* binding */ fixStack),\n/* harmony export */   getCalldata: () => (/* binding */ getCalldata),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   getDefaultNodeUrl: () => (/* binding */ getDefaultNodeUrl),\n/* harmony export */   hash: () => (/* binding */ hash_exports),\n/* harmony export */   isSierra: () => (/* binding */ isSierra),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   json: () => (/* binding */ json_exports),\n/* harmony export */   merkle: () => (/* binding */ merkle_exports),\n/* harmony export */   num: () => (/* binding */ num_exports),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   parseUDCEvent: () => (/* binding */ parseUDCEvent),\n/* harmony export */   provider: () => (/* binding */ provider_exports),\n/* harmony export */   selector: () => (/* binding */ selector_exports),\n/* harmony export */   shortString: () => (/* binding */ shortString_exports),\n/* harmony export */   splitArgsAndOptions: () => (/* binding */ splitArgsAndOptions),\n/* harmony export */   stark: () => (/* binding */ stark_exports),\n/* harmony export */   starknetId: () => (/* binding */ starknetId_exports),\n/* harmony export */   transaction: () => (/* binding */ transaction_exports),\n/* harmony export */   typedData: () => (/* binding */ typedData_exports),\n/* harmony export */   types: () => (/* binding */ types_exports),\n/* harmony export */   uint256: () => (/* binding */ uint256_exports),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress),\n/* harmony export */   validateChecksumAddress: () => (/* binding */ validateChecksumAddress)\n/* harmony export */ });\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lossless-json */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! isomorphic-fetch */ \"(ssr)/./node_modules/isomorphic-fetch/fetch-npm-node.js\");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! url-join */ \"(ssr)/./node_modules/url-join/lib/url-join.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n  ADDR_BOUND: () => ADDR_BOUND,\n  API_VERSION: () => API_VERSION,\n  BN_FEE_TRANSACTION_VERSION_1: () => BN_FEE_TRANSACTION_VERSION_1,\n  BN_FEE_TRANSACTION_VERSION_2: () => BN_FEE_TRANSACTION_VERSION_2,\n  BN_TRANSACTION_VERSION_1: () => BN_TRANSACTION_VERSION_1,\n  BN_TRANSACTION_VERSION_2: () => BN_TRANSACTION_VERSION_2,\n  BaseUrl: () => BaseUrl,\n  HEX_STR_TRANSACTION_VERSION_1: () => HEX_STR_TRANSACTION_VERSION_1,\n  HEX_STR_TRANSACTION_VERSION_2: () => HEX_STR_TRANSACTION_VERSION_2,\n  IS_BROWSER: () => IS_BROWSER,\n  MASK_250: () => MASK_250,\n  MAX_STORAGE_ITEM_SIZE: () => MAX_STORAGE_ITEM_SIZE,\n  NetworkName: () => NetworkName,\n  RPC_DEFAULT_VERSION: () => RPC_DEFAULT_VERSION,\n  RPC_NODES: () => RPC_NODES,\n  StarknetChainId: () => StarknetChainId,\n  TEXT_TO_FELT_MAX_LEN: () => TEXT_TO_FELT_MAX_LEN,\n  TransactionHashPrefix: () => TransactionHashPrefix,\n  UDC: () => UDC,\n  ZERO: () => ZERO\n});\n\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n  IS_BROWSER: () => IS_BROWSER,\n  addHexPrefix: () => addHexPrefix,\n  arrayBufferToString: () => arrayBufferToString,\n  atobUniversal: () => atobUniversal,\n  btoaUniversal: () => btoaUniversal,\n  buf2hex: () => buf2hex,\n  calcByteLength: () => calcByteLength,\n  padLeft: () => padLeft,\n  pascalToSnake: () => pascalToSnake,\n  removeHexPrefix: () => removeHexPrefix,\n  sanitizeBytes: () => sanitizeBytes,\n  sanitizeHex: () => sanitizeHex,\n  stringToArrayBuffer: () => stringToArrayBuffer,\n  utf8ToArray: () => utf8ToArray\n});\n\nvar IS_BROWSER = typeof window !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n  return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n  return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n  return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n  return buffer.reduce((r, x) => r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n  return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n  return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n  return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n  const { length } = str;\n  const remainder = length % byteSize;\n  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n  return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n  hex = removeHexPrefix(hex);\n  hex = sanitizeBytes(hex, 2);\n  if (hex) {\n    hex = addHexPrefix(hex);\n  }\n  return hex;\n}\nvar pascalToSnake = (text) => /[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\n\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar HEX_STR_TRANSACTION_VERSION_1 = \"0x1\";\nvar HEX_STR_TRANSACTION_VERSION_2 = \"0x2\";\nvar BN_TRANSACTION_VERSION_1 = 1n;\nvar BN_TRANSACTION_VERSION_2 = 2n;\nvar BN_FEE_TRANSACTION_VERSION_1 = 2n ** 128n + BN_TRANSACTION_VERSION_1;\nvar BN_FEE_TRANSACTION_VERSION_2 = 2n ** 128n + BN_TRANSACTION_VERSION_2;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar API_VERSION = ZERO;\nvar MAX_STORAGE_ITEM_SIZE = 256n;\nvar ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2) => {\n  BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n  BaseUrl2[\"SN_GOERLI\"] = \"https://alpha4.starknet.io\";\n  BaseUrl2[\"SN_SEPOLIA\"] = \"https://alpha-sepolia.starknet.io\";\n  return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2) => {\n  NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n  NetworkName2[\"SN_GOERLI\"] = \"SN_GOERLI\";\n  NetworkName2[\"SN_SEPOLIA\"] = \"SN_SEPOLIA\";\n  return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId4) => {\n  StarknetChainId4[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n  StarknetChainId4[\"SN_GOERLI\"] = \"0x534e5f474f45524c49\";\n  StarknetChainId4[\"SN_SEPOLIA\"] = \"0x534e5f5345504f4c4941\";\n  return StarknetChainId4;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2) => {\n  TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n  TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n  TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n  TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n  TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n  return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar UDC = {\n  ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n  ENTRYPOINT: \"deployContract\"\n};\nvar RPC_DEFAULT_VERSION = \"v0_5\";\nvar RPC_NODES = {\n  SN_GOERLI: [\n    `https://starknet-testnet.public.blastapi.io/rpc/`,\n    `https://free-rpc.nethermind.io/goerli-juno/`\n  ],\n  SN_MAIN: [\n    `https://starknet-mainnet.public.blastapi.io/rpc/`,\n    `https://free-rpc.nethermind.io/mainnet-juno/`\n  ],\n  SN_SEPOLIA: [\n    `https://starknet-sepolia.public.blastapi.io/rpc/`,\n    `https://free-rpc.nethermind.io/sepolia-juno/`\n  ]\n};\n\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n  BlockStatus: () => BlockStatus,\n  BlockTag: () => BlockTag,\n  EntryPointType: () => EntryPointType,\n  Litteral: () => Litteral,\n  RPC: () => rpc_exports,\n  SIMULATION_FLAG: () => SIMULATION_FLAG,\n  Sequencer: () => sequencer_exports,\n  TransactionExecutionStatus: () => TransactionExecutionStatus,\n  TransactionFinalityStatus: () => TransactionFinalityStatus,\n  TransactionStatus: () => TransactionStatus,\n  TransactionType: () => TransactionType,\n  Uint: () => Uint,\n  ValidateType: () => ValidateType\n});\n\n// src/types/account.ts\nvar SIMULATION_FLAG = /* @__PURE__ */ ((SIMULATION_FLAG2) => {\n  SIMULATION_FLAG2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n  SIMULATION_FLAG2[\"SKIP_EXECUTE\"] = \"SKIP_EXECUTE\";\n  return SIMULATION_FLAG2;\n})(SIMULATION_FLAG || {});\n\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2) => {\n  ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n  ValidateType2[\"CALL\"] = \"CALL\";\n  ValidateType2[\"INVOKE\"] = \"INVOKE\";\n  return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2) => {\n  Uint2[\"u8\"] = \"core::integer::u8\";\n  Uint2[\"u16\"] = \"core::integer::u16\";\n  Uint2[\"u32\"] = \"core::integer::u32\";\n  Uint2[\"u64\"] = \"core::integer::u64\";\n  Uint2[\"u128\"] = \"core::integer::u128\";\n  Uint2[\"u256\"] = \"core::integer::u256\";\n  return Uint2;\n})(Uint || {});\nvar Litteral = /* @__PURE__ */ ((Litteral2) => {\n  Litteral2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n  Litteral2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n  return Litteral2;\n})(Litteral || {});\n\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2) => {\n  EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n  EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n  EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n  return EntryPointType2;\n})(EntryPointType || {});\n\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2) => {\n  TransactionType2[\"DECLARE\"] = \"DECLARE\";\n  TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n  TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n  TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n  return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {\n  TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n  TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n  TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n  return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2) => {\n  TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n  TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2) => {\n  TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n  TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n  TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2) => {\n  BlockStatus2[\"PENDING\"] = \"PENDING\";\n  BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n  return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2) => {\n  BlockTag2[\"pending\"] = \"pending\";\n  BlockTag2[\"latest\"] = \"latest\";\n  return BlockTag2;\n})(BlockTag || {});\n\n// src/types/api/rpc.ts\nvar rpc_exports = {};\n__export(rpc_exports, {\n  EBlockTag: () => EBlockTag,\n  EDataAvailabilityMode: () => EDataAvailabilityMode,\n  ESimulationFlag: () => ESimulationFlag,\n  ETransactionExecutionStatus: () => ETransactionExecutionStatus,\n  ETransactionFinalityStatus: () => ETransactionFinalityStatus,\n  ETransactionStatus: () => ETransactionStatus,\n  ETransactionType: () => ETransactionType,\n  Errors: () => errors_exports,\n  JRPC: () => jsonrpc_exports,\n  SPEC: () => components_exports\n});\n\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n\n// src/types/api/rpcspec/errors.ts\nvar errors_exports = {};\n\n// src/types/api/rpcspec/components.ts\nvar components_exports = {};\n\n// src/types/api/rpcspec/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2) => {\n  ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n  ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n  ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n  ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n  ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n  return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2) => {\n  ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n  ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n  return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2) => {\n  ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n  ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2) => {\n  ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2) => {\n  ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n  return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2) => {\n  EBlockTag2[\"LATEST\"] = \"latest\";\n  EBlockTag2[\"PENDING\"] = \"pending\";\n  return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode2) => {\n  EDataAvailabilityMode2[\"L1\"] = \"L1\";\n  EDataAvailabilityMode2[\"L2\"] = \"L2\";\n  return EDataAvailabilityMode2;\n})(EDataAvailabilityMode || {});\n\n// src/types/api/sequencer.ts\nvar sequencer_exports = {};\n\n// src/utils/assert.ts\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failure\");\n  }\n}\n\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n  assertInRange: () => assertInRange,\n  bigNumberishArrayToDecimalStringArray: () => bigNumberishArrayToDecimalStringArray,\n  bigNumberishArrayToHexadecimalStringArray: () => bigNumberishArrayToHexadecimalStringArray,\n  cleanHex: () => cleanHex,\n  getDecimalString: () => getDecimalString,\n  getHexString: () => getHexString,\n  getHexStringArray: () => getHexStringArray,\n  hexToBytes: () => hexToBytes,\n  hexToDecimalString: () => hexToDecimalString,\n  isBigInt: () => isBigInt,\n  isHex: () => isHex,\n  isStringWholeNumber: () => isStringWholeNumber,\n  toBigInt: () => toBigInt,\n  toCairoBool: () => toCairoBool,\n  toHex: () => toHex,\n  toHexString: () => toHexString,\n  toStorageKey: () => toStorageKey\n});\n\nfunction isHex(hex) {\n  return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n  return BigInt(value);\n}\nfunction isBigInt(value) {\n  return typeof value === \"bigint\";\n}\nfunction toHex(number2) {\n  return addHexPrefix(toBigInt(number2).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n  const res = addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n  return res;\n}\nfunction hexToDecimalString(hex) {\n  return BigInt(addHexPrefix(hex)).toString(10);\n}\nvar cleanHex = (hex) => hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n  const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n  const inputBigInt = BigInt(input);\n  const lowerBoundBigInt = BigInt(lowerBound);\n  const upperBoundBigInt = BigInt(upperBound);\n  assert(\n    inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,\n    `Message not signable, ${messageSuffix}.`\n  );\n}\nfunction bigNumberishArrayToDecimalStringArray(rawCalldata) {\n  return rawCalldata.map((x) => toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(rawCalldata) {\n  return rawCalldata.map((x) => toHex(x));\n}\nvar isStringWholeNumber = (value) => /^\\d+$/.test(value);\nfunction getDecimalString(value) {\n  if (isHex(value)) {\n    return hexToDecimalString(value);\n  }\n  if (isStringWholeNumber(value)) {\n    return value;\n  }\n  throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexString(value) {\n  if (isHex(value)) {\n    return value;\n  }\n  if (isStringWholeNumber(value)) {\n    return toHexString(value);\n  }\n  throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexStringArray(value) {\n  return value.map((el) => getHexString(el));\n}\nvar toCairoBool = (value) => (+value).toString();\nfunction hexToBytes(value) {\n  if (!isHex(value))\n    throw new Error(`${value} need to be a hex-string`);\n  let adaptedValue = removeHexPrefix(value);\n  if (adaptedValue.length % 2 !== 0) {\n    adaptedValue = `0${adaptedValue}`;\n  }\n  return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(adaptedValue);\n}\n\n// src/utils/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  keccakBn: () => keccakBn,\n  starknetKeccak: () => starknetKeccak\n});\n\nfunction keccakBn(value) {\n  const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n  const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n  const hash = BigInt(keccakHex(str));\n  return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n  return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n  if (isHex(value)) {\n    return value;\n  }\n  if (isStringWholeNumber(value)) {\n    return toHexString(value);\n  }\n  return getSelectorFromName(value);\n}\n\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n  decodeShortString: () => decodeShortString,\n  encodeShortString: () => encodeShortString,\n  isASCII: () => isASCII,\n  isDecimalString: () => isDecimalString,\n  isLongText: () => isLongText,\n  isShortString: () => isShortString,\n  isShortText: () => isShortText,\n  isText: () => isText,\n  splitLongString: () => splitLongString\n});\nfunction isASCII(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n  return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n  return /^[0-9]*$/i.test(str);\n}\nfunction isText(val) {\n  return typeof val === \"string\" && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val) => isText(val) && isShortString(val);\nvar isLongText = (val) => isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n  const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n  return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n  if (!isASCII(str))\n    throw new Error(`${str} is not an ASCII string`);\n  if (!isShortString(str))\n    throw new Error(`${str} is too long`);\n  return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n  if (!isASCII(str))\n    throw new Error(`${str} is not an ASCII string`);\n  if (isHex(str)) {\n    return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));\n  }\n  if (isDecimalString(str)) {\n    return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n  }\n  throw new Error(`${str} is not Hex or decimal`);\n}\n\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n  felt: () => felt,\n  getAbiContractVersion: () => getAbiContractVersion,\n  getArrayType: () => getArrayType,\n  isCairo1Abi: () => isCairo1Abi,\n  isCairo1Type: () => isCairo1Type,\n  isLen: () => isLen,\n  isTypeArray: () => isTypeArray,\n  isTypeBool: () => isTypeBool,\n  isTypeContractAddress: () => isTypeContractAddress,\n  isTypeEnum: () => isTypeEnum,\n  isTypeEthAddress: () => isTypeEthAddress,\n  isTypeFelt: () => isTypeFelt,\n  isTypeLitteral: () => isTypeLitteral,\n  isTypeNamedTuple: () => isTypeNamedTuple,\n  isTypeOption: () => isTypeOption,\n  isTypeResult: () => isTypeResult,\n  isTypeStruct: () => isTypeStruct,\n  isTypeTuple: () => isTypeTuple,\n  isTypeUint: () => isTypeUint,\n  isTypeUint256: () => isTypeUint256,\n  tuple: () => tuple,\n  uint256: () => uint256\n});\n\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n  UINT_128_MAX: () => UINT_128_MAX,\n  UINT_256_MAX: () => UINT_256_MAX,\n  bnToUint256: () => bnToUint256,\n  isUint256: () => isUint256,\n  uint256ToBN: () => uint256ToBN\n});\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nfunction uint256ToBN(uint2562) {\n  return (toBigInt(uint2562.high) << 128n) + toBigInt(uint2562.low);\n}\nfunction isUint256(bn) {\n  return toBigInt(bn) <= UINT_256_MAX;\n}\nfunction bnToUint256(bn) {\n  const bi = toBigInt(bn);\n  if (!isUint256(bi))\n    throw new Error(\"Number is too large\");\n  return {\n    low: addHexPrefix((bi & UINT_128_MAX).toString(16)),\n    high: addHexPrefix((bi >> 128n).toString(16))\n  };\n}\n\n// src/utils/calldata/cairo.ts\nvar isLen = (name) => /_len$/.test(name);\nvar isTypeFelt = (type) => type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type) => /\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type) => /^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type) => /\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs) => type in structs;\nvar isTypeEnum = (type, enums) => type in enums;\nvar isTypeOption = (type) => type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type) => type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type) => Object.values(Uint).includes(type);\nvar isTypeLitteral = (type) => Object.values(Litteral).includes(type);\nvar isTypeUint256 = (type) => type === \"core::integer::u256\";\nvar isTypeBool = (type) => type === \"core::bool\";\nvar isTypeContractAddress = (type) => type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type) => type === \"core::starknet::eth_address::EthAddress\";\nvar isCairo1Type = (type) => type.includes(\"::\");\nvar getArrayType = (type) => {\n  if (isCairo1Type(type)) {\n    return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n  }\n  return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n  const { cairo } = getAbiContractVersion(abi);\n  if (cairo === void 0) {\n    throw Error(\"Unable to determine Cairo version\");\n  }\n  return cairo === \"1\";\n}\nfunction getAbiContractVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\")) {\n    return { cairo: \"1\", compiler: \"2\" };\n  }\n  const testFunction = abi.find(\n    (it) => it.type === \"function\" && (it.inputs.length || it.outputs.length)\n  );\n  if (!testFunction) {\n    return { cairo: void 0, compiler: void 0 };\n  }\n  const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n  if (isCairo1Type(io[0].type)) {\n    return { cairo: \"1\", compiler: \"1\" };\n  }\n  return { cairo: \"0\", compiler: \"0\" };\n}\nvar uint256 = (it) => {\n  const bn = BigInt(it);\n  if (!isUint256(bn))\n    throw new Error(\"Number is too large\");\n  return {\n    // eslint-disable-next-line no-bitwise\n    low: (bn & UINT_128_MAX).toString(10),\n    // eslint-disable-next-line no-bitwise\n    high: (bn >> 128n).toString(10)\n  };\n};\nvar tuple = (...args) => ({ ...args });\nfunction felt(it) {\n  if (isBigInt(it) || typeof it === \"number\" && Number.isInteger(it)) {\n    return it.toString();\n  }\n  if (isText(it)) {\n    if (!isShortString(it))\n      throw new Error(\n        `${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`\n      );\n    const encoded = encodeShortString(it);\n    return BigInt(encoded).toString();\n  }\n  if (typeof it === \"string\" && isHex(it)) {\n    return BigInt(it).toString();\n  }\n  if (typeof it === \"string\" && isStringWholeNumber(it)) {\n    return it;\n  }\n  if (typeof it === \"boolean\") {\n    return `${+it}`;\n  }\n  throw new Error(`${it} can't be computed by felt()`);\n}\n\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n  /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */\n  constructor(enumContent) {\n    const variantsList = Object.values(enumContent);\n    if (variantsList.length === 0) {\n      throw new Error(\"This Enum must have a least 1 variant\");\n    }\n    const nbActiveVariants = variantsList.filter(\n      (content) => typeof content !== \"undefined\"\n    ).length;\n    if (nbActiveVariants !== 1) {\n      throw new Error(\"This Enum must have exactly one active variant\");\n    }\n    this.variant = enumContent;\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */\n  unwrap() {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== \"undefined\");\n    if (typeof activeVariant === \"undefined\") {\n      return void 0;\n    }\n    return activeVariant[1];\n  }\n  /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */\n  activeVariant() {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== \"undefined\");\n    if (typeof activeVariant === \"undefined\") {\n      return \"\";\n    }\n    return activeVariant[0];\n  }\n};\n\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2) => {\n  CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n  CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n  return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n  constructor(variant, someContent) {\n    if (!(variant in CairoOptionVariant)) {\n      throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n    }\n    if (variant === 0 /* Some */) {\n      if (typeof someContent === \"undefined\") {\n        throw new Error(\n          'The creation of a Cairo Option with \"Some\" variant needs a content as input.'\n        );\n      }\n      this.Some = someContent;\n      this.None = void 0;\n    } else {\n      this.Some = void 0;\n      this.None = true;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */\n  unwrap() {\n    if (this.None) {\n      return void 0;\n    }\n    return this.Some;\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */\n  isSome() {\n    return !(typeof this.Some === \"undefined\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */\n  isNone() {\n    return this.None === true;\n  }\n};\n\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2) => {\n  CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n  CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n  return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n  constructor(variant, resultContent) {\n    if (!(variant in CairoResultVariant)) {\n      throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n    }\n    if (variant === 0 /* Ok */) {\n      this.Ok = resultContent;\n      this.Err = void 0;\n    } else {\n      this.Ok = void 0;\n      this.Err = resultContent;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */\n  unwrap() {\n    if (typeof this.Ok !== \"undefined\") {\n      return this.Ok;\n    }\n    if (typeof this.Err !== \"undefined\") {\n      return this.Err;\n    }\n    throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */\n  isOk() {\n    return !(typeof this.Ok === \"undefined\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */\n  isErr() {\n    return !(typeof this.Err === \"undefined\");\n  }\n};\n\n// src/utils/calldata/formatter.ts\nvar guard = {\n  isBN: (data, type, key) => {\n    if (!isBigInt(data[key]))\n      throw new Error(\n        `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`\n      );\n  },\n  unknown: (data, type, key) => {\n    throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n  }\n};\nfunction formatter(data, type, sameType) {\n  return Object.entries(data).reduce((acc, [key, value]) => {\n    const elType = sameType ?? type[key];\n    if (!(key in type) && !sameType) {\n      acc[key] = value;\n      return acc;\n    }\n    if (elType === \"string\") {\n      if (Array.isArray(data[key])) {\n        const arrayStr = formatter(\n          data[key],\n          data[key].map((_) => elType)\n        );\n        acc[key] = Object.values(arrayStr).join(\"\");\n        return acc;\n      }\n      guard.isBN(data, type, key);\n      acc[key] = decodeShortString(value);\n      return acc;\n    }\n    if (elType === \"number\") {\n      guard.isBN(data, type, key);\n      acc[key] = Number(value);\n      return acc;\n    }\n    if (typeof elType === \"function\") {\n      acc[key] = elType(value);\n      return acc;\n    }\n    if (Array.isArray(elType)) {\n      const arrayObj = formatter(data[key], elType, elType[0]);\n      acc[key] = Object.values(arrayObj);\n      return acc;\n    }\n    if (typeof elType === \"object\") {\n      acc[key] = formatter(data[key], elType);\n      return acc;\n    }\n    guard.unknown(data, type, key);\n    return acc;\n  }, {});\n}\n\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.reduce((acc, input) => !isLen(input.name) ? acc + 1 : acc, 0);\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    return this.abi.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi;\n  }\n};\n\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.length;\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    const intf = this.abi.find((it) => it.type === \"interface\");\n    return intf.items.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi.flatMap((e) => {\n      if (e.type === \"interface\") {\n        return e.items;\n      }\n      return e;\n    });\n  }\n};\n\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n  const version = getAbiVersion(abi);\n  if (version === 0 || version === 1) {\n    return new AbiParser1(abi);\n  }\n  if (version === 2) {\n    return new AbiParser2(abi);\n  }\n  throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\"))\n    return 2;\n  if (isCairo1Abi(abi))\n    return 1;\n  return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n  return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n  const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n  const type = namedTuple.substring(name.length + \":\".length);\n  return { name, type };\n}\nfunction parseSubTuple(s) {\n  if (!s.includes(\"(\"))\n    return { subTuple: [], result: s };\n  const subTuple = [];\n  let result = \"\";\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === \"(\") {\n      let counter = 1;\n      const lBracket = i;\n      i++;\n      while (counter) {\n        if (s[i] === \")\")\n          counter--;\n        if (s[i] === \"(\")\n          counter++;\n        i++;\n      }\n      subTuple.push(s.substring(lBracket, i));\n      result += \" \";\n      i--;\n    } else {\n      result += s[i];\n    }\n    i++;\n  }\n  return {\n    subTuple,\n    result\n  };\n}\nfunction extractCairo0Tuple(type) {\n  const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n  const { subTuple, result } = parseSubTuple(cleanType);\n  let recomposed = result.split(\",\").map((it) => {\n    return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n  });\n  if (isTypeNamedTuple(type)) {\n    recomposed = recomposed.reduce((acc, it) => {\n      return acc.concat(parseNamedTuple(it));\n    }, []);\n  }\n  return recomposed;\n}\nfunction extractCairo1Tuple(type) {\n  const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n  const { subTuple, result } = parseSubTuple(cleanType);\n  const recomposed = result.split(\",\").map((it) => {\n    return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n  });\n  return recomposed;\n}\nfunction extractTupleMemberTypes(type) {\n  if (isCairo1Type(type)) {\n    return extractCairo1Tuple(type);\n  }\n  return extractCairo0Tuple(type);\n}\n\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`\n  );\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n  const orderInput = (unorderedItem, abiType) => {\n    if (isTypeArray(abiType)) {\n      return orderArray(unorderedItem, abiType);\n    }\n    if (isTypeEnum(abiType, enums)) {\n      const abiObj = enums[abiType];\n      return orderEnum(unorderedItem, abiObj);\n    }\n    if (isTypeTuple(abiType)) {\n      return orderTuple(unorderedItem, abiType);\n    }\n    if (isTypeEthAddress(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeUint256(abiType)) {\n      const u256 = unorderedItem;\n      if (typeof u256 !== \"object\") {\n        return u256;\n      }\n      if (!(\"low\" in u256 && \"high\" in u256)) {\n        throw errorU256(abiType);\n      }\n      return { low: u256.low, high: u256.high };\n    }\n    if (isTypeStruct(abiType, structs)) {\n      const abiOfStruct = structs[abiType].members;\n      return orderStruct(unorderedItem, abiOfStruct);\n    }\n    return unorderedItem;\n  };\n  const orderStruct = (unorderedObject2, abiObject) => {\n    const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {\n      const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n        enumerable: true,\n        value: value ?? unorderedObject2[abiParam.name]\n      });\n      if (unorderedObject2[abiParam.name] === \"undefined\") {\n        if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n          throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n        }\n      }\n      setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  };\n  function orderArray(myArray, abiParam) {\n    const typeInArray = getArrayType(abiParam);\n    if (typeof myArray === \"string\") {\n      return myArray;\n    }\n    return myArray.map((myElem) => orderInput(myElem, typeInArray));\n  }\n  function orderTuple(unorderedObject2, abiParam) {\n    const typeList = extractTupleMemberTypes(abiParam);\n    const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index) => {\n      const myObjKeys = Object.keys(unorderedObject2);\n      const setProperty = (value) => Object.defineProperty(orderedObject, index.toString(), {\n        enumerable: true,\n        value: value ?? unorderedObject2[myObjKeys[index]]\n      });\n      const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n      setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  }\n  const orderEnum = (unorderedObject2, abiObject) => {\n    if (isTypeResult(abiObject.name)) {\n      const unorderedResult = unorderedObject2;\n      const resultOkType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\",\")\n      );\n      const resultErrType = abiObject.name.substring(\n        abiObject.name.indexOf(\",\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedResult.isOk()) {\n        return new CairoResult(\n          0 /* Ok */,\n          orderInput(unorderedObject2.unwrap(), resultOkType)\n        );\n      }\n      return new CairoResult(\n        1 /* Err */,\n        orderInput(unorderedObject2.unwrap(), resultErrType)\n      );\n    }\n    if (isTypeOption(abiObject.name)) {\n      const unorderedOption = unorderedObject2;\n      const resultSomeType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedOption.isSome()) {\n        return new CairoOption(\n          0 /* Some */,\n          orderInput(unorderedOption.unwrap(), resultSomeType)\n        );\n      }\n      return new CairoOption(1 /* None */, {});\n    }\n    const unorderedCustomEnum = unorderedObject2;\n    const variants = Object.entries(unorderedCustomEnum.variant);\n    const newEntries = variants.map((variant) => {\n      if (typeof variant[1] === \"undefined\") {\n        return variant;\n      }\n      const variantType = abiObject.type.substring(\n        abiObject.type.lastIndexOf(\"<\") + 1,\n        abiObject.type.lastIndexOf(\">\")\n      );\n      if (variantType === \"()\") {\n        return variant;\n      }\n      return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];\n    });\n    return new CairoCustomEnum(Object.fromEntries(newEntries));\n  };\n  const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {\n    const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n      enumerable: true,\n      value\n    });\n    if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n      return orderedObject;\n    }\n    setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n    return orderedObject;\n  }, {});\n  return finalOrderedObject;\n}\n\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n  switch (true) {\n    case isTypeUint256(type):\n      const el_uint256 = uint256(val);\n      return [felt(el_uint256.low), felt(el_uint256.high)];\n    default:\n      return felt(val);\n  }\n}\nfunction parseTuple(element, typeStr) {\n  const memberTypes = extractTupleMemberTypes(typeStr);\n  const elements = Object.values(element);\n  if (elements.length !== memberTypes.length) {\n    throw Error(\n      `ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`\n    );\n  }\n  return memberTypes.map((it, dx) => {\n    return {\n      element: elements[dx],\n      type: it.type ?? it\n    };\n  });\n}\nfunction parseUint256(element) {\n  if (typeof element === \"object\") {\n    const { low, high } = element;\n    return [felt(low), felt(high)];\n  }\n  const el_uint256 = uint256(element);\n  return [felt(el_uint256.low), felt(el_uint256.high)];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n  if (element === void 0) {\n    throw Error(`Missing parameter for type ${type}`);\n  }\n  if (Array.isArray(element)) {\n    const result = [];\n    result.push(felt(element.length));\n    const arrayType = getArrayType(type);\n    return element.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, result);\n  }\n  if (structs[type] && structs[type].members.length) {\n    if (isTypeUint256(type)) {\n      return parseUint256(element);\n    }\n    if (type === \"core::starknet::eth_address::EthAddress\")\n      return parseBaseTypes(type, element);\n    const { members } = structs[type];\n    const subElement = element;\n    return members.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n    }, []);\n  }\n  if (isTypeTuple(type)) {\n    const tupled = parseTuple(element, type);\n    return tupled.reduce((acc, it) => {\n      const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n      return acc.concat(parsedData);\n    }, []);\n  }\n  if (isTypeUint256(type)) {\n    return parseUint256(element);\n  }\n  if (isTypeEnum(type, enums)) {\n    const { variants } = enums[type];\n    if (isTypeOption(type)) {\n      const myOption = element;\n      if (myOption.isSome()) {\n        const listTypeVariant2 = variants.find((variant) => variant.name === \"Some\");\n        if (typeof listTypeVariant2 === \"undefined\") {\n          throw Error(`Error in abi : Option has no 'Some' variant.`);\n        }\n        const typeVariantSome = listTypeVariant2.type;\n        if (typeVariantSome === \"()\") {\n          return 0 /* Some */.toString();\n        }\n        const parsedParameter2 = parseCalldataValue(\n          myOption.unwrap(),\n          typeVariantSome,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter2)) {\n          return [0 /* Some */.toString(), ...parsedParameter2];\n        }\n        return [0 /* Some */.toString(), parsedParameter2];\n      }\n      return 1 /* None */.toString();\n    }\n    if (isTypeResult(type)) {\n      const myResult = element;\n      if (myResult.isOk()) {\n        const listTypeVariant3 = variants.find((variant) => variant.name === \"Ok\");\n        if (typeof listTypeVariant3 === \"undefined\") {\n          throw Error(`Error in abi : Result has no 'Ok' variant.`);\n        }\n        const typeVariantOk = listTypeVariant3.type;\n        if (typeVariantOk === \"()\") {\n          return 0 /* Ok */.toString();\n        }\n        const parsedParameter3 = parseCalldataValue(\n          myResult.unwrap(),\n          typeVariantOk,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter3)) {\n          return [0 /* Ok */.toString(), ...parsedParameter3];\n        }\n        return [0 /* Ok */.toString(), parsedParameter3];\n      }\n      const listTypeVariant2 = variants.find((variant) => variant.name === \"Err\");\n      if (typeof listTypeVariant2 === \"undefined\") {\n        throw Error(`Error in abi : Result has no 'Err' variant.`);\n      }\n      const typeVariantErr = listTypeVariant2.type;\n      if (typeVariantErr === \"()\") {\n        return 1 /* Err */.toString();\n      }\n      const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n      if (Array.isArray(parsedParameter2)) {\n        return [1 /* Err */.toString(), ...parsedParameter2];\n      }\n      return [1 /* Err */.toString(), parsedParameter2];\n    }\n    const myEnum = element;\n    const activeVariant = myEnum.activeVariant();\n    const listTypeVariant = variants.find((variant) => variant.name === activeVariant);\n    if (typeof listTypeVariant === \"undefined\") {\n      throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n    }\n    const typeActiveVariant = listTypeVariant.type;\n    const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant);\n    if (typeActiveVariant === \"()\") {\n      return numActiveVariant.toString();\n    }\n    const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n    if (Array.isArray(parsedParameter)) {\n      return [numActiveVariant.toString(), ...parsedParameter];\n    }\n    return [numActiveVariant.toString(), parsedParameter];\n  }\n  if (typeof element === \"object\") {\n    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n  }\n  return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n  const { name, type } = input;\n  let { value } = argsIterator.next();\n  switch (true) {\n    case isTypeArray(type):\n      if (!Array.isArray(value) && !isText(value)) {\n        throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n      }\n      if (typeof value === \"string\") {\n        value = splitLongString(value);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n    case type === \"core::starknet::eth_address::EthAddress\":\n      return parseBaseTypes(type, value);\n    case (isTypeStruct(type, structs) || isTypeTuple(type) || isTypeUint256(type)):\n      return parseCalldataValue(value, type, structs, enums);\n    case isTypeEnum(type, enums):\n      return parseCalldataValue(\n        value,\n        type,\n        structs,\n        enums\n      );\n    default:\n      return parseBaseTypes(type, value);\n  }\n}\n\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n  let temp;\n  switch (true) {\n    case isTypeBool(type):\n      temp = it.next().value;\n      return Boolean(BigInt(temp));\n    case isTypeUint256(type):\n      const low = it.next().value;\n      const high = it.next().value;\n      return uint256ToBN({ low, high });\n    case type === \"core::starknet::eth_address::EthAddress\":\n      temp = it.next().value;\n      return BigInt(temp);\n    default:\n      temp = it.next().value;\n      return BigInt(temp);\n  }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n  if (element.type === \"()\") {\n    return {};\n  }\n  if (isTypeUint256(element.type)) {\n    const low = responseIterator.next().value;\n    const high = responseIterator.next().value;\n    return uint256ToBN({ low, high });\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  if (structs && element.type in structs && structs[element.type]) {\n    if (element.type === \"core::starknet::eth_address::EthAddress\") {\n      return parseBaseTypes2(element.type, responseIterator);\n    }\n    return structs[element.type].members.reduce((acc, el) => {\n      acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (enums && element.type in enums && enums[element.type]) {\n    const variantNum = Number(responseIterator.next().value);\n    const rawEnum = enums[element.type].variants.reduce((acc, variant, num) => {\n      if (num === variantNum) {\n        acc[variant.name] = parseResponseValue(\n          responseIterator,\n          { name: \"\", type: variant.type },\n          structs,\n          enums\n        );\n        return acc;\n      }\n      acc[variant.name] = void 0;\n      return acc;\n    }, {});\n    if (element.type.startsWith(\"core::option::Option\")) {\n      const content = variantNum === 0 /* Some */ ? rawEnum.Some : void 0;\n      return new CairoOption(variantNum, content);\n    }\n    if (element.type.startsWith(\"core::result::Result\")) {\n      let content;\n      if (variantNum === 0 /* Ok */) {\n        content = rawEnum.Ok;\n      } else {\n        content = rawEnum.Err;\n      }\n      return new CairoResult(variantNum, content);\n    }\n    const customEnum = new CairoCustomEnum(rawEnum);\n    return customEnum;\n  }\n  if (isTypeTuple(element.type)) {\n    const memberTypes = extractTupleMemberTypes(element.type);\n    return memberTypes.reduce((acc, it, idx) => {\n      const name = it?.name ? it.name : idx;\n      const type = it?.type ? it.type : it;\n      const el = { name, type };\n      acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n  const { name, type } = output;\n  let temp;\n  switch (true) {\n    case isLen(name):\n      temp = responseIterator.next().value;\n      return BigInt(temp);\n    case (structs && type in structs || isTypeTuple(type)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case (enums && isTypeEnum(type, enums)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case isTypeArray(type):\n      if (isCairo1Type(type)) {\n        return parseResponseValue(responseIterator, output, structs, enums);\n      }\n      const parsedDataArr = [];\n      if (parsedResult && parsedResult[`${name}_len`]) {\n        const arrLen = parsedResult[`${name}_len`];\n        while (parsedDataArr.length < arrLen) {\n          parsedDataArr.push(\n            parseResponseValue(\n              responseIterator,\n              { name, type: output.type.replace(\"*\", \"\") },\n              structs,\n              enums\n            )\n          );\n        }\n      }\n      return parsedDataArr;\n    default:\n      return parseBaseTypes2(type, responseIterator);\n  }\n}\n\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input) => {\n  assert(\n    typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\",\n    `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`\n  );\n  if (typeof parameter === \"string\" && !isHex(parameter))\n    return;\n  const param = BigInt(parameter.toString(10));\n  assert(\n    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n  );\n};\nvar validateUint = (parameter, input) => {\n  if (typeof parameter === \"number\") {\n    assert(\n      parameter <= Number.MAX_SAFE_INTEGER,\n      `Validation: Parameter is to large to be typed as Number use (BigInt or String)`\n    );\n  }\n  assert(\n    typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\" || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter,\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`\n  );\n  const param = typeof parameter === \"object\" ? uint256ToBN(parameter) : toBigInt(parameter);\n  switch (input.type) {\n    case \"core::integer::u8\" /* u8 */:\n      assert(\n        param >= 0n && param <= 255n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`\n      );\n      break;\n    case \"core::integer::u16\" /* u16 */:\n      assert(\n        param >= 0n && param <= 65535n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`\n      );\n      break;\n    case \"core::integer::u32\" /* u32 */:\n      assert(\n        param >= 0n && param <= 4294967295n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`\n      );\n      break;\n    case \"core::integer::u64\" /* u64 */:\n      assert(\n        param >= 0n && param <= 2n ** 64n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`\n      );\n      break;\n    case \"core::integer::u128\" /* u128 */:\n      assert(\n        param >= 0n && param <= 2n ** 128n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`\n      );\n      break;\n    case \"core::integer::u256\" /* u256 */:\n      assert(\n        param >= 0n && param <= 2n ** 256n - 1n,\n        `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`\n      );\n      break;\n    case \"core::starknet::class_hash::ClassHash\" /* ClassHash */:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    default:\n      break;\n  }\n};\nvar validateBool = (parameter, input) => {\n  assert(\n    typeof parameter === \"boolean\",\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`\n  );\n};\nvar validateStruct = (parameter, input, structs) => {\n  if (input.type === \"core::integer::u256\" /* u256 */) {\n    validateUint(parameter, input);\n    return;\n  }\n  if (input.type === \"core::starknet::eth_address::EthAddress\") {\n    assert(\n      typeof parameter !== \"object\",\n      `EthAddress type is waiting a BigNumberish. Got ${parameter}`\n    );\n    const param = BigInt(parameter.toString(10));\n    assert(\n      // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n      param >= 0n && param <= 2n ** 160n - 1n,\n      `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`\n    );\n    return;\n  }\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`\n  );\n  structs[input.type].members.forEach(({ name }) => {\n    assert(\n      Object.keys(parameter).includes(name),\n      `Validate: arg ${input.name} should have a property ${name}`\n    );\n  });\n};\nvar validateEnum = (parameter, input) => {\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`\n  );\n  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n  const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];\n  if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n    return;\n  }\n  if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n    return;\n  }\n  if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n    return;\n  }\n  throw new Error(\n    `Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`\n  );\n};\nvar validateTuple = (parameter, input) => {\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} should be a tuple (defined as object)`\n  );\n};\nvar validateArray = (parameter, input, structs, enums) => {\n  const baseType = getArrayType(input.type);\n  if (isTypeFelt(baseType) && isLongText(parameter)) {\n    return;\n  }\n  assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n  switch (true) {\n    case isTypeFelt(baseType):\n      parameter.forEach((param) => validateFelt(param, input));\n      break;\n    case isTypeTuple(baseType):\n      parameter.forEach((it) => validateTuple(it, { name: input.name, type: baseType }));\n      break;\n    case isTypeArray(baseType):\n      parameter.forEach(\n        (param) => validateArray(param, { name: \"\", type: baseType }, structs, enums)\n      );\n      break;\n    case isTypeStruct(baseType, structs):\n      parameter.forEach(\n        (it) => validateStruct(it, { name: input.name, type: baseType }, structs)\n      );\n      break;\n    case isTypeEnum(baseType, enums):\n      parameter.forEach((it) => validateEnum(it, { name: input.name, type: baseType }));\n      break;\n    case (isTypeUint(baseType) || isTypeLitteral(baseType)):\n      parameter.forEach((param) => validateUint(param, input));\n      break;\n    case isTypeBool(baseType):\n      parameter.forEach((param) => validateBool(param, input));\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n  abiMethod.inputs.reduce((acc, input) => {\n    const parameter = args[acc];\n    switch (true) {\n      case isLen(input.name):\n        return acc;\n      case isTypeFelt(input.type):\n        validateFelt(parameter, input);\n        break;\n      case (isTypeUint(input.type) || isTypeLitteral(input.type)):\n        validateUint(parameter, input);\n        break;\n      case isTypeBool(input.type):\n        validateBool(parameter, input);\n        break;\n      case isTypeArray(input.type):\n        validateArray(parameter, input, structs, enums);\n        break;\n      case isTypeStruct(input.type, structs):\n        validateStruct(parameter, input, structs);\n        break;\n      case isTypeEnum(input.type, enums):\n        validateEnum(parameter, input);\n        break;\n      case isTypeTuple(input.type):\n        validateTuple(parameter, input);\n        break;\n      default:\n        throw new Error(\n          `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n        );\n    }\n    return acc + 1;\n  }, 0);\n}\n\n// src/utils/calldata/index.ts\nvar CallData = class {\n  constructor(abi) {\n    this.structs = CallData.getAbiStruct(abi);\n    this.enums = CallData.getAbiEnum(abi);\n    this.parser = createAbiParser(abi);\n    this.abi = this.parser.getLegacyFormat();\n  }\n  /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */\n  validate(type, method, args = []) {\n    if (type !== \"DEPLOY\" /* DEPLOY */) {\n      const invocableFunctionNames = this.abi.filter((abi) => {\n        if (abi.type !== \"function\")\n          return false;\n        const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n        return type === \"INVOKE\" /* INVOKE */ ? !isView : isView;\n      }).map((abi) => abi.name);\n      assert(\n        invocableFunctionNames.includes(method),\n        `${type === \"INVOKE\" /* INVOKE */ ? \"invocable\" : \"viewable\"} method not found in abi`\n      );\n    }\n    const abiMethod = this.abi.find(\n      (abi) => type === \"DEPLOY\" /* DEPLOY */ ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\"\n    );\n    if (isNoConstructorValid(method, args, abiMethod)) {\n      return;\n    }\n    const inputsLength = this.parser.methodInputsLength(abiMethod);\n    if (args.length !== inputsLength) {\n      throw Error(\n        `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`\n      );\n    }\n    validateFields(abiMethod, args, this.structs, this.enums);\n  }\n  /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */\n  compile(method, argsCalldata) {\n    const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method);\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n      return [];\n    }\n    let args;\n    if (Array.isArray(argsCalldata)) {\n      args = argsCalldata;\n    } else {\n      const orderedObject = orderPropsByAbi(\n        argsCalldata,\n        abiMethod.inputs,\n        this.structs,\n        this.enums\n      );\n      args = Object.values(orderedObject);\n      validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    const argsIterator = args[Symbol.iterator]();\n    const callArray = abiMethod.inputs.reduce(\n      (acc, input) => isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),\n      []\n    );\n    Object.defineProperty(callArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callArray;\n  }\n  /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */\n  static compile(rawArgs) {\n    const createTree = (obj) => {\n      const getEntries = (o, prefix = \".\") => {\n        const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;\n        return Object.entries(oe).flatMap(([k, v]) => {\n          let value = v;\n          if (k === \"entrypoint\")\n            value = getSelectorFromName(value);\n          else if (isLongText(value))\n            value = splitLongString(value);\n          const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n          if (isBigInt(value))\n            return [[`${prefix}${kk}`, felt(value)]];\n          if (Object(value) === value) {\n            const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n            const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];\n            if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n              const myOption = value;\n              const variantNb = myOption.isSome() ? 0 /* Some */ : 1 /* None */;\n              if (myOption.isSome())\n                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);\n              return [[`${prefix}${kk}`, felt(variantNb)]];\n            }\n            if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n              const myResult = value;\n              const variantNb = myResult.isOk() ? 0 /* Ok */ : 1 /* Err */;\n              return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);\n            }\n            if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n              const myEnum = value;\n              const activeVariant = myEnum.activeVariant();\n              const listVariants = Object.keys(myEnum.variant);\n              const activeVariantNb = listVariants.findIndex(\n                (variant) => variant === activeVariant\n              );\n              if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                return [[`${prefix}${kk}`, felt(activeVariantNb)]];\n              }\n              return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);\n            }\n            return getEntries(value, `${prefix}${kk}.`);\n          }\n          return [[`${prefix}${kk}`, felt(value)]];\n        });\n      };\n      const result = Object.fromEntries(getEntries(obj));\n      return result;\n    };\n    let callTreeArray;\n    if (!Array.isArray(rawArgs)) {\n      const callTree = createTree(rawArgs);\n      callTreeArray = Object.values(callTree);\n    } else {\n      const callObj = { ...rawArgs };\n      const callTree = createTree(callObj);\n      callTreeArray = Object.values(callTree);\n    }\n    Object.defineProperty(callTreeArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callTreeArray;\n  }\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */\n  parse(method, response) {\n    const { outputs } = this.abi.find((abi) => abi.name === method);\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const parsed = outputs.flat().reduce((acc, output, idx) => {\n      const propName = output.name ?? idx;\n      acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n      if (acc[propName] && acc[`${propName}_len`]) {\n        delete acc[`${propName}_len`];\n      }\n      return acc;\n    }, {});\n    return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n  }\n  /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */\n  format(method, response, format) {\n    const parsed = this.parse(method, response);\n    return formatter(parsed, format);\n  }\n  /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */\n  static getAbiStruct(abi) {\n    return abi.filter((abiEntry) => abiEntry.type === \"struct\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n  }\n  /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */\n  static getAbiEnum(abi) {\n    const fullEnumList = abi.filter((abiEntry) => abiEntry.type === \"enum\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n    delete fullEnumList[\"core::bool\"];\n    return fullEnumList;\n  }\n  /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */\n  static toCalldata(rawCalldata = []) {\n    return CallData.compile(rawCalldata);\n  }\n  /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */\n  static toHex(raw = []) {\n    const calldata = CallData.compile(raw);\n    return calldata.map((it) => toHex(it));\n  }\n};\n\n// src/utils/hash.ts\nvar hash_exports = {};\n__export(hash_exports, {\n  calculateContractAddressFromHash: () => calculateContractAddressFromHash,\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash,\n  calculateDeployTransactionHash: () => calculateDeployTransactionHash,\n  calculateTransactionHash: () => calculateTransactionHash,\n  calculateTransactionHashCommon: () => calculateTransactionHashCommon,\n  computeCompiledClassHash: () => computeCompiledClassHash,\n  computeContractClassHash: () => computeContractClassHash,\n  computeHashOnElements: () => computeHashOnElements,\n  computeLegacyContractClassHash: () => computeLegacyContractClassHash,\n  computeSierraContractClassHash: () => computeSierraContractClassHash,\n  default: () => computeHintedClassHash,\n  feeTransactionVersion: () => feeTransactionVersion,\n  feeTransactionVersion_2: () => feeTransactionVersion_2,\n  formatSpaces: () => formatSpaces,\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  getVersionsByType: () => getVersionsByType,\n  keccakBn: () => keccakBn,\n  poseidon: () => _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__,\n  starknetKeccak: () => starknetKeccak,\n  transactionVersion: () => transactionVersion,\n  transactionVersion_2: () => transactionVersion_2\n});\n\n\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n  starkCurve: () => _scure_starknet__WEBPACK_IMPORTED_MODULE_2__,\n  weierstrass: () => _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__\n});\n\n\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n  parse: () => parse2,\n  parseAlwaysAsBig: () => parseAlwaysAsBig,\n  stringify: () => stringify2,\n  stringifyAlwaysAsBig: () => stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (x) => {\n  if (!lossless_json__WEBPACK_IMPORTED_MODULE_5__.isInteger(x))\n    return parseFloat(x);\n  const v = parseInt(x, 10);\n  return Number.isSafeInteger(v) ? v : BigInt(x);\n};\nvar parse2 = (x) => lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (x) => lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_5__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers) => lossless_json__WEBPACK_IMPORTED_MODULE_5__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n\n// src/utils/hash.ts\n\nvar transactionVersion = BN_TRANSACTION_VERSION_1;\nvar transactionVersion_2 = BN_TRANSACTION_VERSION_2;\nvar feeTransactionVersion = BN_FEE_TRANSACTION_VERSION_1;\nvar feeTransactionVersion_2 = BN_FEE_TRANSACTION_VERSION_2;\nfunction getVersionsByType(versionType) {\n  return versionType === \"fee\" ? { v1: feeTransactionVersion, v2: feeTransactionVersion_2 } : { v1: transactionVersion, v2: transactionVersion_2 };\n}\nfunction computeHashOnElements(data) {\n  return [...data, data.length].reduce((x, y) => _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(toBigInt(x), toBigInt(y)), 0).toString();\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n  const calldataHash = computeHashOnElements(calldata);\n  const dataToHash = [\n    txHashPrefix,\n    version,\n    contractAddress,\n    entryPointSelector,\n    calldataHash,\n    maxFee,\n    chainId,\n    ...additionalData\n  ];\n  return computeHashOnElements(dataToHash);\n}\nfunction calculateDeployTransactionHash(contractAddress, constructorCalldata, version, chainId, constructorName = \"constructor\") {\n  return calculateTransactionHashCommon(\n    \"0x6465706c6f79\" /* DEPLOY */,\n    version,\n    contractAddress,\n    getSelectorFromName(constructorName),\n    constructorCalldata,\n    0,\n    chainId\n  );\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n  return calculateTransactionHashCommon(\n    \"0x6465636c617265\" /* DECLARE */,\n    version,\n    senderAddress,\n    0,\n    [classHash],\n    maxFee,\n    chainId,\n    [nonce, ...compiledClassHash ? [compiledClassHash] : []]\n  );\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n  const calldata = [classHash, salt, ...constructorCalldata];\n  return calculateTransactionHashCommon(\n    \"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n  return calculateTransactionHashCommon(\n    \"0x696e766f6b65\" /* INVOKE */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n  const compiledCalldata = CallData.compile(constructorCalldata);\n  const constructorCalldataHash = computeHashOnElements(compiledCalldata);\n  const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n  const hash = computeHashOnElements([\n    CONTRACT_ADDRESS_PREFIX,\n    deployerAddress,\n    salt,\n    classHash,\n    constructorCalldataHash\n  ]);\n  return toHex(BigInt(hash) % ADDR_BOUND);\n}\nfunction nullSkipReplacer(key, value) {\n  if (key === \"attributes\" || key === \"accessible_scopes\") {\n    return Array.isArray(value) && value.length === 0 ? void 0 : value;\n  }\n  if (key === \"debug_info\") {\n    return null;\n  }\n  return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n  let insideQuotes = false;\n  const newString = [];\n  for (const char of json2) {\n    if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n      insideQuotes = !insideQuotes;\n    }\n    if (insideQuotes) {\n      newString.push(char);\n    } else {\n      newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n    }\n  }\n  return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n  const { abi, program } = compiledContract;\n  const contractClass = { abi, program };\n  const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n  return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n  const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n  const apiVersion = toHex(API_VERSION);\n  const externalEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])\n  );\n  const l1HandlerEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])\n  );\n  const constructorEntryPointHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])\n  );\n  const builtinsHash = computeHashOnElements(\n    compiledContract.program.builtins.map((s) => encodeShortString(s))\n  );\n  const hintedClassHash = computeHintedClassHash(compiledContract);\n  const dataHash = computeHashOnElements(compiledContract.program.data);\n  return computeHashOnElements([\n    apiVersion,\n    externalEntryPointsHash,\n    l1HandlerEntryPointsHash,\n    constructorEntryPointHash,\n    builtinsHash,\n    hintedClassHash,\n    dataHash\n  ]);\n}\nfunction hashBuiltins(builtins) {\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(\n    builtins.flatMap((it) => {\n      return BigInt(encodeShortString(it));\n    })\n  );\n}\nfunction hashEntryPoint(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction computeCompiledClassHash(casm) {\n  const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n  const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n  const bytecode = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(casm.bytecode.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      bytecode\n    ])\n  );\n}\nfunction hashEntryPointSierra(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.function_idx)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n  const indentString = formatSpaces(stringify2(sierra.abi, null));\n  return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n  const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n  const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n  const abiHash = hashAbi(sierra);\n  const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(sierra.sierra_program.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      abiHash,\n      sierraProgram\n    ])\n  );\n}\nfunction computeContractClassHash(contract) {\n  const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n  if (\"sierra_program\" in compiledContract) {\n    return computeSierraContractClassHash(compiledContract);\n  }\n  return computeLegacyContractClassHash(compiledContract);\n}\n\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n  compressProgram: () => compressProgram,\n  decompressProgram: () => decompressProgram,\n  estimatedFeeToMaxFee: () => estimatedFeeToMaxFee,\n  formatSignature: () => formatSignature,\n  makeAddress: () => makeAddress,\n  randomAddress: () => randomAddress,\n  signatureToDecimalArray: () => signatureToDecimalArray,\n  signatureToHexArray: () => signatureToHexArray\n});\n\n\nfunction compressProgram(jsonProgram) {\n  const stringified = typeof jsonProgram === \"string\" ? jsonProgram : stringify2(jsonProgram);\n  const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_6__.gzip)(stringified);\n  return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n  if (Array.isArray(base642))\n    return base642;\n  const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_6__.ungzip)(atobUniversal(base642)));\n  return parse2(decompressed);\n}\nfunction randomAddress() {\n  const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey();\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n  return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n  if (!sig)\n    throw Error(\"formatSignature: provided signature is undefined\");\n  if (Array.isArray(sig)) {\n    return sig.map((it) => toHex(it));\n  }\n  try {\n    const { r, s } = sig;\n    return [toHex(r), toHex(s)];\n  } catch (e) {\n    throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n  }\n}\nfunction signatureToDecimalArray(sig) {\n  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 0.5) {\n  const overHeadPercent = Math.round((1 + overhead) * 100);\n  return toBigInt(estimatedFee) * toBigInt(overHeadPercent) / 100n;\n}\n\n// src/utils/contract.ts\nfunction isSierra(contract) {\n  const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n  return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n  const response = { ...payload };\n  if (isSierra(payload.contract)) {\n    if (!payload.compiledClassHash && payload.casm) {\n      response.compiledClassHash = computeCompiledClassHash(payload.casm);\n    }\n    if (!response.compiledClassHash)\n      throw new Error(\n        \"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\"\n      );\n  }\n  response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n  if (!response.classHash)\n    throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n  return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n  if (isSierra(ccr)) {\n    throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n  }\n  const contract = ccr;\n  return { ...contract, program: decompressProgram(contract.program) };\n}\n\n// src/utils/fetchPonyfill.ts\n\nvar fetchPonyfill_default = typeof window !== \"undefined\" && window.fetch || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && global.fetch || // use buildin fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__;\n\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n  createSierraContractClass: () => createSierraContractClass,\n  parseContract: () => parseContract,\n  wait: () => wait\n});\nfunction wait(delay) {\n  return new Promise((res) => {\n    setTimeout(res, delay);\n  });\n}\nfunction createSierraContractClass(contract) {\n  const result = { ...contract };\n  delete result.sierra_program_debug_info;\n  result.abi = formatSpaces(stringify2(contract.abi));\n  result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n  result.sierra_program = compressProgram(result.sierra_program);\n  return result;\n}\nfunction parseContract(contract) {\n  const parsedContract = typeof contract === \"string\" ? parse2(contract) : contract;\n  if (!isSierra(contract)) {\n    return {\n      ...parsedContract,\n      ...\"program\" in parsedContract && { program: compressProgram(parsedContract.program) }\n    };\n  }\n  return createSierraContractClass(parsedContract);\n}\n\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n  parseGetBlockResponse(res) {\n    return {\n      timestamp: res.timestamp,\n      block_hash: \"block_hash\" in res ? res.block_hash : \"\",\n      block_number: \"block_number\" in res ? res.block_number : -1,\n      new_root: \"new_root\" in res ? res.new_root : \"\",\n      parent_hash: res.parent_hash,\n      status: \"status\" in res ? res.status : \"PENDING\" /* PENDING */,\n      transactions: res.transactions\n    };\n  }\n  parseGetTransactionResponse(res) {\n    return {\n      calldata: \"calldata\" in res ? res.calldata : [],\n      contract_address: \"contract_address\" in res ? res.contract_address : \"\",\n      sender_address: \"sender_address\" in res ? res.sender_address : \"\",\n      max_fee: \"max_fee\" in res ? res.max_fee : \"\",\n      nonce: \"nonce\" in res ? res.nonce : \"\",\n      signature: \"signature\" in res ? res.signature : [],\n      transaction_hash: res.transaction_hash,\n      version: res.version\n    };\n  }\n  parseFeeEstimateResponse(res) {\n    return {\n      overall_fee: toBigInt(res[0].overall_fee),\n      gas_consumed: toBigInt(res[0].gas_consumed),\n      gas_price: toBigInt(res[0].gas_price)\n    };\n  }\n  parseFeeEstimateBulkResponse(res) {\n    return res.map((val) => ({\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price)\n    }));\n  }\n  parseCallContractResponse(res) {\n    return {\n      result: res\n    };\n  }\n  parseSimulateTransactionResponse(res) {\n    return res.map((it) => {\n      return {\n        ...it,\n        suggestedMaxFee: estimatedFeeToMaxFee(BigInt(it.fee_estimation.overall_fee))\n      };\n    });\n  }\n  parseContractClassResponse(res) {\n    return {\n      ...res,\n      abi: typeof res.abi === \"string\" ? JSON.parse(res.abi) : res.abi\n    };\n  }\n};\n\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n  const { captureStackTrace } = Error;\n  captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n  const { setPrototypeOf } = Object;\n  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n  constructor(message) {\n    super(message);\n    Object.defineProperty(this, \"name\", {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true\n    });\n    fixProto(this, new.target.prototype);\n    fixStack(this);\n  }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n  constructor(message, errorCode) {\n    super(message);\n    this.errorCode = errorCode;\n  }\n};\nvar HttpError = class extends LibraryError {\n  constructor(message, errorCode) {\n    super(message);\n    this.errorCode = errorCode;\n  }\n};\n\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n  StarknetIdContract: () => StarknetIdContract,\n  getStarknetIdContract: () => getStarknetIdContract,\n  useDecoded: () => useDecoded,\n  useEncoded: () => useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"\\u8FD9\\u6765\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n  let k = 0;\n  while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {\n    str = str.substring(0, str.length - 1);\n    k += 1;\n  }\n  return [str, k];\n}\nfunction useDecoded(encoded) {\n  let decoded = \"\";\n  encoded.forEach((subdomain) => {\n    while (subdomain !== ZERO) {\n      const code = subdomain % basicSizePlusOne;\n      subdomain /= basicSizePlusOne;\n      if (code === BigInt(basicAlphabet.length)) {\n        const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n        if (nextSubdomain === ZERO) {\n          const code2 = subdomain % bigAlphabetSizePlusOne;\n          subdomain = nextSubdomain;\n          if (code2 === ZERO)\n            decoded += basicAlphabet[0];\n          else\n            decoded += bigAlphabet[Number(code2) - 1];\n        } else {\n          const code2 = subdomain % bigAlphabetSize;\n          decoded += bigAlphabet[Number(code2)];\n          subdomain /= bigAlphabetSize;\n        }\n      } else\n        decoded += basicAlphabet[Number(code)];\n    }\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n    decoded += \".\";\n  });\n  if (!decoded) {\n    return decoded;\n  }\n  return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n  let encoded = BigInt(0);\n  let multiplier = BigInt(1);\n  if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n    const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n  } else {\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n  }\n  for (let i = 0; i < decoded.length; i += 1) {\n    const char = decoded[i];\n    const index = basicAlphabet.indexOf(char);\n    const bnIndex = BigInt(basicAlphabet.indexOf(char));\n    if (index !== -1) {\n      if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n        encoded += multiplier * basicAlphabetSize;\n        multiplier *= basicSizePlusOne;\n        multiplier *= basicSizePlusOne;\n      } else {\n        encoded += multiplier * bnIndex;\n        multiplier *= basicSizePlusOne;\n      }\n    } else if (bigAlphabet.indexOf(char) !== -1) {\n      encoded += multiplier * basicAlphabetSize;\n      multiplier *= basicSizePlusOne;\n      const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n      encoded += multiplier * BigInt(newid);\n      multiplier *= bigAlphabetSize;\n    }\n  }\n  return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2) => {\n  StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n  StarknetIdContract2[\"TESTNET\"] = \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\";\n  return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */;\n    case \"0x534e5f474f45524c49\" /* SN_GOERLI */:\n      return \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\" /* TESTNET */;\n    default:\n      throw new Error(\"Starknet.id is not yet deployed on this network\");\n  }\n}\n\n// src/provider/starknetId.ts\nasync function getStarkName(provider, address, StarknetIdContract2) {\n  const chainId = await provider.getChainId();\n  const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n  try {\n    const hexDomain = await provider.callContract({\n      contractAddress: contract,\n      entrypoint: \"address_to_domain\",\n      calldata: CallData.compile({\n        address\n      })\n    });\n    const decimalDomain = hexDomain.result.map((element) => BigInt(element)).slice(1);\n    const stringDomain = useDecoded(decimalDomain);\n    if (!stringDomain) {\n      throw Error(\"Starkname not found\");\n    }\n    return stringDomain;\n  } catch (e) {\n    if (e instanceof Error && e.message === \"Starkname not found\") {\n      throw e;\n    }\n    throw Error(\"Could not get stark name\");\n  }\n}\nasync function getAddressFromStarkName(provider, name, StarknetIdContract2) {\n  const chainId = await provider.getChainId();\n  const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n  try {\n    const addressData = await provider.callContract({\n      contractAddress: contract,\n      entrypoint: \"domain_to_address\",\n      calldata: CallData.compile({\n        domain: [useEncoded(name.replace(\".stark\", \"\")).toString(10)]\n      })\n    });\n    return addressData.result[0];\n  } catch {\n    throw Error(\"Could not get address from stark name\");\n  }\n}\n\n// src/provider/utils.ts\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n  constructor(_identifier) {\n    this.hash = null;\n    this.number = null;\n    this.tag = null;\n    this.valueOf = () => this.number;\n    this.toString = () => this.hash;\n    this.setIdentifier(_identifier);\n  }\n  setIdentifier(__identifier) {\n    if (typeof __identifier === \"string\" && isHex(__identifier)) {\n      this.hash = __identifier;\n    } else if (typeof __identifier === \"bigint\") {\n      this.hash = toHex(__identifier);\n    } else if (typeof __identifier === \"number\") {\n      this.number = __identifier;\n    } else if (typeof __identifier === \"string\" && validBlockTags.includes(__identifier)) {\n      this.tag = __identifier;\n    } else {\n      this.tag = \"pending\" /* pending */;\n    }\n  }\n  // TODO: fix any\n  get queryIdentifier() {\n    if (this.number !== null) {\n      return `blockNumber=${this.number}`;\n    }\n    if (this.hash !== null) {\n      return `blockHash=${this.hash}`;\n    }\n    return `blockNumber=${this.tag}`;\n  }\n  // TODO: fix any\n  get identifier() {\n    if (this.number !== null) {\n      return { block_number: this.number };\n    }\n    if (this.hash !== null) {\n      return { block_hash: this.hash };\n    }\n    return this.tag;\n  }\n  set identifier(_identifier) {\n    this.setIdentifier(_identifier);\n  }\n  get sequencerIdentifier() {\n    return this.hash !== null ? { blockHash: this.hash } : { blockNumber: this.number ?? this.tag };\n  }\n};\n\n// src/provider/rpc.ts\nvar getDefaultNodeUrl = (networkName, mute = false, version = RPC_DEFAULT_VERSION) => {\n  if (!mute)\n    console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n  const nodes = RPC_NODES[networkName ?? \"SN_GOERLI\" /* SN_GOERLI */];\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return `${nodes[randIdx]}${version}`;\n};\nvar defaultOptions = {\n  headers: { \"Content-Type\": \"application/json\" },\n  blockIdentifier: \"pending\" /* pending */,\n  retries: 200\n};\nvar RpcProvider = class {\n  constructor(optionsOrProvider) {\n    this.responseParser = new RPCResponseParser();\n    /**\n     * @deprecated renamed to getBlockLatestAccepted(); (will be removed in next minor version)\n     */\n    this.getBlockHashAndNumber = this.getBlockLatestAccepted;\n    /**\n     * @deprecated renamed to getBlockStateUpdate();\n     */\n    this.getStateUpdate = this.getBlockStateUpdate;\n    /**\n     * Returns the execution traces of all transactions included in the given block\n     * @deprecated renamed to getBlockTransactionsTraces()\n     */\n    this.traceBlockTransactions = this.getBlockTransactionsTraces;\n    /**\n     * Get the number of transactions in a block given a block id\n     * @deprecated renamed to getBlockTransactionCount()\n     * @returns Number of transactions\n     */\n    this.getTransactionCount = this.getBlockTransactionCount;\n    /**\n     * @deprecated renamed to getTransactionTrace();\n     * For a given executed transaction, return the trace of its execution, including internal calls\n     */\n    this.traceTransaction = this.getTransactionTrace;\n    /**\n     * @deprecated renamed to simulateTransaction();\n     */\n    this.getSimulateTransaction = this.simulateTransaction;\n    const { nodeUrl, retries, headers, blockIdentifier, chainId, rpcVersion } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl)) {\n      this.nodeUrl = getDefaultNodeUrl(\n        nodeUrl,\n        optionsOrProvider?.default,\n        rpcVersion\n      );\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default, rpcVersion);\n    }\n    this.retries = retries || defaultOptions.retries;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n  }\n  fetch(method, params, id = 0) {\n    const rpcRequestBody = {\n      id,\n      jsonrpc: \"2.0\",\n      method,\n      ...params && { params }\n    };\n    return fetchPonyfill_default(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(rpcRequestBody),\n      headers: this.headers\n    });\n  }\n  errorHandler(method, params, rpcError, otherError) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify2(params)}\n ${code}: ${message}: ${stringify2(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n  async fetchEndpoint(method, params) {\n    try {\n      const rawResult = await this.fetch(method, params);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result;\n    } catch (error) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n  async getChainId() {\n    this.chainId ?? (this.chainId = await this.fetchEndpoint(\"starknet_chainId\"));\n    return this.chainId;\n  }\n  /**\n   * NEW: Returns the version of the Starknet JSON-RPC specification being used\n   */\n  async getSpecVersion() {\n    return this.fetchEndpoint(\"starknet_specVersion\");\n  }\n  async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getNonce\", {\n      contract_address,\n      block_id\n    });\n  }\n  /**\n   * @deprecated use getBlockWithTxHashes or getBlockWithTxs (will be removed on sequencer deprecation)\n   */\n  async getBlock(blockIdentifier = this.blockIdentifier) {\n    return this.getBlockWithTxHashes(blockIdentifier).then(\n      this.responseParser.parseGetBlockResponse\n    );\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  async getBlockLatestAccepted() {\n    return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n  }\n  /**\n   * @deprecated redundant use getBlockLatestAccepted();\n   * Get the most recent accepted block number\n   * @returns Number of the latest block\n   */\n  async getBlockNumber() {\n    return this.fetchEndpoint(\"starknet_blockNumber\");\n  }\n  async getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", { block_id });\n  }\n  async getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxs\", { block_id });\n  }\n  async getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStateUpdate\", { block_id });\n  }\n  async getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_traceBlockTransactions\", { block_id });\n  }\n  async getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", { block_id });\n  }\n  /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.pending); (will be removed in next minor version)\n   */\n  async getPendingTransactions() {\n    const { transactions } = await this.getBlock(\"pending\" /* pending */);\n    return Promise.all(transactions.map((it) => this.getTransactionByHash(it)));\n  }\n  /**\n   * @deprecated use getTransactionByHash or getTransactionByBlockIdAndIndex (will be removed on sequencer deprecation)\n   */\n  async getTransaction(txHash) {\n    return this.getTransactionByHash(txHash).then(this.responseParser.parseGetTransactionResponse);\n  }\n  async getTransactionByHash(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n      transaction_hash\n    });\n  }\n  async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", { block_id, index });\n  }\n  async getTransactionReceipt(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionReceipt\", { transaction_hash });\n  }\n  async getTransactionTrace(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_traceTransaction\", { transaction_hash });\n  }\n  /**\n   * NEW: Get the status of a transaction\n   */\n  async getTransactionStatus(transactionHash) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint(\"starknet_getTransactionStatus\", { transaction_hash });\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  async simulateTransaction(invocations, {\n    blockIdentifier = this.blockIdentifier,\n    skipValidate = false,\n    skipFeeCharge = true\n  }) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags = [];\n    if (skipValidate)\n      simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge)\n      simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n    return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags\n    }).then(this.responseParser.parseSimulateTransactionResponse);\n  }\n  async waitForTransaction(txHash, options) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? 5e3;\n    const errorStates = options?.errorStates ?? [\n      rpc_exports.ETransactionStatus.REJECTED\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates = options?.successStates ?? [\n      rpc_exports.ETransactionExecutionStatus.SUCCEEDED,\n      rpc_exports.ETransactionStatus.ACCEPTED_ON_L2,\n      rpc_exports.ETransactionStatus.ACCEPTED_ON_L1\n    ];\n    let txStatus;\n    while (!onchain) {\n      await wait(retryInterval);\n      try {\n        txStatus = await this.getTransactionStatus(transactionHash);\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n        if (!finalityStatus) {\n          const error = new Error(\"waiting for transaction status\");\n          throw error;\n        }\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message);\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n    }\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      await wait(retryInterval);\n    }\n    return txReceipt;\n  }\n  async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStorageAt\", {\n      contract_address,\n      key: parsedKey,\n      block_id\n    });\n  }\n  async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  async getClassByHash(classHash) {\n    return this.getClass(classHash);\n  }\n  async getClass(classHash, blockIdentifier = this.blockIdentifier) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClass\", {\n      class_hash,\n      block_id\n    }).then(this.responseParser.parseContractClassResponse);\n  }\n  async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassAt\", {\n      block_id,\n      contract_address\n    }).then(this.responseParser.parseContractClassResponse);\n  }\n  async getCode(_contractAddress, _blockIdentifier) {\n    throw new Error(\"RPC does not implement getCode function\");\n  }\n  async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n    let contractClass;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClass(classHash, blockIdentifier);\n    } else {\n      throw Error(\"getContractVersion require contractAddress or classHash\");\n    }\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: \"1\", compiler: abiTest.compiler };\n      }\n      return { cairo: \"1\", compiler: void 0 };\n    }\n    return { cairo: \"0\", compiler: \"0\" };\n  }\n  /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */\n  async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier);\n  }\n  async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const transaction = this.buildTransaction(\n      {\n        type: \"INVOKE_FUNCTION\" /* INVOKE */,\n        ...invocation,\n        ...invocationDetails\n      },\n      \"fee\"\n    );\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: [transaction],\n      block_id\n    }).then(this.responseParser.parseFeeEstimateResponse);\n  }\n  async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const transaction = this.buildTransaction(\n      {\n        type: \"DECLARE\" /* DECLARE */,\n        ...invocation,\n        ...details\n      },\n      \"fee\"\n    );\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: [transaction],\n      block_id\n    }).then(this.responseParser.parseFeeEstimateResponse);\n  }\n  async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const transaction = this.buildTransaction(\n      {\n        type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n        ...invocation,\n        ...details\n      },\n      \"fee\"\n    );\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: [transaction],\n      block_id\n    }).then(this.responseParser.parseFeeEstimateResponse);\n  }\n  async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n    if (skipValidate) {\n      console.warn(\"getEstimateFeeBulk RPC does not support skipValidate\");\n    }\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: invocations.map((it) => this.buildTransaction(it, \"fee\")),\n      block_id\n    }).then(this.responseParser.parseFeeEstimateBulkResponse);\n  }\n  async invokeFunction(functionInvocation, details) {\n    return this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n      invoke_transaction: {\n        sender_address: functionInvocation.contractAddress,\n        calldata: CallData.toHex(functionInvocation.calldata),\n        type: rpc_exports.ETransactionType.INVOKE,\n        max_fee: toHex(details.maxFee || 0),\n        version: \"0x1\",\n        signature: signatureToHexArray(functionInvocation.signature),\n        nonce: toHex(details.nonce)\n      }\n    });\n  }\n  async declareContract({ contract, signature, senderAddress, compiledClassHash }, details) {\n    if (!isSierra(contract)) {\n      return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpc_exports.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          version: HEX_STR_TRANSACTION_VERSION_1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    }\n    return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n      declare_transaction: {\n        type: rpc_exports.ETransactionType.DECLARE,\n        contract_class: {\n          sierra_program: decompressProgram(contract.sierra_program),\n          contract_class_version: contract.contract_class_version,\n          entry_points_by_type: contract.entry_points_by_type,\n          abi: contract.abi\n        },\n        compiled_class_hash: compiledClassHash || \"\",\n        version: HEX_STR_TRANSACTION_VERSION_2,\n        max_fee: toHex(details.maxFee || 0),\n        signature: signatureToHexArray(signature),\n        sender_address: senderAddress,\n        nonce: toHex(details.nonce)\n      }\n    });\n  }\n  async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    return this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n      deploy_account_transaction: {\n        constructor_calldata: CallData.toHex(constructorCalldata || []),\n        class_hash: toHex(classHash),\n        contract_address_salt: toHex(addressSalt || 0),\n        type: rpc_exports.ETransactionType.DEPLOY_ACCOUNT,\n        max_fee: toHex(details.maxFee || 0),\n        version: toHex(details.version || 0),\n        signature: signatureToHexArray(signature),\n        nonce: toHex(details.nonce)\n      }\n    });\n  }\n  async callContract(call, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const result = await this.fetchEndpoint(\"starknet_call\", {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata)\n      },\n      block_id\n    });\n    return this.responseParser.parseCallContractResponse(result);\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  async estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: toHex(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n      message: formattedMessage,\n      block_id\n    });\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  async getSyncingStats() {\n    return this.fetchEndpoint(\"starknet_syncing\");\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  async getEvents(eventFilter) {\n    return this.fetchEndpoint(\"starknet_getEvents\", { filter: eventFilter });\n  }\n  /**\n   * StarknetId Endpoint (get name from address)\n   */\n  async getStarkName(address, StarknetIdContract2) {\n    return getStarkName(this, address, StarknetIdContract2);\n  }\n  /**\n   * StarknetId Endpoint (get address from name)\n   */\n  async getAddressFromStarkName(name, StarknetIdContract2) {\n    return getAddressFromStarkName(this, name, StarknetIdContract2);\n  }\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    const details = {\n      signature: signatureToHexArray(invocation.signature),\n      nonce: toHex(invocation.nonce),\n      max_fee: toHex(invocation.maxFee || 0)\n    };\n    if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n      return {\n        type: rpc_exports.ETransactionType.INVOKE,\n        // Diff between sequencer and rpc invoke type\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v1),\n        ...details\n      };\n    }\n    if (invocation.type === \"DECLARE\" /* DECLARE */) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details\n        };\n      }\n      return {\n        // compiled_class_hash\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program)\n        },\n        compiled_class_hash: invocation.compiledClassHash || \"\",\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v2),\n        ...details\n      };\n    }\n    if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v1),\n        ...details\n      };\n    }\n    throw Error(\"RPC buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/provider/sequencer.ts\n\n\n// src/utils/responseParser/index.ts\nvar ResponseParser = class {\n};\n\n// src/utils/responseParser/sequencer.ts\nvar SequencerAPIResponseParser = class extends ResponseParser {\n  parseGetBlockResponse(res) {\n    return {\n      ...res,\n      new_root: res.state_root,\n      parent_hash: res.parent_block_hash,\n      transactions: Object.values(res.transactions).map((value) => \"transaction_hash\" in value && value.transaction_hash).filter(Boolean)\n    };\n  }\n  parseGetTransactionResponse(res) {\n    if (res.status === \"NOT_RECEIVED\" /* NOT_RECEIVED */ && res.finality_status === \"NOT_RECEIVED\" /* NOT_RECEIVED */) {\n      throw new LibraryError();\n    }\n    return {\n      ...res,\n      calldata: \"calldata\" in res.transaction ? res.transaction.calldata : [],\n      contract_class: \"contract_class\" in res.transaction ? res.transaction.contract_class : void 0,\n      entry_point_selector: \"entry_point_selector\" in res.transaction ? res.transaction.entry_point_selector : void 0,\n      max_fee: \"max_fee\" in res.transaction ? res.transaction.max_fee : void 0,\n      nonce: res.transaction.nonce,\n      sender_address: \"sender_address\" in res.transaction ? res.transaction.sender_address : void 0,\n      signature: \"signature\" in res.transaction ? res.transaction.signature : void 0,\n      transaction_hash: \"transaction_hash\" in res.transaction ? res.transaction.transaction_hash : void 0,\n      version: \"version\" in res.transaction ? res.transaction.version : void 0\n    };\n  }\n  parseGetTransactionReceiptResponse(res) {\n    return {\n      ...res,\n      messages_sent: res.l2_to_l1_messages,\n      ...\"revert_error\" in res && { revert_reason: res.revert_error }\n    };\n  }\n  parseFeeEstimateResponse(res) {\n    if (\"overall_fee\" in res) {\n      let gasInfo = {};\n      try {\n        gasInfo = {\n          gas_consumed: toBigInt(res.gas_usage),\n          gas_price: toBigInt(res.gas_price)\n        };\n      } catch {\n      }\n      return {\n        overall_fee: toBigInt(res.overall_fee),\n        ...gasInfo\n      };\n    }\n    return {\n      overall_fee: toBigInt(res.amount)\n    };\n  }\n  parseFeeEstimateBulkResponse(res) {\n    return [].concat(res).map((item) => {\n      if (\"overall_fee\" in item) {\n        let gasInfo = {};\n        try {\n          gasInfo = {\n            gas_consumed: toBigInt(item.gas_usage),\n            gas_price: toBigInt(item.gas_price)\n          };\n        } catch {\n        }\n        return {\n          overall_fee: toBigInt(item.overall_fee),\n          ...gasInfo\n        };\n      }\n      return {\n        overall_fee: toBigInt(item.amount)\n      };\n    });\n  }\n  parseSimulateTransactionResponse(res) {\n    const suggestedMaxFee = \"overall_fee\" in res.fee_estimation ? res.fee_estimation.overall_fee : res.fee_estimation.amount;\n    return [\n      {\n        transaction_trace: res.trace,\n        fee_estimation: res.fee_estimation,\n        suggestedMaxFee: estimatedFeeToMaxFee(BigInt(suggestedMaxFee))\n      }\n    ];\n  }\n  parseCallContractResponse(res) {\n    return {\n      result: res.result\n    };\n  }\n  parseInvokeFunctionResponse(res) {\n    return {\n      transaction_hash: res.transaction_hash\n    };\n  }\n  parseDeployContractResponse(res) {\n    return {\n      transaction_hash: res.transaction_hash,\n      contract_address: res.address\n    };\n  }\n  parseDeclareContractResponse(res) {\n    return {\n      transaction_hash: res.transaction_hash,\n      class_hash: res.class_hash\n    };\n  }\n  parseGetStateUpdateResponse(res) {\n    const nonces = Object.entries(res.state_diff.nonces).map(([contract_address, nonce]) => ({\n      contract_address,\n      nonce\n    }));\n    const storage_diffs = Object.entries(res.state_diff.storage_diffs).map(\n      ([address, storage_entries]) => ({ address, storage_entries })\n    );\n    return {\n      ...res,\n      state_diff: {\n        ...res.state_diff,\n        storage_diffs,\n        nonces\n      }\n    };\n  }\n  parseContractClassResponse(res) {\n    const response = isSierra(res) ? res : parseContract(res);\n    return {\n      ...response,\n      abi: typeof response.abi === \"string\" ? JSON.parse(response.abi) : response.abi\n    };\n  }\n};\n\n// src/utils/url.ts\n\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n  if (!s) {\n    return false;\n  }\n  if (typeof s !== \"string\") {\n    return false;\n  }\n  const match = s.match(protocolAndDomainRE);\n  if (!match) {\n    return false;\n  }\n  const everythingAfterProtocol = match[1];\n  if (!everythingAfterProtocol) {\n    return false;\n  }\n  if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n    return true;\n  }\n  return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n  return isUrl(urlOrPath) ? urlOrPath : url_join__WEBPACK_IMPORTED_MODULE_8__(baseUrl, urlOrPath ?? defaultPath);\n}\n\n// src/provider/sequencer.ts\nfunction isEmptyQueryObject(obj) {\n  return obj === void 0 || Object.keys(obj).length === 0 || Object.keys(obj).length === 1 && Object.entries(obj).every(([k, v]) => k === \"blockIdentifier\" && v === null);\n}\nvar defaultOptions2 = {\n  network: \"SN_GOERLI\" /* SN_GOERLI */,\n  blockIdentifier: \"pending\" /* pending */\n};\nvar SequencerProvider = class {\n  constructor(optionsOrProvider = defaultOptions2) {\n    this.responseParser = new SequencerAPIResponseParser();\n    if (\"network\" in optionsOrProvider) {\n      this.baseUrl = SequencerProvider.getNetworkFromName(optionsOrProvider.network);\n      this.feederGatewayUrl = buildUrl(this.baseUrl, \"feeder_gateway\");\n      this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\");\n    } else {\n      this.baseUrl = optionsOrProvider.baseUrl;\n      this.feederGatewayUrl = buildUrl(\n        this.baseUrl,\n        \"feeder_gateway\",\n        optionsOrProvider.feederGatewayUrl\n      );\n      this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\", optionsOrProvider.gatewayUrl);\n    }\n    this.chainId = optionsOrProvider?.chainId ?? SequencerProvider.getChainIdFromBaseUrl(this.baseUrl);\n    this.headers = optionsOrProvider.headers;\n    this.blockIdentifier = optionsOrProvider?.blockIdentifier || defaultOptions2.blockIdentifier;\n  }\n  static getNetworkFromName(name) {\n    switch (name) {\n      case \"SN_MAIN\" /* SN_MAIN */:\n      case \"0x534e5f4d41494e\" /* SN_MAIN */:\n        return \"https://alpha-mainnet.starknet.io\" /* SN_MAIN */;\n      case \"SN_GOERLI\" /* SN_GOERLI */:\n      case \"0x534e5f474f45524c49\" /* SN_GOERLI */:\n        return \"https://alpha4.starknet.io\" /* SN_GOERLI */;\n      default:\n        throw new Error(\"Could not detect base url from NetworkName\");\n    }\n  }\n  static getChainIdFromBaseUrl(baseUrl) {\n    try {\n      const url = new URL(baseUrl);\n      if (url.host.includes(\"mainnet.starknet.io\")) {\n        return \"0x534e5f4d41494e\" /* SN_MAIN */;\n      }\n      return \"0x534e5f474f45524c49\" /* SN_GOERLI */;\n    } catch {\n      console.error(`Could not parse baseUrl: ${baseUrl}`);\n      return \"0x534e5f474f45524c49\" /* SN_GOERLI */;\n    }\n  }\n  getFetchUrl(endpoint) {\n    const gatewayUrlEndpoints = [\"add_transaction\"];\n    return gatewayUrlEndpoints.includes(endpoint) ? this.gatewayUrl : this.feederGatewayUrl;\n  }\n  getFetchMethod(endpoint) {\n    const postMethodEndpoints = [\n      \"add_transaction\",\n      \"call_contract\",\n      \"estimate_fee\",\n      \"estimate_message_fee\",\n      \"estimate_fee_bulk\",\n      \"simulate_transaction\"\n    ];\n    return postMethodEndpoints.includes(endpoint) ? \"POST\" : \"GET\";\n  }\n  getQueryString(query) {\n    if (isEmptyQueryObject(query)) {\n      return \"\";\n    }\n    const queryString = Object.entries(query).map(([key, value]) => {\n      if (key === \"blockIdentifier\") {\n        const block = new Block(value);\n        return `${block.queryIdentifier}`;\n      }\n      return `${key}=${value}`;\n    }).join(\"&\");\n    return `?${queryString}`;\n  }\n  getHeaders(method) {\n    if (method === \"POST\") {\n      return {\n        \"Content-Type\": \"application/json\",\n        ...this.headers\n      };\n    }\n    return this.headers;\n  }\n  // typesafe fetch\n  async fetchEndpoint(endpoint, ...[query, request]) {\n    const baseUrl = this.getFetchUrl(endpoint);\n    const method = this.getFetchMethod(endpoint);\n    const queryString = this.getQueryString(query);\n    const url = url_join__WEBPACK_IMPORTED_MODULE_8__(baseUrl, endpoint, queryString);\n    return this.fetch(url, {\n      method,\n      body: request\n    });\n  }\n  async fetch(endpoint, options) {\n    const url = buildUrl(this.baseUrl, \"\", endpoint);\n    const method = options?.method ?? \"GET\";\n    const headers = this.getHeaders(method);\n    const body = stringify2(options?.body);\n    try {\n      const response = await fetchPonyfill_default(url, {\n        method,\n        body,\n        headers\n      });\n      const textResponse = await response.text();\n      if (!response.ok) {\n        let responseBody;\n        try {\n          responseBody = parse2(textResponse);\n        } catch {\n          throw new HttpError(response.statusText, response.status);\n        }\n        throw new GatewayError(responseBody.message, responseBody.code);\n      }\n      const parseChoice = options?.parseAlwaysAsBigInt ? parseAlwaysAsBig : parse2;\n      return parseChoice(textResponse);\n    } catch (error) {\n      if (error instanceof Error && !(error instanceof LibraryError))\n        throw Error(`Could not ${method} from endpoint \\`${url}\\`: ${error.message}`);\n      throw error;\n    }\n  }\n  async getChainId() {\n    return Promise.resolve(this.chainId);\n  }\n  async callContract({ contractAddress, entrypoint: entryPointSelector, calldata = [] }, blockIdentifier = this.blockIdentifier) {\n    return this.fetchEndpoint(\n      \"call_contract\",\n      { blockIdentifier },\n      {\n        // TODO - determine best choice once both are fully supported in devnet\n        // signature: [],\n        // sender_address: contractAddress,\n        contract_address: contractAddress,\n        entry_point_selector: getSelectorFromName(entryPointSelector),\n        calldata: CallData.compile(calldata)\n      }\n    ).then(this.responseParser.parseCallContractResponse);\n  }\n  async getBlock(blockIdentifier = this.blockIdentifier) {\n    return this.fetchEndpoint(\"get_block\", { blockIdentifier }).then(\n      this.responseParser.parseGetBlockResponse\n    );\n  }\n  async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    return this.fetchEndpoint(\"get_nonce\", { contractAddress, blockIdentifier });\n  }\n  async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const parsedKey = toBigInt(key).toString(10);\n    return this.fetchEndpoint(\"get_storage_at\", {\n      blockIdentifier,\n      contractAddress,\n      key: parsedKey\n    });\n  }\n  async getTransaction(txHash) {\n    const txHashHex = toHex(txHash);\n    return this.fetchEndpoint(\"get_transaction\", { transactionHash: txHashHex }).then((result) => {\n      if (Object.values(result).length === 1)\n        throw new LibraryError(result.status);\n      return this.responseParser.parseGetTransactionResponse(result);\n    });\n  }\n  async getTransactionReceipt(txHash) {\n    const txHashHex = toHex(txHash);\n    return this.fetchEndpoint(\"get_transaction_receipt\", { transactionHash: txHashHex }).then(\n      this.responseParser.parseGetTransactionReceiptResponse\n    );\n  }\n  async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    return this.fetchEndpoint(\"get_full_contract\", { blockIdentifier, contractAddress }).then(\n      this.responseParser.parseContractClassResponse\n    );\n  }\n  async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    return this.fetchEndpoint(\"get_class_hash_at\", { blockIdentifier, contractAddress });\n  }\n  async getClassByHash(classHash, blockIdentifier = this.blockIdentifier) {\n    return this.fetchEndpoint(\"get_class_by_hash\", { classHash, blockIdentifier }).then(\n      this.responseParser.parseContractClassResponse\n    );\n  }\n  async getCompiledClassByClassHash(classHash, blockIdentifier = this.blockIdentifier) {\n    return this.fetchEndpoint(\"get_compiled_class_by_class_hash\", { classHash, blockIdentifier });\n  }\n  async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n    let contractClass;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClassByHash(classHash, blockIdentifier);\n    } else {\n      throw Error(\"getContractVersion require contractAddress or classHash\");\n    }\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: \"1\", compiler: abiTest.compiler };\n      }\n      return { cairo: \"1\", compiler: void 0 };\n    }\n    return { cairo: \"0\", compiler: \"0\" };\n  }\n  async invokeFunction(functionInvocation, details) {\n    return this.fetchEndpoint(\"add_transaction\", void 0, {\n      type: \"INVOKE_FUNCTION\" /* INVOKE */,\n      sender_address: functionInvocation.contractAddress,\n      calldata: CallData.compile(functionInvocation.calldata ?? []),\n      signature: signatureToDecimalArray(functionInvocation.signature),\n      nonce: toHex(details.nonce),\n      max_fee: toHex(details.maxFee || 0),\n      version: \"0x1\"\n    }).then(this.responseParser.parseInvokeFunctionResponse);\n  }\n  async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    return this.fetchEndpoint(\"add_transaction\", void 0, {\n      type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n      contract_address_salt: addressSalt ?? randomAddress(),\n      constructor_calldata: CallData.compile(constructorCalldata ?? []),\n      class_hash: toHex(classHash),\n      max_fee: toHex(details.maxFee || 0),\n      version: toHex(details.version || 0),\n      nonce: toHex(details.nonce),\n      signature: signatureToDecimalArray(signature)\n    }).then(this.responseParser.parseDeployContractResponse);\n  }\n  async declareContract({ senderAddress, contract, signature, compiledClassHash }, details) {\n    if (!isSierra(contract)) {\n      return this.fetchEndpoint(\"add_transaction\", void 0, {\n        type: \"DECLARE\" /* DECLARE */,\n        contract_class: contract,\n        nonce: toHex(details.nonce),\n        signature: signatureToDecimalArray(signature),\n        sender_address: senderAddress,\n        max_fee: toHex(details.maxFee || 0),\n        version: toHex(transactionVersion)\n      }).then(this.responseParser.parseDeclareContractResponse);\n    }\n    return this.fetchEndpoint(\"add_transaction\", void 0, {\n      type: \"DECLARE\" /* DECLARE */,\n      sender_address: senderAddress,\n      compiled_class_hash: compiledClassHash,\n      contract_class: contract,\n      nonce: toHex(details.nonce),\n      signature: signatureToDecimalArray(signature),\n      max_fee: toHex(details.maxFee || 0),\n      version: toHex(transactionVersion_2)\n    }).then(this.responseParser.parseDeclareContractResponse);\n  }\n  async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n  }\n  async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n    const transaction = this.buildTransaction(\n      {\n        type: \"INVOKE_FUNCTION\" /* INVOKE */,\n        ...invocation,\n        ...invocationDetails\n      },\n      \"fee\"\n    );\n    return this.fetchEndpoint(\"estimate_fee\", { blockIdentifier, skipValidate }, transaction).then(\n      this.responseParser.parseFeeEstimateResponse\n    );\n  }\n  async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n    const transaction = this.buildTransaction(\n      {\n        type: \"DECLARE\" /* DECLARE */,\n        ...invocation,\n        ...details\n      },\n      \"fee\"\n    );\n    return this.fetchEndpoint(\"estimate_fee\", { blockIdentifier, skipValidate }, transaction).then(\n      this.responseParser.parseFeeEstimateResponse\n    );\n  }\n  async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n    const transaction = this.buildTransaction(\n      {\n        type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n        ...invocation,\n        ...details\n      },\n      \"fee\"\n    );\n    return this.fetchEndpoint(\"estimate_fee\", { blockIdentifier, skipValidate }, transaction).then(\n      this.responseParser.parseFeeEstimateResponse\n    );\n  }\n  async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n    const transactions = invocations.map((it) => this.buildTransaction(it, \"fee\"));\n    return this.fetchEndpoint(\n      \"estimate_fee_bulk\",\n      { blockIdentifier, skipValidate },\n      transactions\n    ).then(this.responseParser.parseFeeEstimateBulkResponse);\n  }\n  async getCode(contractAddress, blockIdentifier = this.blockIdentifier) {\n    return this.fetchEndpoint(\"get_code\", { contractAddress, blockIdentifier });\n  }\n  async waitForTransaction(txHash, options) {\n    let res;\n    let completed = false;\n    let retries = 0;\n    const retryInterval = options?.retryInterval ?? 5e3;\n    const errorStates = options?.errorStates ?? [\n      \"REJECTED\" /* REJECTED */,\n      \"NOT_RECEIVED\" /* NOT_RECEIVED */,\n      \"REVERTED\" /* REVERTED */\n    ];\n    const successStates = options?.successStates ?? [\n      \"SUCCEEDED\" /* SUCCEEDED */,\n      \"ACCEPTED_ON_L1\" /* ACCEPTED_ON_L1 */,\n      \"ACCEPTED_ON_L2\" /* ACCEPTED_ON_L2 */\n    ];\n    while (!completed) {\n      await wait(retryInterval);\n      res = await this.getTransactionStatus(txHash);\n      if (\"NOT_RECEIVED\" /* NOT_RECEIVED */ === res.finality_status && retries < 3) {\n        retries += 1;\n      } else if (successStates.includes(res.finality_status) || successStates.includes(res.execution_status)) {\n        completed = true;\n      } else if (errorStates.includes(res.finality_status) || errorStates.includes(res.execution_status)) {\n        let message;\n        if (res.tx_failure_reason) {\n          message = `${res.tx_status}: ${res.tx_failure_reason.code}\n${res.tx_failure_reason.error_message}`;\n        } else if (res.tx_revert_reason) {\n          message = `${res.tx_status}: ${res.tx_revert_reason}`;\n        } else {\n          message = res.tx_status;\n        }\n        const error = new Error(message);\n        error.response = res;\n        throw error;\n      }\n    }\n    const txReceipt = await this.getTransactionReceipt(txHash);\n    return txReceipt;\n  }\n  /**\n   * Gets the status of a transaction.\n   * @param txHash BigNumberish\n   * @returns GetTransactionStatusResponse - the transaction status object\n   */\n  async getTransactionStatus(txHash) {\n    const txHashHex = toHex(txHash);\n    return this.fetchEndpoint(\"get_transaction_status\", { transactionHash: txHashHex });\n  }\n  /**\n   * Gets the smart contract address on the goerli testnet.\n   * @returns GetContractAddressesResponse - starknet smart contract addresses\n   */\n  async getContractAddresses() {\n    return this.fetchEndpoint(\"get_contract_addresses\");\n  }\n  /**\n   * Gets the transaction trace from a tx id.\n   * @param txHash BigNumberish\n   * @returns TransactionTraceResponse - the transaction trace\n   */\n  async getTransactionTrace(txHash) {\n    const txHashHex = toHex(txHash);\n    return this.fetchEndpoint(\"get_transaction_trace\", { transactionHash: txHashHex });\n  }\n  async estimateMessageFee({ from_address, to_address, entry_point_selector, payload }, blockIdentifier = this.blockIdentifier) {\n    const validCallL1Handler = {\n      from_address: getDecimalString(from_address),\n      to_address: getHexString(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    return this.fetchEndpoint(\"estimate_message_fee\", { blockIdentifier }, validCallL1Handler);\n  }\n  /**\n   * Simulate transaction using Sequencer provider\n   * WARNING!: Sequencer will process only first element from invocations array\n   *\n   * @param invocations Array of invocations, but only first invocation will be processed\n   * @param blockIdentifier block identifier, default 'latest'\n   * @param skipValidate Skip Account __validate__ method\n   * @returns\n   */\n  async getSimulateTransaction(invocations, {\n    blockIdentifier = this.blockIdentifier,\n    skipValidate = false,\n    skipExecute = false\n  }) {\n    if (invocations.length > 1) {\n      console.warn(\"Sequencer simulate process only first element from invocations list\");\n    }\n    if (skipExecute) {\n      console.warn(\"Sequencer can't skip account __execute__\");\n    }\n    const transaction = this.buildTransaction(invocations[0]);\n    return this.fetchEndpoint(\n      \"simulate_transaction\",\n      {\n        blockIdentifier,\n        skipValidate: skipValidate ?? false\n      },\n      transaction\n    ).then(this.responseParser.parseSimulateTransactionResponse);\n  }\n  async getStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const args = new Block(blockIdentifier).sequencerIdentifier;\n    return this.fetchEndpoint(\"get_state_update\", { ...args }).then(\n      this.responseParser.parseGetStateUpdateResponse\n    );\n  }\n  // consider adding an optional trace retrieval parameter to the getBlock method\n  async getBlockTraces(blockIdentifier = this.blockIdentifier) {\n    const args = new Block(blockIdentifier).sequencerIdentifier;\n    return this.fetchEndpoint(\"get_block_traces\", { ...args });\n  }\n  async getStarkName(address, StarknetIdContract2) {\n    return getStarkName(this, address, StarknetIdContract2);\n  }\n  async getAddressFromStarkName(name, StarknetIdContract2) {\n    return getAddressFromStarkName(this, name, StarknetIdContract2);\n  }\n  /**\n   * Build Single AccountTransaction from Single AccountInvocation\n   * @param invocation AccountInvocationItem\n   * @param versionType 'fee' | 'transaction' - used to determine default versions\n   * @returns AccountTransactionItem\n   */\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    const details = {\n      signature: signatureToDecimalArray(invocation.signature),\n      nonce: toHex(invocation.nonce)\n    };\n    if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n      return {\n        type: invocation.type,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.compile(invocation.calldata ?? []),\n        version: toHex(invocation.version || defaultVersions.v1),\n        ...details\n      };\n    }\n    if (invocation.type === \"DECLARE\" /* DECLARE */) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          // fee from getDeclareEstimateFee use t.v. instead of feet.v.\n          ...details\n        };\n      }\n      return {\n        type: invocation.type,\n        contract_class: invocation.contract,\n        compiled_class_hash: invocation.compiledClassHash,\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v2),\n        // fee on getDeclareEstimateFee use t.v. instead of feet.v.\n        ...details\n      };\n    }\n    if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.compile(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v1),\n        ...details\n      };\n    }\n    throw Error(\"Sequencer buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/provider/default.ts\nvar Provider = class {\n  constructor(providerOrOptions) {\n    if (providerOrOptions instanceof Provider) {\n      this.provider = providerOrOptions.provider;\n    } else if (providerOrOptions instanceof RpcProvider || providerOrOptions instanceof SequencerProvider) {\n      this.provider = providerOrOptions;\n    } else if (providerOrOptions && \"rpc\" in providerOrOptions) {\n      this.provider = new RpcProvider(providerOrOptions.rpc);\n    } else if (providerOrOptions && \"sequencer\" in providerOrOptions) {\n      this.provider = new SequencerProvider(providerOrOptions.sequencer);\n    } else {\n      this.provider = new RpcProvider();\n    }\n  }\n  async getChainId() {\n    return this.provider.getChainId();\n  }\n  async getBlock(blockIdentifier) {\n    return this.provider.getBlock(blockIdentifier);\n  }\n  async getClassAt(contractAddress, blockIdentifier) {\n    return this.provider.getClassAt(contractAddress, blockIdentifier);\n  }\n  async getClassHashAt(contractAddress, blockIdentifier) {\n    return this.provider.getClassHashAt(contractAddress, blockIdentifier);\n  }\n  getClassByHash(classHash) {\n    return this.provider.getClassByHash(classHash);\n  }\n  async getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier) {\n    return this.provider.getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier);\n  }\n  async getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate) {\n    return this.provider.getInvokeEstimateFee(\n      invocationWithTxType,\n      invocationDetails,\n      blockIdentifier,\n      skipValidate\n    );\n  }\n  async getEstimateFeeBulk(invocations, options) {\n    return this.provider.getEstimateFeeBulk(invocations, options);\n  }\n  async getNonceForAddress(contractAddress, blockIdentifier) {\n    return this.provider.getNonceForAddress(contractAddress, blockIdentifier);\n  }\n  async getStorageAt(contractAddress, key, blockIdentifier) {\n    return this.provider.getStorageAt(contractAddress, key, blockIdentifier);\n  }\n  async getTransaction(txHash) {\n    return this.provider.getTransaction(txHash);\n  }\n  async getTransactionReceipt(txHash) {\n    return this.provider.getTransactionReceipt(txHash);\n  }\n  async callContract(request, blockIdentifier) {\n    return this.provider.callContract(request, blockIdentifier);\n  }\n  async invokeFunction(functionInvocation, details) {\n    return this.provider.invokeFunction(functionInvocation, details);\n  }\n  async deployAccountContract(payload, details) {\n    return this.provider.deployAccountContract(payload, details);\n  }\n  async declareContract(transaction, details) {\n    return this.provider.declareContract(transaction, details);\n  }\n  async getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate) {\n    return this.provider.getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate);\n  }\n  getDeployAccountEstimateFee(transaction, details, blockIdentifier, skipValidate) {\n    return this.provider.getDeployAccountEstimateFee(\n      transaction,\n      details,\n      blockIdentifier,\n      skipValidate\n    );\n  }\n  async getCode(contractAddress, blockIdentifier) {\n    return this.provider.getCode(contractAddress, blockIdentifier);\n  }\n  async waitForTransaction(txHash, options) {\n    return this.provider.waitForTransaction(txHash, options);\n  }\n  async getSimulateTransaction(invocations, options) {\n    return this.provider.getSimulateTransaction(invocations, options);\n  }\n  async getStateUpdate(blockIdentifier) {\n    return this.provider.getStateUpdate(blockIdentifier);\n  }\n  async getStarkName(address, StarknetIdContract2) {\n    return getStarkName(this, address, StarknetIdContract2);\n  }\n  async getAddressFromStarkName(name, StarknetIdContract2) {\n    return getAddressFromStarkName(this, name, StarknetIdContract2);\n  }\n  async getContractVersion(contractAddress, classHash, options) {\n    return this.provider.getContractVersion(contractAddress, classHash, options);\n  }\n};\n\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n  fromCallsToExecuteCalldata: () => fromCallsToExecuteCalldata,\n  fromCallsToExecuteCalldataWithNonce: () => fromCallsToExecuteCalldataWithNonce,\n  fromCallsToExecuteCalldata_cairo1: () => fromCallsToExecuteCalldata_cairo1,\n  getExecuteCalldata: () => getExecuteCalldata,\n  transformCallsToMulticallArrays: () => transformCallsToMulticallArrays,\n  transformCallsToMulticallArrays_cairo1: () => transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls) => {\n  const callArray = [];\n  const calldata = [];\n  calls.forEach((call) => {\n    const data = CallData.compile(call.calldata || []);\n    callArray.push({\n      to: toBigInt(call.contractAddress).toString(10),\n      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n      data_offset: calldata.length.toString(),\n      data_len: data.length.toString()\n    });\n    calldata.push(...data);\n  });\n  return {\n    callArray,\n    calldata: CallData.compile({ calldata })\n  };\n};\nvar fromCallsToExecuteCalldata = (calls) => {\n  const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n  const compiledCalls = CallData.compile({ callArray });\n  return [...compiledCalls, ...calldata];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce) => {\n  return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls) => {\n  const callArray = calls.map((call) => ({\n    to: toBigInt(call.contractAddress).toString(10),\n    selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n    calldata: CallData.compile(call.calldata || [])\n  }));\n  return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls) => {\n  const orderCalls = calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n    // RawArgsObject | RawArgsArray type\n  }));\n  return CallData.compile({ orderCalls });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\") => {\n  if (cairoVersion === \"1\") {\n    return fromCallsToExecuteCalldata_cairo1(calls);\n  }\n  return fromCallsToExecuteCalldata(calls);\n};\n\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n  encodeData: () => encodeData,\n  encodeType: () => encodeType,\n  encodeValue: () => encodeValue,\n  getDependencies: () => getDependencies,\n  getMessageHash: () => getMessageHash,\n  getStructHash: () => getStructHash,\n  getTypeHash: () => getTypeHash,\n  isMerkleTreeType: () => isMerkleTreeType,\n  prepareSelector: () => prepareSelector\n});\n\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n  MerkleTree: () => MerkleTree,\n  proofMerklePath: () => proofMerklePath\n});\nvar MerkleTree = class {\n  constructor(leafHashes) {\n    this.branches = [];\n    this.leaves = leafHashes;\n    this.root = this.build(leafHashes);\n  }\n  /**\n   * Create Merkle tree\n   * @param leaves hex-string array\n   * @returns format: hex-string; Merkle tree root\n   */\n  build(leaves) {\n    if (leaves.length === 1) {\n      return leaves[0];\n    }\n    if (leaves.length !== this.leaves.length) {\n      this.branches.push(leaves);\n    }\n    const newLeaves = [];\n    for (let i = 0; i < leaves.length; i += 2) {\n      if (i + 1 === leaves.length) {\n        newLeaves.push(MerkleTree.hash(leaves[i], \"0x0\"));\n      } else {\n        newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1]));\n      }\n    }\n    return this.build(newLeaves);\n  }\n  /**\n   * Create pedersen hash from a and b\n   * @returns format: hex-string\n   */\n  static hash(a, b) {\n    const [aSorted, bSorted] = [toBigInt(a), toBigInt(b)].sort((x, y) => x >= y ? 1 : -1);\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(aSorted, bSorted);\n  }\n  /**\n   * Return path to leaf\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns format: hex-string array\n   */\n  getProof(leaf, branch = this.leaves, hashPath = []) {\n    const index = branch.indexOf(leaf);\n    if (index === -1) {\n      throw new Error(\"leaf not found\");\n    }\n    if (branch.length === 1) {\n      return hashPath;\n    }\n    const isLeft = index % 2 === 0;\n    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n    const newHashPath = [...hashPath, neededBranch];\n    const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b) => b.length === branch.length);\n    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];\n    return this.getProof(\n      MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf),\n      nextBranch,\n      newHashPath\n    );\n  }\n};\nfunction proofMerklePath(root, leaf, path) {\n  if (path.length === 0) {\n    return root === leaf;\n  }\n  const [next, ...rest] = path;\n  return proofMerklePath(root, MerkleTree.hash(leaf, next), rest);\n}\n\n// src/utils/typedData.ts\nfunction getHex(value) {\n  try {\n    return toHex(value);\n  } catch (e) {\n    if (typeof value === \"string\") {\n      return toHex(encodeShortString(value));\n    }\n    throw new Error(`Invalid BigNumberish: ${value}`);\n  }\n}\nvar validateTypedData = (data) => {\n  const typedData = data;\n  const valid = Boolean(typedData.types && typedData.primaryType && typedData.message);\n  return valid;\n};\nfunction prepareSelector(selector) {\n  return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n  return type.type === \"merkletree\";\n}\nvar getDependencies = (types, type, dependencies = []) => {\n  if (type[type.length - 1] === \"*\") {\n    type = type.slice(0, -1);\n  }\n  if (dependencies.includes(type)) {\n    return dependencies;\n  }\n  if (!types[type]) {\n    return dependencies;\n  }\n  return [\n    type,\n    ...types[type].reduce(\n      (previous, t) => [\n        ...previous,\n        ...getDependencies(types, t.type, previous).filter(\n          (dependency) => !previous.includes(dependency)\n        )\n      ],\n      []\n    )\n  ];\n};\nfunction getMerkleTreeType(types, ctx) {\n  if (ctx.parent && ctx.key) {\n    const parentType = types[ctx.parent];\n    const merkleType = parentType.find((t) => t.name === ctx.key);\n    const isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(`${ctx.key} is not a merkle tree`);\n    }\n    if (merkleType.contains.endsWith(\"*\")) {\n      throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n    }\n    return merkleType.contains;\n  }\n  return \"raw\";\n}\nvar encodeType = (types, type) => {\n  const [primary, ...dependencies] = getDependencies(types, type);\n  const newTypes = !primary ? [] : [primary, ...dependencies.sort()];\n  return newTypes.map((dependency) => {\n    return `${dependency}(${types[dependency].map((t) => `${t.name}:${t.type}`)})`;\n  }).join(\"\");\n};\nvar getTypeHash = (types, type) => {\n  return getSelectorFromName(encodeType(types, type));\n};\nvar encodeValue = (types, type, data, ctx = {}) => {\n  if (types[type]) {\n    return [type, getStructHash(types, type, data)];\n  }\n  if (Object.keys(types).map((x) => `${x}*`).includes(type)) {\n    const structHashes = data.map((struct) => {\n      return getStructHash(types, type.slice(0, -1), struct);\n    });\n    return [type, computeHashOnElements(structHashes)];\n  }\n  if (type === \"merkletree\") {\n    const merkleTreeType = getMerkleTreeType(types, ctx);\n    const structHashes = data.map((struct) => {\n      return encodeValue(types, merkleTreeType, struct)[1];\n    });\n    const { root } = new MerkleTree(structHashes);\n    return [\"felt\", root];\n  }\n  if (type === \"felt*\") {\n    return [\"felt*\", computeHashOnElements(data)];\n  }\n  if (type === \"selector\") {\n    return [\"felt\", prepareSelector(data)];\n  }\n  return [type, getHex(data)];\n};\nvar encodeData = (types, type, data) => {\n  const [returnTypes, values] = types[type].reduce(\n    ([ts, vs], field) => {\n      if (data[field.name] === void 0 || data[field.name] === null) {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n      const value = data[field.name];\n      const [t, encodedValue] = encodeValue(types, field.type, value, {\n        parent: type,\n        key: field.name\n      });\n      return [\n        [...ts, t],\n        [...vs, encodedValue]\n      ];\n    },\n    [[\"felt\"], [getTypeHash(types, type)]]\n  );\n  return [returnTypes, values];\n};\nvar getStructHash = (types, type, data) => {\n  return computeHashOnElements(encodeData(types, type, data)[1]);\n};\nvar getMessageHash = (typedData, account) => {\n  if (!validateTypedData(typedData)) {\n    throw new Error(\"Typed data does not match JSON schema\");\n  }\n  const message = [\n    encodeShortString(\"StarkNet Message\"),\n    getStructHash(typedData.types, \"StarkNetDomain\", typedData.domain),\n    account,\n    getStructHash(typedData.types, typedData.primaryType, typedData.message)\n  ];\n  return computeHashOnElements(message);\n};\n\n// src/signer/default.ts\nvar Signer = class {\n  constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n  }\n  async getPubKey() {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey(this.pk);\n  }\n  async signMessage(typedData, accountAddress) {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n  }\n  async signTransaction(transactions, transactionsDetail, abis) {\n    if (abis && abis.length !== transactions.length) {\n      throw new Error(\"ABI must be provided for each transaction or no transaction\");\n    }\n    const calldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n    const msgHash = calculateTransactionHash(\n      transactionsDetail.walletAddress,\n      transactionsDetail.version,\n      calldata,\n      transactionsDetail.maxFee,\n      transactionsDetail.chainId,\n      transactionsDetail.nonce\n    );\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n  }\n  async signDeployAccountTransaction({\n    classHash,\n    contractAddress,\n    constructorCalldata,\n    addressSalt,\n    maxFee,\n    version,\n    chainId,\n    nonce\n  }) {\n    const msgHash = calculateDeployAccountTransactionHash(\n      contractAddress,\n      classHash,\n      CallData.compile(constructorCalldata),\n      addressSalt,\n      version,\n      maxFee,\n      chainId,\n      nonce\n    );\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n  }\n  async signDeclareTransaction({\n    classHash,\n    senderAddress,\n    chainId,\n    maxFee,\n    version,\n    nonce,\n    compiledClassHash\n  }) {\n    const msgHash = calculateDeclareTransactionHash(\n      classHash,\n      senderAddress,\n      version,\n      maxFee,\n      chainId,\n      nonce,\n      compiledClassHash\n    );\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n  }\n};\n\n// src/utils/events.ts\nfunction parseUDCEvent(txReceipt) {\n  if (!txReceipt.events) {\n    throw new Error(\"UDC emitted event is empty\");\n  }\n  const event = txReceipt.events.find(\n    (it) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)\n  ) || {\n    data: []\n  };\n  return {\n    transaction_hash: txReceipt.transaction_hash,\n    contract_address: event.data[0],\n    address: event.data[0],\n    deployer: event.data[1],\n    unique: event.data[2],\n    classHash: event.data[3],\n    calldata_len: event.data[4],\n    calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n    salt: event.data[event.data.length - 1]\n  };\n}\n\n// src/account/default.ts\nvar Account = class extends Provider {\n  constructor(providerOrOptions, address, pkOrSigner, cairoVersion) {\n    super(providerOrOptions);\n    this.deploySelf = this.deployAccount;\n    this.address = address.toLowerCase();\n    this.signer = typeof pkOrSigner === \"string\" || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n    if (cairoVersion) {\n      this.cairoVersion = cairoVersion.toString();\n    }\n  }\n  async getNonce(blockIdentifier) {\n    return super.getNonceForAddress(this.address, blockIdentifier);\n  }\n  async getNonceSafe(nonce) {\n    try {\n      return toBigInt(nonce ?? await this.getNonce());\n    } catch (error) {\n      return 0n;\n    }\n  }\n  /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */\n  async getCairoVersion(classHash) {\n    if (!this.cairoVersion) {\n      const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n      this.cairoVersion = cairo;\n    }\n    return this.cairoVersion;\n  }\n  async estimateFee(calls, estimateFeeDetails) {\n    return this.estimateInvokeFee(calls, estimateFeeDetails);\n  }\n  async estimateInvokeFee(calls, { nonce: providedNonce, blockIdentifier, skipValidate } = {}) {\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = toBigInt(feeTransactionVersion);\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      walletAddress: this.address,\n      nonce,\n      maxFee: ZERO,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion()\n    };\n    const invocation = await this.buildInvocation(transactions, signerDetails);\n    const response = await super.getInvokeEstimateFee(\n      { ...invocation },\n      { version, nonce },\n      blockIdentifier,\n      skipValidate\n    );\n    const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n    return {\n      ...response,\n      suggestedMaxFee\n    };\n  }\n  async estimateDeclareFee({ contract, classHash: providedClassHash, casm, compiledClassHash }, { blockIdentifier, nonce: providedNonce, skipValidate } = {}) {\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = !isSierra(contract) ? feeTransactionVersion : feeTransactionVersion_2;\n    const chainId = await this.getChainId();\n    const declareContractTransaction = await this.buildDeclarePayload(\n      { classHash: providedClassHash, contract, casm, compiledClassHash },\n      {\n        nonce,\n        chainId,\n        version,\n        walletAddress: this.address,\n        maxFee: ZERO,\n        cairoVersion: void 0\n        // unused parameter\n      }\n    );\n    const response = await super.getDeclareEstimateFee(\n      declareContractTransaction,\n      { version, nonce },\n      blockIdentifier,\n      skipValidate\n    );\n    const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n    return {\n      ...response,\n      suggestedMaxFee\n    };\n  }\n  async estimateAccountDeployFee({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress: providedContractAddress\n  }, { blockIdentifier, skipValidate } = {}) {\n    const version = toBigInt(feeTransactionVersion);\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const payload = await this.buildAccountDeployPayload(\n      { classHash, addressSalt, constructorCalldata, contractAddress: providedContractAddress },\n      {\n        nonce,\n        chainId,\n        version,\n        walletAddress: this.address,\n        // unused parameter\n        maxFee: ZERO,\n        cairoVersion: void 0\n        // unused parameter\n      }\n    );\n    const response = await super.getDeployAccountEstimateFee(\n      { ...payload },\n      { version, nonce },\n      blockIdentifier,\n      skipValidate\n    );\n    const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n    return {\n      ...response,\n      suggestedMaxFee\n    };\n  }\n  async estimateDeployFee(payload, transactionsDetail) {\n    const calls = this.buildUDCContractPayload(payload);\n    return this.estimateInvokeFee(calls, transactionsDetail);\n  }\n  async estimateFeeBulk(invocations, { nonce, blockIdentifier, skipValidate } = {}) {\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      versions: [feeTransactionVersion, feeTransactionVersion_2],\n      nonce,\n      blockIdentifier\n    });\n    const response = await super.getEstimateFeeBulk(accountInvocations, {\n      blockIdentifier,\n      skipValidate\n    });\n    return [].concat(response).map((elem) => {\n      const suggestedMaxFee = estimatedFeeToMaxFee(elem.overall_fee);\n      return {\n        ...elem,\n        suggestedMaxFee\n      };\n    });\n  }\n  async buildInvocation(call, signerDetails) {\n    const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n    const signature = await this.signer.signTransaction(call, signerDetails);\n    return {\n      contractAddress: this.address,\n      calldata,\n      signature\n    };\n  }\n  async execute(calls, abis = void 0, transactionsDetail = {}) {\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n    const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee(\n      { type: \"INVOKE_FUNCTION\" /* INVOKE */, payload: calls },\n      transactionsDetail\n    );\n    const version = toBigInt(transactionVersion);\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      walletAddress: this.address,\n      nonce,\n      maxFee,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion()\n    };\n    const signature = await this.signer.signTransaction(transactions, signerDetails, abis);\n    const calldata = getExecuteCalldata(transactions, await this.getCairoVersion());\n    return this.invokeFunction(\n      { contractAddress: this.address, calldata, signature },\n      {\n        nonce,\n        maxFee,\n        version\n      }\n    );\n  }\n  /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */\n  async declareIfNot(payload, transactionsDetail = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    try {\n      await this.getClassByHash(declareContractPayload.classHash);\n    } catch (error) {\n      return this.declare(payload, transactionsDetail);\n    }\n    return {\n      transaction_hash: \"\",\n      class_hash: declareContractPayload.classHash\n    };\n  }\n  async declare(payload, transactionsDetail = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    const details = {};\n    details.nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n    details.maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee(\n      {\n        type: \"DECLARE\" /* DECLARE */,\n        payload: declareContractPayload\n      },\n      transactionsDetail\n    );\n    details.version = !isSierra(payload.contract) ? transactionVersion : transactionVersion_2;\n    details.chainId = await this.getChainId();\n    const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, {\n      ...details,\n      walletAddress: this.address,\n      cairoVersion: void 0\n      // unused parameter\n    });\n    return this.declareContract(declareContractTransaction, details);\n  }\n  async deploy(payload, details) {\n    const params = [].concat(payload).map((it) => {\n      const {\n        classHash,\n        salt,\n        unique = true,\n        constructorCalldata = []\n      } = it;\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n      const deploySalt = salt ?? randomAddress();\n      return {\n        call: {\n          contractAddress: UDC.ADDRESS,\n          entrypoint: UDC.ENTRYPOINT,\n          calldata: [\n            classHash,\n            deploySalt,\n            toCairoBool(unique),\n            compiledConstructorCallData.length,\n            ...compiledConstructorCallData\n          ]\n        },\n        address: calculateContractAddressFromHash(\n          unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(this.address, deploySalt) : deploySalt,\n          classHash,\n          compiledConstructorCallData,\n          unique ? UDC.ADDRESS : 0\n        )\n      };\n    });\n    const calls = params.map((it) => it.call);\n    const addresses = params.map((it) => it.address);\n    const invokeResponse = await this.execute(calls, void 0, details);\n    return {\n      ...invokeResponse,\n      contract_address: addresses\n    };\n  }\n  async deployContract(payload, details) {\n    const deployTx = await this.deploy(payload, details);\n    const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n    return parseUDCEvent(txReceipt);\n  }\n  async declareAndDeploy(payload, details) {\n    const { constructorCalldata, salt, unique } = payload;\n    let declare = await this.declareIfNot(payload, details);\n    if (declare.transaction_hash !== \"\") {\n      const tx = await this.waitForTransaction(declare.transaction_hash);\n      declare = { ...declare, ...tx };\n    }\n    const deploy = await this.deployContract(\n      { classHash: declare.class_hash, salt, unique, constructorCalldata },\n      details\n    );\n    return { declare: { ...declare }, deploy };\n  }\n  async deployAccount({\n    classHash,\n    constructorCalldata = [],\n    addressSalt = 0,\n    contractAddress: providedContractAddress\n  }, transactionsDetail = {}) {\n    const version = toBigInt(transactionVersion);\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee(\n      {\n        type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n        payload: {\n          classHash,\n          constructorCalldata: compiledCalldata,\n          addressSalt,\n          contractAddress\n        }\n      },\n      transactionsDetail\n    );\n    const signature = await this.signer.signDeployAccountTransaction({\n      classHash,\n      constructorCalldata: compiledCalldata,\n      contractAddress,\n      addressSalt,\n      chainId,\n      maxFee,\n      version,\n      nonce\n    });\n    return this.deployAccountContract(\n      { classHash, addressSalt, constructorCalldata, signature },\n      {\n        nonce,\n        maxFee,\n        version\n      }\n    );\n  }\n  async signMessage(typedData) {\n    return this.signer.signMessage(typedData, this.address);\n  }\n  async hashMessage(typedData) {\n    return getMessageHash(typedData, this.address);\n  }\n  async verifyMessageHash(hash, signature) {\n    try {\n      await this.callContract({\n        contractAddress: this.address,\n        entrypoint: \"isValidSignature\",\n        calldata: CallData.compile({\n          hash: toBigInt(hash).toString(),\n          signature: formatSignature(signature)\n        })\n      });\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async verifyMessage(typedData, signature) {\n    const hash = await this.hashMessage(typedData);\n    return this.verifyMessageHash(hash, signature);\n  }\n  async getSuggestedMaxFee({ type, payload }, details) {\n    let feeEstimate;\n    switch (type) {\n      case \"INVOKE_FUNCTION\" /* INVOKE */:\n        feeEstimate = await this.estimateInvokeFee(payload, details);\n        break;\n      case \"DECLARE\" /* DECLARE */:\n        feeEstimate = await this.estimateDeclareFee(payload, details);\n        break;\n      case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */:\n        feeEstimate = await this.estimateAccountDeployFee(payload, details);\n        break;\n      case \"DEPLOY\" /* DEPLOY */:\n        feeEstimate = await this.estimateDeployFee(payload, details);\n        break;\n      default:\n        feeEstimate = { suggestedMaxFee: ZERO, overall_fee: ZERO };\n        break;\n    }\n    return feeEstimate.suggestedMaxFee;\n  }\n  /**\n   * will be renamed to buildDeclareContractTransaction\n   */\n  async buildDeclarePayload(payload, { nonce, chainId, version, walletAddress, maxFee }) {\n    const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n    const compressedCompiledContract = parseContract(contract);\n    const signature = await this.signer.signDeclareTransaction({\n      classHash,\n      compiledClassHash,\n      senderAddress: walletAddress,\n      chainId,\n      maxFee,\n      version,\n      nonce\n    });\n    return {\n      senderAddress: walletAddress,\n      signature,\n      contract: compressedCompiledContract,\n      compiledClassHash\n    };\n  }\n  async buildAccountDeployPayload({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress: providedContractAddress\n  }, { nonce, chainId, version, maxFee }) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const signature = await this.signer.signDeployAccountTransaction({\n      classHash,\n      contractAddress,\n      chainId,\n      maxFee,\n      version,\n      nonce,\n      addressSalt,\n      constructorCalldata: compiledCalldata\n    });\n    return {\n      classHash,\n      addressSalt,\n      constructorCalldata: compiledCalldata,\n      signature\n    };\n  }\n  buildUDCContractPayload(payload) {\n    const calls = [].concat(payload).map((it) => {\n      const {\n        classHash,\n        salt = \"0\",\n        unique = true,\n        constructorCalldata = []\n      } = it;\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n      return {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          salt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData\n        ]\n      };\n    });\n    return calls;\n  }\n  async simulateTransaction(invocations, { nonce, blockIdentifier, skipValidate, skipExecute } = {}) {\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      versions: [transactionVersion, transactionVersion_2],\n      nonce,\n      blockIdentifier\n    });\n    return super.getSimulateTransaction(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n      skipExecute\n    });\n  }\n  async accountInvocationsFactory(invocations, { versions, nonce, blockIdentifier }) {\n    const version = versions[0];\n    const safeNonce = await this.getNonceSafe(nonce);\n    const chainId = await this.getChainId();\n    const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n    const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n    return Promise.all(\n      [].concat(invocations).map(async (transaction, index) => {\n        const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n        const signerDetails = {\n          walletAddress: this.address,\n          nonce: toBigInt(Number(safeNonce) + index),\n          maxFee: ZERO,\n          version,\n          chainId,\n          cairoVersion\n        };\n        const common = {\n          type: transaction.type,\n          version,\n          nonce: toBigInt(Number(safeNonce) + index),\n          blockIdentifier\n        };\n        if (transaction.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n          const payload = await this.buildInvocation(\n            [].concat(txPayload),\n            signerDetails\n          );\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        if (transaction.type === \"DECLARE\" /* DECLARE */) {\n          signerDetails.version = !isSierra(txPayload.contract) ? toBigInt(versions[0]) : toBigInt(versions[1]);\n          const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            version: signerDetails.version\n          };\n        }\n        if (transaction.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n          const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        if (transaction.type === \"DEPLOY\" /* DEPLOY */) {\n          const calls = this.buildUDCContractPayload(txPayload);\n          const payload = await this.buildInvocation(calls, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            type: \"INVOKE_FUNCTION\" /* INVOKE */\n          };\n        }\n        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n      })\n    );\n  }\n  async getStarkName(address = this.address, StarknetIdContract2) {\n    return super.getStarkName(address, StarknetIdContract2);\n  }\n};\n\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n\n// src/provider/index.ts\nvar defaultProvider = new Provider({ rpc: { default: true } });\n\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n  getAbiEvents: () => getAbiEvents,\n  parseEvents: () => parseEvents\n});\nfunction getAbiEvents(abi) {\n  return abi.filter((abiEntry) => abiEntry.type === \"event\" && (abiEntry.size || abiEntry.kind !== \"enum\")).reduce((acc, abiEntry) => {\n    const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(\":\") + 1);\n    const abiEntryMod = { ...abiEntry };\n    abiEntryMod.name = entryName;\n    return {\n      ...acc,\n      [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n    };\n  }, {});\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n  const ret = providerReceivedEvents.flat().reduce((acc, recEvent) => {\n    const abiEvent = abiEvents[recEvent.keys[0]];\n    if (!abiEvent) {\n      return acc;\n    }\n    const parsedEvent = {};\n    parsedEvent[abiEvent.name] = {};\n    recEvent.keys.shift();\n    const keysIter = recEvent.keys[Symbol.iterator]();\n    const dataIter = recEvent.data[Symbol.iterator]();\n    const abiEventKeys = abiEvent.members?.filter((it) => it.kind === \"key\") || abiEvent.keys;\n    const abiEventData = abiEvent.members?.filter((it) => it.kind === \"data\") || abiEvent.data;\n    abiEventKeys.forEach((key) => {\n      parsedEvent[abiEvent.name][key.name] = responseParser(\n        keysIter,\n        key,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    abiEventData.forEach((data) => {\n      parsedEvent[abiEvent.name][data.name] = responseParser(\n        dataIter,\n        data,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    acc.push(parsedEvent);\n    return acc;\n  }, []);\n  return ret;\n}\n\n// src/contract/default.ts\nvar splitArgsAndOptions = (args) => {\n  const options = [\n    \"blockIdentifier\",\n    \"parseRequest\",\n    \"parseResponse\",\n    \"formatResponse\",\n    \"maxFee\",\n    \"nonce\",\n    \"signature\",\n    \"addressSalt\"\n  ];\n  const lastArg = args[args.length - 1];\n  if (typeof lastArg === \"object\" && options.some((x) => x in lastArg)) {\n    return { args, options: args.pop() };\n  }\n  return { args };\n};\nfunction buildCall(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.call(functionAbi.name, params.args, {\n      parseRequest: true,\n      parseResponse: true,\n      ...params.options\n    });\n  };\n}\nfunction buildInvoke(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.invoke(functionAbi.name, params.args, {\n      parseRequest: true,\n      ...params.options\n    });\n  };\n}\nfunction buildDefault(contract, functionAbi) {\n  if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n  return function(...args) {\n    return contract.populate(functionAbi.name, args);\n  };\n}\nfunction buildEstimate(contract, functionAbi) {\n  return function(...args) {\n    return contract.estimate(functionAbi.name, args);\n  };\n}\nfunction getCalldata(args, callback) {\n  if (Array.isArray(args) && \"__compiled__\" in args)\n    return args;\n  if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0])\n    return args[0];\n  return callback();\n}\nvar Contract = class {\n  /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */\n  constructor(abi, address, providerOrAccount = defaultProvider) {\n    this.address = address && address.toLowerCase();\n    this.providerOrAccount = providerOrAccount;\n    this.callData = new CallData(abi);\n    this.structs = CallData.getAbiStruct(abi);\n    this.events = getAbiEvents(abi);\n    const parser = createAbiParser(abi);\n    this.abi = parser.getLegacyFormat();\n    const options = { enumerable: true, value: {}, writable: false };\n    Object.defineProperties(this, {\n      functions: { enumerable: true, value: {}, writable: false },\n      callStatic: { enumerable: true, value: {}, writable: false },\n      populateTransaction: { enumerable: true, value: {}, writable: false },\n      estimateFee: { enumerable: true, value: {}, writable: false }\n    });\n    this.abi.forEach((abiElement) => {\n      if (abiElement.type !== \"function\")\n        return;\n      const signature = abiElement.name;\n      if (!this[signature]) {\n        Object.defineProperty(this, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.functions[signature]) {\n        Object.defineProperty(this.functions, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.callStatic[signature]) {\n        Object.defineProperty(this.callStatic, signature, {\n          ...options,\n          value: buildCall(this, abiElement)\n        });\n      }\n      if (!this.populateTransaction[signature]) {\n        Object.defineProperty(this.populateTransaction, signature, {\n          ...options,\n          value: buildPopulate(this, abiElement)\n        });\n      }\n      if (!this.estimateFee[signature]) {\n        Object.defineProperty(this.estimateFee, signature, {\n          ...options,\n          value: buildEstimate(this, abiElement)\n        });\n      }\n    });\n  }\n  attach(address) {\n    this.address = address;\n  }\n  connect(providerOrAccount) {\n    this.providerOrAccount = providerOrAccount;\n  }\n  async deployed() {\n    if (this.deployTransactionHash) {\n      await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n      this.deployTransactionHash = void 0;\n    }\n    return this;\n  }\n  async call(method, args = [], {\n    parseRequest = true,\n    parseResponse = true,\n    formatResponse = void 0,\n    blockIdentifier = void 0\n  } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(\"CALL\" /* CALL */, method, args);\n        return this.callData.compile(method, args);\n      }\n      console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    return this.providerOrAccount.callContract(\n      {\n        contractAddress: this.address,\n        calldata,\n        entrypoint: method\n      },\n      blockIdentifier\n    ).then((x) => {\n      if (!parseResponse) {\n        return x.result;\n      }\n      if (formatResponse) {\n        return this.callData.format(method, x.result, formatResponse);\n      }\n      return this.callData.parse(method, x.result);\n    });\n  }\n  invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(\"INVOKE\" /* INVOKE */, method, args);\n        return this.callData.compile(method, args);\n      }\n      console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    const invocation = {\n      contractAddress: this.address,\n      calldata,\n      entrypoint: method\n    };\n    if (\"execute\" in this.providerOrAccount) {\n      return this.providerOrAccount.execute(invocation, void 0, {\n        maxFee,\n        nonce\n      });\n    }\n    if (!nonce)\n      throw new Error(`Nonce is required when invoking a function without an account`);\n    console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n    return this.providerOrAccount.invokeFunction(\n      {\n        ...invocation,\n        signature\n      },\n      {\n        nonce\n      }\n    );\n  }\n  async estimate(method, args = []) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    if (!getCalldata(args, () => false)) {\n      this.callData.validate(\"INVOKE\" /* INVOKE */, method, args);\n    }\n    const invocation = this.populate(method, args);\n    if (\"estimateInvokeFee\" in this.providerOrAccount) {\n      return this.providerOrAccount.estimateInvokeFee(invocation);\n    }\n    throw Error(\"Contract must be connected to the account contract to estimate\");\n  }\n  populate(method, args = []) {\n    const calldata = getCalldata(args, () => this.callData.compile(method, args));\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata\n    };\n  }\n  parseEvents(receipt) {\n    return parseEvents(\n      receipt.events?.filter(\n        (event) => cleanHex(event.from_address) === cleanHex(this.address),\n        []\n      ) || [],\n      this.events,\n      this.structs,\n      CallData.getAbiEnum(this.abi)\n    );\n  }\n  isCairo1() {\n    return cairo_exports.isCairo1Abi(this.abi);\n  }\n  async getVersion() {\n    return this.providerOrAccount.getContractVersion(this.address);\n  }\n  typed(tAbi) {\n    return this;\n  }\n};\n\n// src/contract/interface.ts\nvar ContractInterface = class {\n};\n\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n  /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */\n  constructor(params) {\n    this.compiledContract = params.compiledContract;\n    this.account = params.account;\n    this.casm = params.casm;\n    this.abi = params.abi ?? params.compiledContract.abi;\n    this.classHash = params.classHash;\n    this.compiledClassHash = params.compiledClassHash;\n    this.CallData = new CallData(this.abi);\n  }\n  /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */\n  async deploy(...args) {\n    const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);\n    const constructorCalldata = getCalldata(param, () => {\n      if (options.parseRequest) {\n        this.CallData.validate(\"DEPLOY\" /* DEPLOY */, \"constructor\", param);\n        return this.CallData.compile(\"constructor\", param);\n      }\n      console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return param;\n    });\n    const {\n      deploy: { contract_address, transaction_hash }\n    } = await this.account.declareAndDeploy({\n      contract: this.compiledContract,\n      casm: this.casm,\n      classHash: this.classHash,\n      compiledClassHash: this.compiledClassHash,\n      constructorCalldata,\n      salt: options.addressSalt\n    });\n    assert(Boolean(contract_address), \"Deployment of the contract failed\");\n    const contractInstance = new Contract(\n      this.compiledContract.abi,\n      contract_address,\n      this.account\n    );\n    contractInstance.deployTransactionHash = transaction_hash;\n    return contractInstance;\n  }\n  /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */\n  connect(account) {\n    this.account = account;\n    return this;\n  }\n  /**\n   * Attaches current abi and account to the new address\n   */\n  attach(address) {\n    return new Contract(this.abi, address, this.account);\n  }\n  // ethers.js' getDeployTransaction cant be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation\n};\n\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n  return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, \"0\"));\n}\nfunction validateAndParseAddress(address) {\n  assertInRange(address, ZERO, ADDR_BOUND - 1n, \"Starknet Address\");\n  const result = addAddressPadding(address);\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error(\"Invalid Address Format\");\n  }\n  return result;\n}\nfunction getChecksumAddress(address) {\n  const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n  const hex = removeHexPrefix(keccakBn(address));\n  const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(hex.padStart(64, \"0\"));\n  for (let i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 15) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n  return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n  return getChecksumAddress(address) === address;\n}\n\n// src/index.ts\nvar number = num_exports;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtDQUFNO0FBQ2Y7QUFDQTtBQUNBLFNBQVMsK0NBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBC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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBMEQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2dDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3RUFBVztBQUM1QixrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBdUVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3MtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanM/YTZkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgY29uc3RhbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNvbnN0YW50c19leHBvcnRzLCB7XG4gIEFERFJfQk9VTkQ6ICgpID0+IEFERFJfQk9VTkQsXG4gIEFQSV9WRVJTSU9OOiAoKSA9PiBBUElfVkVSU0lPTixcbiAgQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTogKCkgPT4gQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSxcbiAgQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMjogKCkgPT4gQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMixcbiAgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8xOiAoKSA9PiBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzEsXG4gIEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMjogKCkgPT4gQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8yLFxuICBCYXNlVXJsOiAoKSA9PiBCYXNlVXJsLFxuICBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTogKCkgPT4gSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEsXG4gIEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8yOiAoKSA9PiBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMixcbiAgSVNfQlJPV1NFUjogKCkgPT4gSVNfQlJPV1NFUixcbiAgTUFTS18yNTA6ICgpID0+IE1BU0tfMjUwLFxuICBNQVhfU1RPUkFHRV9JVEVNX1NJWkU6ICgpID0+IE1BWF9TVE9SQUdFX0lURU1fU0laRSxcbiAgTmV0d29ya05hbWU6ICgpID0+IE5ldHdvcmtOYW1lLFxuICBSUENfREVGQVVMVF9WRVJTSU9OOiAoKSA9PiBSUENfREVGQVVMVF9WRVJTSU9OLFxuICBSUENfTk9ERVM6ICgpID0+IFJQQ19OT0RFUyxcbiAgU3RhcmtuZXRDaGFpbklkOiAoKSA9PiBTdGFya25ldENoYWluSWQsXG4gIFRFWFRfVE9fRkVMVF9NQVhfTEVOOiAoKSA9PiBURVhUX1RPX0ZFTFRfTUFYX0xFTixcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4OiAoKSA9PiBUcmFuc2FjdGlvbkhhc2hQcmVmaXgsXG4gIFVEQzogKCkgPT4gVURDLFxuICBaRVJPOiAoKSA9PiBaRVJPXG59KTtcblxuLy8gc3JjL3V0aWxzL2VuY29kZS50c1xudmFyIGVuY29kZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChlbmNvZGVfZXhwb3J0cywge1xuICBJU19CUk9XU0VSOiAoKSA9PiBJU19CUk9XU0VSLFxuICBhZGRIZXhQcmVmaXg6ICgpID0+IGFkZEhleFByZWZpeCxcbiAgYXJyYXlCdWZmZXJUb1N0cmluZzogKCkgPT4gYXJyYXlCdWZmZXJUb1N0cmluZyxcbiAgYXRvYlVuaXZlcnNhbDogKCkgPT4gYXRvYlVuaXZlcnNhbCxcbiAgYnRvYVVuaXZlcnNhbDogKCkgPT4gYnRvYVVuaXZlcnNhbCxcbiAgYnVmMmhleDogKCkgPT4gYnVmMmhleCxcbiAgY2FsY0J5dGVMZW5ndGg6ICgpID0+IGNhbGNCeXRlTGVuZ3RoLFxuICBwYWRMZWZ0OiAoKSA9PiBwYWRMZWZ0LFxuICBwYXNjYWxUb1NuYWtlOiAoKSA9PiBwYXNjYWxUb1NuYWtlLFxuICByZW1vdmVIZXhQcmVmaXg6ICgpID0+IHJlbW92ZUhleFByZWZpeCxcbiAgc2FuaXRpemVCeXRlczogKCkgPT4gc2FuaXRpemVCeXRlcyxcbiAgc2FuaXRpemVIZXg6ICgpID0+IHNhbml0aXplSGV4LFxuICBzdHJpbmdUb0FycmF5QnVmZmVyOiAoKSA9PiBzdHJpbmdUb0FycmF5QnVmZmVyLFxuICB1dGY4VG9BcnJheTogKCkgPT4gdXRmOFRvQXJyYXlcbn0pO1xuaW1wb3J0IHsgYmFzZTY0IH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgSVNfQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgU1RSSU5HX1pFUk8gPSBcIjBcIjtcbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9TdHJpbmcoYXJyYXkpIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5KS5yZWR1Y2UoKGRhdGEsIGJ5dGUpID0+IGRhdGEgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0FycmF5KHN0cikge1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5QnVmZmVyKHN0cikge1xuICByZXR1cm4gdXRmOFRvQXJyYXkoc3RyKTtcbn1cbmZ1bmN0aW9uIGF0b2JVbml2ZXJzYWwoYSkge1xuICByZXR1cm4gYmFzZTY0LmRlY29kZShhKTtcbn1cbmZ1bmN0aW9uIGJ0b2FVbml2ZXJzYWwoYikge1xuICByZXR1cm4gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShiKSk7XG59XG5mdW5jdGlvbiBidWYyaGV4KGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnJlZHVjZSgociwgeCkgPT4gciArIHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG59XG5mdW5jdGlvbiByZW1vdmVIZXhQcmVmaXgoaGV4KSB7XG4gIHJldHVybiBoZXgucmVwbGFjZSgvXjB4L2ksIFwiXCIpO1xufVxuZnVuY3Rpb24gYWRkSGV4UHJlZml4KGhleCkge1xuICByZXR1cm4gYDB4JHtyZW1vdmVIZXhQcmVmaXgoaGV4KX1gO1xufVxuZnVuY3Rpb24gcGFkU3RyaW5nKHN0ciwgbGVuZ3RoLCBsZWZ0LCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgY29uc3QgZGlmZiA9IGxlbmd0aCAtIHN0ci5sZW5ndGg7XG4gIGxldCByZXN1bHQgPSBzdHI7XG4gIGlmIChkaWZmID4gMCkge1xuICAgIGNvbnN0IHBhZCA9IHBhZGRpbmcucmVwZWF0KGRpZmYpO1xuICAgIHJlc3VsdCA9IGxlZnQgPyBwYWQgKyBzdHIgOiBzdHIgKyBwYWQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhZExlZnQoc3RyLCBsZW5ndGgsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICByZXR1cm4gcGFkU3RyaW5nKHN0ciwgbGVuZ3RoLCB0cnVlLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIGNhbGNCeXRlTGVuZ3RoKHN0ciwgYnl0ZVNpemUgPSA4KSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdHI7XG4gIGNvbnN0IHJlbWFpbmRlciA9IGxlbmd0aCAlIGJ5dGVTaXplO1xuICByZXR1cm4gcmVtYWluZGVyID8gKGxlbmd0aCAtIHJlbWFpbmRlcikgLyBieXRlU2l6ZSAqIGJ5dGVTaXplICsgYnl0ZVNpemUgOiBsZW5ndGg7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUJ5dGVzKHN0ciwgYnl0ZVNpemUgPSA4LCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgcmV0dXJuIHBhZExlZnQoc3RyLCBjYWxjQnl0ZUxlbmd0aChzdHIsIGJ5dGVTaXplKSwgcGFkZGluZyk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUhleChoZXgpIHtcbiAgaGV4ID0gcmVtb3ZlSGV4UHJlZml4KGhleCk7XG4gIGhleCA9IHNhbml0aXplQnl0ZXMoaGV4LCAyKTtcbiAgaWYgKGhleCkge1xuICAgIGhleCA9IGFkZEhleFByZWZpeChoZXgpO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG52YXIgcGFzY2FsVG9TbmFrZSA9ICh0ZXh0KSA9PiAvW2Etel0vLnRlc3QodGV4dCkgPyB0ZXh0LnNwbGl0KC8oPz1bQS1aXSkvKS5qb2luKFwiX1wiKS50b1VwcGVyQ2FzZSgpIDogdGV4dDtcblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIFRFWFRfVE9fRkVMVF9NQVhfTEVOID0gMzE7XG52YXIgSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEgPSBcIjB4MVwiO1xudmFyIEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8yID0gXCIweDJcIjtcbnZhciBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzEgPSAxbjtcbnZhciBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzIgPSAybjtcbnZhciBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8xID0gMm4gKiogMTI4biArIEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTtcbnZhciBCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8yID0gMm4gKiogMTI4biArIEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMjtcbnZhciBaRVJPID0gMG47XG52YXIgTUFTS18yNTAgPSAybiAqKiAyNTBuIC0gMW47XG52YXIgQVBJX1ZFUlNJT04gPSBaRVJPO1xudmFyIE1BWF9TVE9SQUdFX0lURU1fU0laRSA9IDI1Nm47XG52YXIgQUREUl9CT1VORCA9IDJuICoqIDI1MW4gLSBNQVhfU1RPUkFHRV9JVEVNX1NJWkU7XG52YXIgQmFzZVVybCA9IC8qIEBfX1BVUkVfXyAqLyAoKEJhc2VVcmwyKSA9PiB7XG4gIEJhc2VVcmwyW1wiU05fTUFJTlwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1tYWlubmV0LnN0YXJrbmV0LmlvXCI7XG4gIEJhc2VVcmwyW1wiU05fR09FUkxJXCJdID0gXCJodHRwczovL2FscGhhNC5zdGFya25ldC5pb1wiO1xuICBCYXNlVXJsMltcIlNOX1NFUE9MSUFcIl0gPSBcImh0dHBzOi8vYWxwaGEtc2Vwb2xpYS5zdGFya25ldC5pb1wiO1xuICByZXR1cm4gQmFzZVVybDI7XG59KShCYXNlVXJsIHx8IHt9KTtcbnZhciBOZXR3b3JrTmFtZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ldHdvcmtOYW1lMikgPT4ge1xuICBOZXR3b3JrTmFtZTJbXCJTTl9NQUlOXCJdID0gXCJTTl9NQUlOXCI7XG4gIE5ldHdvcmtOYW1lMltcIlNOX0dPRVJMSVwiXSA9IFwiU05fR09FUkxJXCI7XG4gIE5ldHdvcmtOYW1lMltcIlNOX1NFUE9MSUFcIl0gPSBcIlNOX1NFUE9MSUFcIjtcbiAgcmV0dXJuIE5ldHdvcmtOYW1lMjtcbn0pKE5ldHdvcmtOYW1lIHx8IHt9KTtcbnZhciBTdGFya25ldENoYWluSWQgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldENoYWluSWQ0KSA9PiB7XG4gIFN0YXJrbmV0Q2hhaW5JZDRbXCJTTl9NQUlOXCJdID0gXCIweDUzNGU1ZjRkNDE0OTRlXCI7XG4gIFN0YXJrbmV0Q2hhaW5JZDRbXCJTTl9HT0VSTElcIl0gPSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCI7XG4gIFN0YXJrbmV0Q2hhaW5JZDRbXCJTTl9TRVBPTElBXCJdID0gXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCI7XG4gIHJldHVybiBTdGFya25ldENoYWluSWQ0O1xufSkoU3RhcmtuZXRDaGFpbklkIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkhhc2hQcmVmaXggPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkhhc2hQcmVmaXgyKSA9PiB7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERUNMQVJFXCJdID0gXCIweDY0NjU2MzZjNjE3MjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lcIl0gPSBcIjB4NjQ2NTcwNmM2Zjc5XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJJTlZPS0VcIl0gPSBcIjB4Njk2ZTc2NmY2YjY1XCI7XG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDJbXCJMMV9IQU5ETEVSXCJdID0gXCIweDZjMzE1ZjY4NjE2ZTY0NmM2NTcyXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyO1xufSkoVHJhbnNhY3Rpb25IYXNoUHJlZml4IHx8IHt9KTtcbnZhciBVREMgPSB7XG4gIEFERFJFU1M6IFwiMHgwNDFhNzhlNzQxZTVhZjJmZWMzNGI2OTU2NzliYzY4OTE3NDI0MzlmN2FmYjg0ODRlY2Q3NzY2NjYxYWQwMmJmXCIsXG4gIEVOVFJZUE9JTlQ6IFwiZGVwbG95Q29udHJhY3RcIlxufTtcbnZhciBSUENfREVGQVVMVF9WRVJTSU9OID0gXCJ2MF81XCI7XG52YXIgUlBDX05PREVTID0ge1xuICBTTl9HT0VSTEk6IFtcbiAgICBgaHR0cHM6Ly9zdGFya25ldC10ZXN0bmV0LnB1YmxpYy5ibGFzdGFwaS5pby9ycGMvYCxcbiAgICBgaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL2dvZXJsaS1qdW5vL2BcbiAgXSxcbiAgU05fTUFJTjogW1xuICAgIGBodHRwczovL3N0YXJrbmV0LW1haW5uZXQucHVibGljLmJsYXN0YXBpLmlvL3JwYy9gLFxuICAgIGBodHRwczovL2ZyZWUtcnBjLm5ldGhlcm1pbmQuaW8vbWFpbm5ldC1qdW5vL2BcbiAgXSxcbiAgU05fU0VQT0xJQTogW1xuICAgIGBodHRwczovL3N0YXJrbmV0LXNlcG9saWEucHVibGljLmJsYXN0YXBpLmlvL3JwYy9gLFxuICAgIGBodHRwczovL2ZyZWUtcnBjLm5ldGhlcm1pbmQuaW8vc2Vwb2xpYS1qdW5vL2BcbiAgXVxufTtcblxuLy8gc3JjL3R5cGVzL2luZGV4LnRzXG52YXIgdHlwZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZXNfZXhwb3J0cywge1xuICBCbG9ja1N0YXR1czogKCkgPT4gQmxvY2tTdGF0dXMsXG4gIEJsb2NrVGFnOiAoKSA9PiBCbG9ja1RhZyxcbiAgRW50cnlQb2ludFR5cGU6ICgpID0+IEVudHJ5UG9pbnRUeXBlLFxuICBMaXR0ZXJhbDogKCkgPT4gTGl0dGVyYWwsXG4gIFJQQzogKCkgPT4gcnBjX2V4cG9ydHMsXG4gIFNJTVVMQVRJT05fRkxBRzogKCkgPT4gU0lNVUxBVElPTl9GTEFHLFxuICBTZXF1ZW5jZXI6ICgpID0+IHNlcXVlbmNlcl9leHBvcnRzLFxuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25UeXBlOiAoKSA9PiBUcmFuc2FjdGlvblR5cGUsXG4gIFVpbnQ6ICgpID0+IFVpbnQsXG4gIFZhbGlkYXRlVHlwZTogKCkgPT4gVmFsaWRhdGVUeXBlXG59KTtcblxuLy8gc3JjL3R5cGVzL2FjY291bnQudHNcbnZhciBTSU1VTEFUSU9OX0ZMQUcgPSAvKiBAX19QVVJFX18gKi8gKChTSU1VTEFUSU9OX0ZMQUcyKSA9PiB7XG4gIFNJTVVMQVRJT05fRkxBRzJbXCJTS0lQX1ZBTElEQVRFXCJdID0gXCJTS0lQX1ZBTElEQVRFXCI7XG4gIFNJTVVMQVRJT05fRkxBRzJbXCJTS0lQX0VYRUNVVEVcIl0gPSBcIlNLSVBfRVhFQ1VURVwiO1xuICByZXR1cm4gU0lNVUxBVElPTl9GTEFHMjtcbn0pKFNJTVVMQVRJT05fRkxBRyB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9jYWxsZGF0YS50c1xudmFyIFZhbGlkYXRlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFZhbGlkYXRlVHlwZTIpID0+IHtcbiAgVmFsaWRhdGVUeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJDQUxMXCJdID0gXCJDQUxMXCI7XG4gIFZhbGlkYXRlVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRVwiO1xuICByZXR1cm4gVmFsaWRhdGVUeXBlMjtcbn0pKFZhbGlkYXRlVHlwZSB8fCB7fSk7XG52YXIgVWludCA9IC8qIEBfX1BVUkVfXyAqLyAoKFVpbnQyKSA9PiB7XG4gIFVpbnQyW1widThcIl0gPSBcImNvcmU6OmludGVnZXI6OnU4XCI7XG4gIFVpbnQyW1widTE2XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MTZcIjtcbiAgVWludDJbXCJ1MzJcIl0gPSBcImNvcmU6OmludGVnZXI6OnUzMlwiO1xuICBVaW50MltcInU2NFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTY0XCI7XG4gIFVpbnQyW1widTEyOFwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiO1xuICBVaW50MltcInUyNTZcIl0gPSBcImNvcmU6OmludGVnZXI6OnUyNTZcIjtcbiAgcmV0dXJuIFVpbnQyO1xufSkoVWludCB8fCB7fSk7XG52YXIgTGl0dGVyYWwgPSAvKiBAX19QVVJFX18gKi8gKChMaXR0ZXJhbDIpID0+IHtcbiAgTGl0dGVyYWwyW1wiQ2xhc3NIYXNoXCJdID0gXCJjb3JlOjpzdGFya25ldDo6Y2xhc3NfaGFzaDo6Q2xhc3NIYXNoXCI7XG4gIExpdHRlcmFsMltcIkNvbnRyYWN0QWRkcmVzc1wiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xuICByZXR1cm4gTGl0dGVyYWwyO1xufSkoTGl0dGVyYWwgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvbGliL2NvbnRyYWN0L2luZGV4LnRzXG52YXIgRW50cnlQb2ludFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFbnRyeVBvaW50VHlwZTIpID0+IHtcbiAgRW50cnlQb2ludFR5cGUyW1wiRVhURVJOQUxcIl0gPSBcIkVYVEVSTkFMXCI7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkwxX0hBTkRMRVJcIl0gPSBcIkwxX0hBTkRMRVJcIjtcbiAgRW50cnlQb2ludFR5cGUyW1wiQ09OU1RSVUNUT1JcIl0gPSBcIkNPTlNUUlVDVE9SXCI7XG4gIHJldHVybiBFbnRyeVBvaW50VHlwZTI7XG59KShFbnRyeVBvaW50VHlwZSB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9saWIvaW5kZXgudHNcbnZhciBUcmFuc2FjdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvblR5cGUyKSA9PiB7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJERUNMQVJFXCJdID0gXCJERUNMQVJFXCI7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZX0FDQ09VTlRcIl0gPSBcIkRFUExPWV9BQ0NPVU5UXCI7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRV9GVU5DVElPTlwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlMjtcbn0pKFRyYW5zYWN0aW9uVHlwZSB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvblN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiTk9UX1JFQ0VJVkVEXCJdID0gXCJOT1RfUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXMyO1xufSkoVHJhbnNhY3Rpb25TdGF0dXMgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIk5PVF9SRUNFSVZFRFwiXSA9IFwiTk9UX1JFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJSRVZFUlRFRFwiXSA9IFwiUkVWRVJURURcIjtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiU1VDQ0VFREVEXCJdID0gXCJTVUNDRUVERURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBCbG9ja1N0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJsb2NrU3RhdHVzMikgPT4ge1xuICBCbG9ja1N0YXR1czJbXCJQRU5ESU5HXCJdID0gXCJQRU5ESU5HXCI7XG4gIEJsb2NrU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICBCbG9ja1N0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgQmxvY2tTdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIHJldHVybiBCbG9ja1N0YXR1czI7XG59KShCbG9ja1N0YXR1cyB8fCB7fSk7XG52YXIgQmxvY2tUYWcgPSAvKiBAX19QVVJFX18gKi8gKChCbG9ja1RhZzIpID0+IHtcbiAgQmxvY2tUYWcyW1wicGVuZGluZ1wiXSA9IFwicGVuZGluZ1wiO1xuICBCbG9ja1RhZzJbXCJsYXRlc3RcIl0gPSBcImxhdGVzdFwiO1xuICByZXR1cm4gQmxvY2tUYWcyO1xufSkoQmxvY2tUYWcgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwYy50c1xudmFyIHJwY19leHBvcnRzID0ge307XG5fX2V4cG9ydChycGNfZXhwb3J0cywge1xuICBFQmxvY2tUYWc6ICgpID0+IEVCbG9ja1RhZyxcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlOiAoKSA9PiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gIEVTaW11bGF0aW9uRmxhZzogKCkgPT4gRVNpbXVsYXRpb25GbGFnLFxuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzLFxuICBFVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IEVUcmFuc2FjdGlvblN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uVHlwZTogKCkgPT4gRVRyYW5zYWN0aW9uVHlwZSxcbiAgRXJyb3JzOiAoKSA9PiBlcnJvcnNfZXhwb3J0cyxcbiAgSlJQQzogKCkgPT4ganNvbnJwY19leHBvcnRzLFxuICBTUEVDOiAoKSA9PiBjb21wb25lbnRzX2V4cG9ydHNcbn0pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL2pzb25ycGMvaW5kZXgudHNcbnZhciBqc29ucnBjX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjL2Vycm9ycy50c1xudmFyIGVycm9yc19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlYy9jb21wb25lbnRzLnRzXG52YXIgY29tcG9uZW50c19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlYy9ub25zcGVjLnRzXG52YXIgRVRyYW5zYWN0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvblR5cGUyKSA9PiB7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiREVDTEFSRVwiXSA9IFwiREVDTEFSRVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZX0FDQ09VTlRcIl0gPSBcIkRFUExPWV9BQ0NPVU5UXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJMMV9IQU5ETEVSXCJdID0gXCJMMV9IQU5ETEVSXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25UeXBlMjtcbn0pKEVUcmFuc2FjdGlvblR5cGUgfHwge30pO1xudmFyIEVTaW11bGF0aW9uRmxhZyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVTaW11bGF0aW9uRmxhZzIpID0+IHtcbiAgRVNpbXVsYXRpb25GbGFnMltcIlNLSVBfVkFMSURBVEVcIl0gPSBcIlNLSVBfVkFMSURBVEVcIjtcbiAgRVNpbXVsYXRpb25GbGFnMltcIlNLSVBfRkVFX0NIQVJHRVwiXSA9IFwiU0tJUF9GRUVfQ0hBUkdFXCI7XG4gIHJldHVybiBFU2ltdWxhdGlvbkZsYWcyO1xufSkoRVNpbXVsYXRpb25GbGFnIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25TdGF0dXMyKSA9PiB7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJSRUNFSVZFRFwiXSA9IFwiUkVDRUlWRURcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25TdGF0dXMgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyKSA9PiB7XG4gIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyKSA9PiB7XG4gIEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJTVUNDRUVERURcIl0gPSBcIlNVQ0NFRURFRFwiO1xuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiUkVWRVJURURcIl0gPSBcIlJFVkVSVEVEXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBFQmxvY2tUYWcgPSAvKiBAX19QVVJFX18gKi8gKChFQmxvY2tUYWcyKSA9PiB7XG4gIEVCbG9ja1RhZzJbXCJMQVRFU1RcIl0gPSBcImxhdGVzdFwiO1xuICBFQmxvY2tUYWcyW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICByZXR1cm4gRUJsb2NrVGFnMjtcbn0pKEVCbG9ja1RhZyB8fCB7fSk7XG52YXIgRURhdGFBdmFpbGFiaWxpdHlNb2RlID0gLyogQF9fUFVSRV9fICovICgoRURhdGFBdmFpbGFiaWxpdHlNb2RlMikgPT4ge1xuICBFRGF0YUF2YWlsYWJpbGl0eU1vZGUyW1wiTDFcIl0gPSBcIkwxXCI7XG4gIEVEYXRhQXZhaWxhYmlsaXR5TW9kZTJbXCJMMlwiXSA9IFwiTDJcIjtcbiAgcmV0dXJuIEVEYXRhQXZhaWxhYmlsaXR5TW9kZTI7XG59KShFRGF0YUF2YWlsYWJpbGl0eU1vZGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL3NlcXVlbmNlci50c1xudmFyIHNlcXVlbmNlcl9leHBvcnRzID0ge307XG5cbi8vIHNyYy91dGlscy9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCBcIkFzc2VydGlvbiBmYWlsdXJlXCIpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9udW0udHNcbnZhciBudW1fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobnVtX2V4cG9ydHMsIHtcbiAgYXNzZXJ0SW5SYW5nZTogKCkgPT4gYXNzZXJ0SW5SYW5nZSxcbiAgYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheTogKCkgPT4gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheSxcbiAgYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXk6ICgpID0+IGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5LFxuICBjbGVhbkhleDogKCkgPT4gY2xlYW5IZXgsXG4gIGdldERlY2ltYWxTdHJpbmc6ICgpID0+IGdldERlY2ltYWxTdHJpbmcsXG4gIGdldEhleFN0cmluZzogKCkgPT4gZ2V0SGV4U3RyaW5nLFxuICBnZXRIZXhTdHJpbmdBcnJheTogKCkgPT4gZ2V0SGV4U3RyaW5nQXJyYXksXG4gIGhleFRvQnl0ZXM6ICgpID0+IGhleFRvQnl0ZXMsXG4gIGhleFRvRGVjaW1hbFN0cmluZzogKCkgPT4gaGV4VG9EZWNpbWFsU3RyaW5nLFxuICBpc0JpZ0ludDogKCkgPT4gaXNCaWdJbnQsXG4gIGlzSGV4OiAoKSA9PiBpc0hleCxcbiAgaXNTdHJpbmdXaG9sZU51bWJlcjogKCkgPT4gaXNTdHJpbmdXaG9sZU51bWJlcixcbiAgdG9CaWdJbnQ6ICgpID0+IHRvQmlnSW50LFxuICB0b0NhaXJvQm9vbDogKCkgPT4gdG9DYWlyb0Jvb2wsXG4gIHRvSGV4OiAoKSA9PiB0b0hleCxcbiAgdG9IZXhTdHJpbmc6ICgpID0+IHRvSGV4U3RyaW5nLFxuICB0b1N0b3JhZ2VLZXk6ICgpID0+IHRvU3RvcmFnZUtleVxufSk7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXNOb2JsZSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5mdW5jdGlvbiBpc0hleChoZXgpIHtcbiAgcmV0dXJuIC9eMHhbMC05YS1mXSokL2kudGVzdChoZXgpO1xufVxuZnVuY3Rpb24gdG9CaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0JpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiO1xufVxuZnVuY3Rpb24gdG9IZXgobnVtYmVyMikge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHRvQmlnSW50KG51bWJlcjIpLnRvU3RyaW5nKDE2KSk7XG59XG52YXIgdG9IZXhTdHJpbmcgPSB0b0hleDtcbmZ1bmN0aW9uIHRvU3RvcmFnZUtleShudW1iZXIyKSB7XG4gIGNvbnN0IHJlcyA9IGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBoZXhUb0RlY2ltYWxTdHJpbmcoaGV4KSB7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KGhleCkpLnRvU3RyaW5nKDEwKTtcbn1cbnZhciBjbGVhbkhleCA9IChoZXgpID0+IGhleC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL14oMHgpMCsvLCBcIiQxXCIpO1xuZnVuY3Rpb24gYXNzZXJ0SW5SYW5nZShpbnB1dCwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCwgaW5wdXROYW1lID0gXCJcIikge1xuICBjb25zdCBtZXNzYWdlU3VmZml4ID0gaW5wdXROYW1lID09PSBcIlwiID8gXCJpbnZhbGlkIGxlbmd0aFwiIDogYGludmFsaWQgJHtpbnB1dE5hbWV9IGxlbmd0aGA7XG4gIGNvbnN0IGlucHV0QmlnSW50ID0gQmlnSW50KGlucHV0KTtcbiAgY29uc3QgbG93ZXJCb3VuZEJpZ0ludCA9IEJpZ0ludChsb3dlckJvdW5kKTtcbiAgY29uc3QgdXBwZXJCb3VuZEJpZ0ludCA9IEJpZ0ludCh1cHBlckJvdW5kKTtcbiAgYXNzZXJ0KFxuICAgIGlucHV0QmlnSW50ID49IGxvd2VyQm91bmRCaWdJbnQgJiYgaW5wdXRCaWdJbnQgPD0gdXBwZXJCb3VuZEJpZ0ludCxcbiAgICBgTWVzc2FnZSBub3Qgc2lnbmFibGUsICR7bWVzc2FnZVN1ZmZpeH0uYFxuICApO1xufVxuZnVuY3Rpb24gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheShyYXdDYWxsZGF0YSkge1xuICByZXR1cm4gcmF3Q2FsbGRhdGEubWFwKCh4KSA9PiB0b0JpZ0ludCh4KS50b1N0cmluZygxMCkpO1xufVxuZnVuY3Rpb24gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkocmF3Q2FsbGRhdGEpIHtcbiAgcmV0dXJuIHJhd0NhbGxkYXRhLm1hcCgoeCkgPT4gdG9IZXgoeCkpO1xufVxudmFyIGlzU3RyaW5nV2hvbGVOdW1iZXIgPSAodmFsdWUpID0+IC9eXFxkKyQvLnRlc3QodmFsdWUpO1xuZnVuY3Rpb24gZ2V0RGVjaW1hbFN0cmluZyh2YWx1ZSkge1xuICBpZiAoaXNIZXgodmFsdWUpKSB7XG4gICAgcmV0dXJuIGhleFRvRGVjaW1hbFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHt2YWx1ZX0gbmVlZCB0byBiZSBoZXgtc3RyaW5nIG9yIHdob2xlLW51bWJlci1zdHJpbmdgKTtcbn1cbmZ1bmN0aW9uIGdldEhleFN0cmluZyh2YWx1ZSkge1xuICBpZiAoaXNIZXgodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB0b0hleFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke3ZhbHVlfSBuZWVkIHRvIGJlIGhleC1zdHJpbmcgb3Igd2hvbGUtbnVtYmVyLXN0cmluZ2ApO1xufVxuZnVuY3Rpb24gZ2V0SGV4U3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcCgoZWwpID0+IGdldEhleFN0cmluZyhlbCkpO1xufVxudmFyIHRvQ2Fpcm9Cb29sID0gKHZhbHVlKSA9PiAoK3ZhbHVlKS50b1N0cmluZygpO1xuZnVuY3Rpb24gaGV4VG9CeXRlcyh2YWx1ZSkge1xuICBpZiAoIWlzSGV4KHZhbHVlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dmFsdWV9IG5lZWQgdG8gYmUgYSBoZXgtc3RyaW5nYCk7XG4gIGxldCBhZGFwdGVkVmFsdWUgPSByZW1vdmVIZXhQcmVmaXgodmFsdWUpO1xuICBpZiAoYWRhcHRlZFZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICBhZGFwdGVkVmFsdWUgPSBgMCR7YWRhcHRlZFZhbHVlfWA7XG4gIH1cbiAgcmV0dXJuIGhleFRvQnl0ZXNOb2JsZShhZGFwdGVkVmFsdWUpO1xufVxuXG4vLyBzcmMvdXRpbHMvc2VsZWN0b3IudHNcbnZhciBzZWxlY3Rvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChzZWxlY3Rvcl9leHBvcnRzLCB7XG4gIGdldFNlbGVjdG9yOiAoKSA9PiBnZXRTZWxlY3RvcixcbiAgZ2V0U2VsZWN0b3JGcm9tTmFtZTogKCkgPT4gZ2V0U2VsZWN0b3JGcm9tTmFtZSxcbiAga2VjY2FrQm46ICgpID0+IGtlY2Nha0JuLFxuICBzdGFya25ldEtlY2NhazogKCkgPT4gc3RhcmtuZXRLZWNjYWtcbn0pO1xuaW1wb3J0IHsga2VjY2FrIH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuZnVuY3Rpb24ga2VjY2FrQm4odmFsdWUpIHtcbiAgY29uc3QgaGV4V2l0aG91dFByZWZpeCA9IHJlbW92ZUhleFByZWZpeCh0b0hleChCaWdJbnQodmFsdWUpKSk7XG4gIGNvbnN0IGV2ZW5IZXggPSBoZXhXaXRob3V0UHJlZml4Lmxlbmd0aCAlIDIgPT09IDAgPyBoZXhXaXRob3V0UHJlZml4IDogYDAke2hleFdpdGhvdXRQcmVmaXh9YDtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChrZWNjYWsoaGV4VG9CeXRlcyhhZGRIZXhQcmVmaXgoZXZlbkhleCkpKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24ga2VjY2FrSGV4KHN0cikge1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGtlY2Nhayh1dGY4VG9BcnJheShzdHIpKS50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gc3RhcmtuZXRLZWNjYWsoc3RyKSB7XG4gIGNvbnN0IGhhc2ggPSBCaWdJbnQoa2VjY2FrSGV4KHN0cikpO1xuICByZXR1cm4gaGFzaCAmIE1BU0tfMjUwO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3JGcm9tTmFtZShmdW5jTmFtZSkge1xuICByZXR1cm4gdG9IZXgoc3RhcmtuZXRLZWNjYWsoZnVuY05hbWUpKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKHZhbHVlKSB7XG4gIGlmIChpc0hleCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRvSGV4U3RyaW5nKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZ2V0U2VsZWN0b3JGcm9tTmFtZSh2YWx1ZSk7XG59XG5cbi8vIHNyYy91dGlscy9zaG9ydFN0cmluZy50c1xudmFyIHNob3J0U3RyaW5nX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNob3J0U3RyaW5nX2V4cG9ydHMsIHtcbiAgZGVjb2RlU2hvcnRTdHJpbmc6ICgpID0+IGRlY29kZVNob3J0U3RyaW5nLFxuICBlbmNvZGVTaG9ydFN0cmluZzogKCkgPT4gZW5jb2RlU2hvcnRTdHJpbmcsXG4gIGlzQVNDSUk6ICgpID0+IGlzQVNDSUksXG4gIGlzRGVjaW1hbFN0cmluZzogKCkgPT4gaXNEZWNpbWFsU3RyaW5nLFxuICBpc0xvbmdUZXh0OiAoKSA9PiBpc0xvbmdUZXh0LFxuICBpc1Nob3J0U3RyaW5nOiAoKSA9PiBpc1Nob3J0U3RyaW5nLFxuICBpc1Nob3J0VGV4dDogKCkgPT4gaXNTaG9ydFRleHQsXG4gIGlzVGV4dDogKCkgPT4gaXNUZXh0LFxuICBzcGxpdExvbmdTdHJpbmc6ICgpID0+IHNwbGl0TG9uZ1N0cmluZ1xufSk7XG5mdW5jdGlvbiBpc0FTQ0lJKHN0cikge1xuICByZXR1cm4gL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzU2hvcnRTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIubGVuZ3RoIDw9IFRFWFRfVE9fRkVMVF9NQVhfTEVOO1xufVxuZnVuY3Rpb24gaXNEZWNpbWFsU3RyaW5nKHN0cikge1xuICByZXR1cm4gL15bMC05XSokL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNUZXh0KHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiAmJiAhaXNIZXgodmFsKSAmJiAhaXNTdHJpbmdXaG9sZU51bWJlcih2YWwpO1xufVxudmFyIGlzU2hvcnRUZXh0ID0gKHZhbCkgPT4gaXNUZXh0KHZhbCkgJiYgaXNTaG9ydFN0cmluZyh2YWwpO1xudmFyIGlzTG9uZ1RleHQgPSAodmFsKSA9PiBpc1RleHQodmFsKSAmJiAhaXNTaG9ydFN0cmluZyh2YWwpO1xuZnVuY3Rpb24gc3BsaXRMb25nU3RyaW5nKGxvbmdTdHIpIHtcbiAgY29uc3QgcmVnZXggPSBSZWdFeHAoYFteXXsxLCR7VEVYVF9UT19GRUxUX01BWF9MRU59fWAsIFwiZ1wiKTtcbiAgcmV0dXJuIGxvbmdTdHIubWF0Y2gocmVnZXgpIHx8IFtdO1xufVxuZnVuY3Rpb24gZW5jb2RlU2hvcnRTdHJpbmcoc3RyKSB7XG4gIGlmICghaXNBU0NJSShzdHIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBhbiBBU0NJSSBzdHJpbmdgKTtcbiAgaWYgKCFpc1Nob3J0U3RyaW5nKHN0cikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgdG9vIGxvbmdgKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChzdHIucmVwbGFjZSgvLi9nLCAoY2hhcikgPT4gY2hhci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkpO1xufVxuZnVuY3Rpb24gZGVjb2RlU2hvcnRTdHJpbmcoc3RyKSB7XG4gIGlmICghaXNBU0NJSShzdHIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBhbiBBU0NJSSBzdHJpbmdgKTtcbiAgaWYgKGlzSGV4KHN0cikpIHtcbiAgICByZXR1cm4gcmVtb3ZlSGV4UHJlZml4KHN0cikucmVwbGFjZSgvLnsyfS9nLCAoaGV4KSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKSk7XG4gIH1cbiAgaWYgKGlzRGVjaW1hbFN0cmluZyhzdHIpKSB7XG4gICAgcmV0dXJuIGRlY29kZVNob3J0U3RyaW5nKFwiMFhcIi5jb25jYXQoQmlnSW50KHN0cikudG9TdHJpbmcoMTYpKSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IEhleCBvciBkZWNpbWFsYCk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9jYWlyby50c1xudmFyIGNhaXJvX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNhaXJvX2V4cG9ydHMsIHtcbiAgZmVsdDogKCkgPT4gZmVsdCxcbiAgZ2V0QWJpQ29udHJhY3RWZXJzaW9uOiAoKSA9PiBnZXRBYmlDb250cmFjdFZlcnNpb24sXG4gIGdldEFycmF5VHlwZTogKCkgPT4gZ2V0QXJyYXlUeXBlLFxuICBpc0NhaXJvMUFiaTogKCkgPT4gaXNDYWlybzFBYmksXG4gIGlzQ2Fpcm8xVHlwZTogKCkgPT4gaXNDYWlybzFUeXBlLFxuICBpc0xlbjogKCkgPT4gaXNMZW4sXG4gIGlzVHlwZUFycmF5OiAoKSA9PiBpc1R5cGVBcnJheSxcbiAgaXNUeXBlQm9vbDogKCkgPT4gaXNUeXBlQm9vbCxcbiAgaXNUeXBlQ29udHJhY3RBZGRyZXNzOiAoKSA9PiBpc1R5cGVDb250cmFjdEFkZHJlc3MsXG4gIGlzVHlwZUVudW06ICgpID0+IGlzVHlwZUVudW0sXG4gIGlzVHlwZUV0aEFkZHJlc3M6ICgpID0+IGlzVHlwZUV0aEFkZHJlc3MsXG4gIGlzVHlwZUZlbHQ6ICgpID0+IGlzVHlwZUZlbHQsXG4gIGlzVHlwZUxpdHRlcmFsOiAoKSA9PiBpc1R5cGVMaXR0ZXJhbCxcbiAgaXNUeXBlTmFtZWRUdXBsZTogKCkgPT4gaXNUeXBlTmFtZWRUdXBsZSxcbiAgaXNUeXBlT3B0aW9uOiAoKSA9PiBpc1R5cGVPcHRpb24sXG4gIGlzVHlwZVJlc3VsdDogKCkgPT4gaXNUeXBlUmVzdWx0LFxuICBpc1R5cGVTdHJ1Y3Q6ICgpID0+IGlzVHlwZVN0cnVjdCxcbiAgaXNUeXBlVHVwbGU6ICgpID0+IGlzVHlwZVR1cGxlLFxuICBpc1R5cGVVaW50OiAoKSA9PiBpc1R5cGVVaW50LFxuICBpc1R5cGVVaW50MjU2OiAoKSA9PiBpc1R5cGVVaW50MjU2LFxuICB0dXBsZTogKCkgPT4gdHVwbGUsXG4gIHVpbnQyNTY6ICgpID0+IHVpbnQyNTZcbn0pO1xuXG4vLyBzcmMvdXRpbHMvdWludDI1Ni50c1xudmFyIHVpbnQyNTZfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodWludDI1Nl9leHBvcnRzLCB7XG4gIFVJTlRfMTI4X01BWDogKCkgPT4gVUlOVF8xMjhfTUFYLFxuICBVSU5UXzI1Nl9NQVg6ICgpID0+IFVJTlRfMjU2X01BWCxcbiAgYm5Ub1VpbnQyNTY6ICgpID0+IGJuVG9VaW50MjU2LFxuICBpc1VpbnQyNTY6ICgpID0+IGlzVWludDI1NixcbiAgdWludDI1NlRvQk46ICgpID0+IHVpbnQyNTZUb0JOXG59KTtcbnZhciBVSU5UXzEyOF9NQVggPSAoMW4gPDwgMTI4bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NQVggPSAoMW4gPDwgMjU2bikgLSAxbjtcbmZ1bmN0aW9uIHVpbnQyNTZUb0JOKHVpbnQyNTYyKSB7XG4gIHJldHVybiAodG9CaWdJbnQodWludDI1NjIuaGlnaCkgPDwgMTI4bikgKyB0b0JpZ0ludCh1aW50MjU2Mi5sb3cpO1xufVxuZnVuY3Rpb24gaXNVaW50MjU2KGJuKSB7XG4gIHJldHVybiB0b0JpZ0ludChibikgPD0gVUlOVF8yNTZfTUFYO1xufVxuZnVuY3Rpb24gYm5Ub1VpbnQyNTYoYm4pIHtcbiAgY29uc3QgYmkgPSB0b0JpZ0ludChibik7XG4gIGlmICghaXNVaW50MjU2KGJpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgaXMgdG9vIGxhcmdlXCIpO1xuICByZXR1cm4ge1xuICAgIGxvdzogYWRkSGV4UHJlZml4KChiaSAmIFVJTlRfMTI4X01BWCkudG9TdHJpbmcoMTYpKSxcbiAgICBoaWdoOiBhZGRIZXhQcmVmaXgoKGJpID4+IDEyOG4pLnRvU3RyaW5nKDE2KSlcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgaXNMZW4gPSAobmFtZSkgPT4gL19sZW4kLy50ZXN0KG5hbWUpO1xudmFyIGlzVHlwZUZlbHQgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJmZWx0XCIgfHwgdHlwZSA9PT0gXCJjb3JlOjpmZWx0MjUyXCI7XG52YXIgaXNUeXBlQXJyYXkgPSAodHlwZSkgPT4gL1xcKi8udGVzdCh0eXBlKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OlwiKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6U3Bhbjo6XCIpO1xudmFyIGlzVHlwZVR1cGxlID0gKHR5cGUpID0+IC9eXFwoLipcXCkkL2kudGVzdCh0eXBlKTtcbnZhciBpc1R5cGVOYW1lZFR1cGxlID0gKHR5cGUpID0+IC9cXCguKlxcKS9pLnRlc3QodHlwZSkgJiYgdHlwZS5pbmNsdWRlcyhcIjpcIik7XG52YXIgaXNUeXBlU3RydWN0ID0gKHR5cGUsIHN0cnVjdHMpID0+IHR5cGUgaW4gc3RydWN0cztcbnZhciBpc1R5cGVFbnVtID0gKHR5cGUsIGVudW1zKSA9PiB0eXBlIGluIGVudW1zO1xudmFyIGlzVHlwZU9wdGlvbiA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpvcHRpb246Ok9wdGlvbjo6XCIpO1xudmFyIGlzVHlwZVJlc3VsdCA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6XCIpO1xudmFyIGlzVHlwZVVpbnQgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhVaW50KS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVMaXR0ZXJhbCA9ICh0eXBlKSA9PiBPYmplY3QudmFsdWVzKExpdHRlcmFsKS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVVaW50MjU2ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiO1xudmFyIGlzVHlwZUJvb2wgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpib29sXCI7XG52YXIgaXNUeXBlQ29udHJhY3RBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xudmFyIGlzVHlwZUV0aEFkZHJlc3MgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjtcbnZhciBpc0NhaXJvMVR5cGUgPSAodHlwZSkgPT4gdHlwZS5pbmNsdWRlcyhcIjo6XCIpO1xudmFyIGdldEFycmF5VHlwZSA9ICh0eXBlKSA9PiB7XG4gIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZS5zdWJzdHJpbmcodHlwZS5pbmRleE9mKFwiPFwiKSArIDEsIHR5cGUubGFzdEluZGV4T2YoXCI+XCIpKTtcbiAgfVxuICByZXR1cm4gdHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKTtcbn07XG5mdW5jdGlvbiBpc0NhaXJvMUFiaShhYmkpIHtcbiAgY29uc3QgeyBjYWlybyB9ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGFiaSk7XG4gIGlmIChjYWlybyA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZGV0ZXJtaW5lIENhaXJvIHZlcnNpb25cIik7XG4gIH1cbiAgcmV0dXJuIGNhaXJvID09PSBcIjFcIjtcbn1cbmZ1bmN0aW9uIGdldEFiaUNvbnRyYWN0VmVyc2lvbihhYmkpIHtcbiAgaWYgKGFiaS5maW5kKChpdCkgPT4gaXQudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikpIHtcbiAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBcIjJcIiB9O1xuICB9XG4gIGNvbnN0IHRlc3RGdW5jdGlvbiA9IGFiaS5maW5kKFxuICAgIChpdCkgPT4gaXQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIChpdC5pbnB1dHMubGVuZ3RoIHx8IGl0Lm91dHB1dHMubGVuZ3RoKVxuICApO1xuICBpZiAoIXRlc3RGdW5jdGlvbikge1xuICAgIHJldHVybiB7IGNhaXJvOiB2b2lkIDAsIGNvbXBpbGVyOiB2b2lkIDAgfTtcbiAgfVxuICBjb25zdCBpbyA9IHRlc3RGdW5jdGlvbi5pbnB1dHMubGVuZ3RoID8gdGVzdEZ1bmN0aW9uLmlucHV0cyA6IHRlc3RGdW5jdGlvbi5vdXRwdXRzO1xuICBpZiAoaXNDYWlybzFUeXBlKGlvWzBdLnR5cGUpKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogXCIxXCIgfTtcbiAgfVxuICByZXR1cm4geyBjYWlybzogXCIwXCIsIGNvbXBpbGVyOiBcIjBcIiB9O1xufVxudmFyIHVpbnQyNTYgPSAoaXQpID0+IHtcbiAgY29uc3QgYm4gPSBCaWdJbnQoaXQpO1xuICBpZiAoIWlzVWludDI1NihibikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIGlzIHRvbyBsYXJnZVwiKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGxvdzogKGJuICYgVUlOVF8xMjhfTUFYKS50b1N0cmluZygxMCksXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBoaWdoOiAoYm4gPj4gMTI4bikudG9TdHJpbmcoMTApXG4gIH07XG59O1xudmFyIHR1cGxlID0gKC4uLmFyZ3MpID0+ICh7IC4uLmFyZ3MgfSk7XG5mdW5jdGlvbiBmZWx0KGl0KSB7XG4gIGlmIChpc0JpZ0ludChpdCkgfHwgdHlwZW9mIGl0ID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0ludGVnZXIoaXQpKSB7XG4gICAgcmV0dXJuIGl0LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKGlzVGV4dChpdCkpIHtcbiAgICBpZiAoIWlzU2hvcnRTdHJpbmcoaXQpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtpdH0gaXMgYSBsb25nIHN0cmluZyA+IDMxIGNoYXJzLCBmZWx0IGNhbiBzdG9yZSBzaG9ydCBzdHJpbmdzLCBzcGxpdCBpdCB0byBhcnJheSBvZiBzaG9ydCBzdHJpbmdzYFxuICAgICAgKTtcbiAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlU2hvcnRTdHJpbmcoaXQpO1xuICAgIHJldHVybiBCaWdJbnQoZW5jb2RlZCkudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodHlwZW9mIGl0ID09PSBcInN0cmluZ1wiICYmIGlzSGV4KGl0KSkge1xuICAgIHJldHVybiBCaWdJbnQoaXQpLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpdCA9PT0gXCJzdHJpbmdcIiAmJiBpc1N0cmluZ1dob2xlTnVtYmVyKGl0KSkge1xuICAgIHJldHVybiBpdDtcbiAgfVxuICBpZiAodHlwZW9mIGl0ID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBgJHsraXR9YDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7aXR9IGNhbid0IGJlIGNvbXB1dGVkIGJ5IGZlbHQoKWApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZW51bS9DYWlyb0N1c3RvbUVudW0udHNcbnZhciBDYWlyb0N1c3RvbUVudW0gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0gZW51bUNvbnRlbnQgYW4gb2JqZWN0IHdpdGggdGhlIHZhcmlhbnRzIGFzIGtleXMgYW5kIHRoZSBjb250ZW50IGFzIHZhbHVlLiBPbmx5IG9uZSBjb250ZW50IHNoYWxsIGJlIGRlZmluZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnVtQ29udGVudCkge1xuICAgIGNvbnN0IHZhcmlhbnRzTGlzdCA9IE9iamVjdC52YWx1ZXMoZW51bUNvbnRlbnQpO1xuICAgIGlmICh2YXJpYW50c0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGEgbGVhc3QgMSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuYkFjdGl2ZVZhcmlhbnRzID0gdmFyaWFudHNMaXN0LmZpbHRlcihcbiAgICAgIChjb250ZW50KSA9PiB0eXBlb2YgY29udGVudCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICkubGVuZ3RoO1xuICAgIGlmIChuYkFjdGl2ZVZhcmlhbnRzICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFjdGl2ZSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnZhcmlhbnQgPSBlbnVtQ29udGVudDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVWYXJpYW50WzFdO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKi9cbiAgYWN0aXZlVmFyaWFudCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVmFyaWFudFswXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9PcHRpb24udHNcbnZhciBDYWlyb09wdGlvblZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb09wdGlvblZhcmlhbnQyKSA9PiB7XG4gIENhaXJvT3B0aW9uVmFyaWFudDJbQ2Fpcm9PcHRpb25WYXJpYW50MltcIlNvbWVcIl0gPSAwXSA9IFwiU29tZVwiO1xuICBDYWlyb09wdGlvblZhcmlhbnQyW0NhaXJvT3B0aW9uVmFyaWFudDJbXCJOb25lXCJdID0gMV0gPSBcIk5vbmVcIjtcbiAgcmV0dXJuIENhaXJvT3B0aW9uVmFyaWFudDI7XG59KShDYWlyb09wdGlvblZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvT3B0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCBzb21lQ29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gQ2Fpcm9PcHRpb25WYXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCA6IHNob3VsZCBiZSBDYWlyb09wdGlvblZhcmlhbnQuU29tZSBvciAuTm9uZS5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSAwIC8qIFNvbWUgKi8pIHtcbiAgICAgIGlmICh0eXBlb2Ygc29tZUNvbnRlbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgY3JlYXRpb24gb2YgYSBDYWlybyBPcHRpb24gd2l0aCBcIlNvbWVcIiB2YXJpYW50IG5lZWRzIGEgY29udGVudCBhcyBpbnB1dC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLlNvbWUgPSBzb21lQ29udGVudDtcbiAgICAgIHRoaXMuTm9uZSA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5Tb21lID0gdm9pZCAwO1xuICAgICAgdGhpcy5Ob25lID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqICBJZiBOb25lLCByZXR1cm5zICd1bmRlZmluZWQnLlxuICAgKi9cbiAgdW53cmFwKCkge1xuICAgIGlmICh0aGlzLk5vbmUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLlNvbWU7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzU29tZScuXG4gICAqL1xuICBpc1NvbWUoKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuU29tZSA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzTm9uZScuXG4gICAqL1xuICBpc05vbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuTm9uZSA9PT0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9SZXN1bHQudHNcbnZhciBDYWlyb1Jlc3VsdFZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb1Jlc3VsdFZhcmlhbnQyKSA9PiB7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIk9rXCJdID0gMF0gPSBcIk9rXCI7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIkVyclwiXSA9IDFdID0gXCJFcnJcIjtcbiAgcmV0dXJuIENhaXJvUmVzdWx0VmFyaWFudDI7XG59KShDYWlyb1Jlc3VsdFZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCByZXN1bHRDb250ZW50KSB7XG4gICAgaWYgKCEodmFyaWFudCBpbiBDYWlyb1Jlc3VsdFZhcmlhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyB2YXJpYW50IDogc2hvdWxkIGJlIENhaXJvUmVzdWx0VmFyaWFudC5PayBvciAuRXJyLlwiKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09IDAgLyogT2sgKi8pIHtcbiAgICAgIHRoaXMuT2sgPSByZXN1bHRDb250ZW50O1xuICAgICAgdGhpcy5FcnIgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuT2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLkVyciA9IHJlc3VsdENvbnRlbnQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIFJlc3VsdC5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuT2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLk9rO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuRXJyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5FcnI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggUmVzdWx0Lk9rIGFuZCAuRXJyIGFyZSB1bmRlZmluZWQuIE5vdCBhdXRob3JpemVkLlwiKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsaWQgdmFyaWFudCBpcyAnT2snLlxuICAgKi9cbiAgaXNPaygpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5PayA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzRXJyJy5cbiAgICovXG4gIGlzRXJyKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLkVyciA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9mb3JtYXR0ZXIudHNcbnZhciBndWFyZCA9IHtcbiAgaXNCTjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIGlmICghaXNCaWdJbnQoZGF0YVtrZXldKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYERhdGEgYW5kIGZvcm1hdHRlciBtaXNtYXRjaCBvbiAke2tleX06JHt0eXBlW2tleV19LCBleHBlY3RlZCByZXNwb25zZSBkYXRhICR7a2V5fToke2RhdGFba2V5XX0gdG8gYmUgQk4gaW5zdGVhZCBpdCBpcyAke3R5cGVvZiBkYXRhW2tleV19YFxuICAgICAgKTtcbiAgfSxcbiAgdW5rbm93bjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGZvcm1hdHRlciB0eXBlIG9uICR7a2V5fToke3R5cGVba2V5XX0gZm9yIGRhdGEgJHtrZXl9OiR7ZGF0YVtrZXldfWApO1xuICB9XG59O1xuZnVuY3Rpb24gZm9ybWF0dGVyKGRhdGEsIHR5cGUsIHNhbWVUeXBlKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgZWxUeXBlID0gc2FtZVR5cGUgPz8gdHlwZVtrZXldO1xuICAgIGlmICghKGtleSBpbiB0eXBlKSAmJiAhc2FtZVR5cGUpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBpZiAoZWxUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pKSB7XG4gICAgICAgIGNvbnN0IGFycmF5U3RyID0gZm9ybWF0dGVyKFxuICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICBkYXRhW2tleV0ubWFwKChfKSA9PiBlbFR5cGUpXG4gICAgICAgICk7XG4gICAgICAgIGFjY1trZXldID0gT2JqZWN0LnZhbHVlcyhhcnJheVN0cikuam9pbihcIlwiKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGd1YXJkLmlzQk4oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgIGFjY1trZXldID0gZGVjb2RlU2hvcnRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKGVsVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZ3VhcmQuaXNCTihkYXRhLCB0eXBlLCBrZXkpO1xuICAgICAgYWNjW2tleV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYWNjW2tleV0gPSBlbFR5cGUodmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxUeXBlKSkge1xuICAgICAgY29uc3QgYXJyYXlPYmogPSBmb3JtYXR0ZXIoZGF0YVtrZXldLCBlbFR5cGUsIGVsVHlwZVswXSk7XG4gICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlPYmopO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGFjY1trZXldID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGd1YXJkLnVua25vd24oZGF0YSwgdHlwZSwga2V5KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTAtMS4xLjAudHNcbnZhciBBYmlQYXJzZXIxID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoIHdpdGhvdXQgJ19sZW4nIGlucHV0c1xuICAgKiBjYWlybyAwIHJlZHVjZXJcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoKGFjYywgaW5wdXQpID0+ICFpc0xlbihpbnB1dC5uYW1lKSA/IGFjYyArIDEgOiBhY2MsIDApO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFiaS5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTIuMC4wLnRzXG52YXIgQWJpUGFyc2VyMiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG4gIH1cbiAgLyoqXG4gICAqIGFiaSBtZXRob2QgaW5wdXRzIGxlbmd0aFxuICAgKiBAcGFyYW0gYWJpTWV0aG9kIEZ1bmN0aW9uQWJpXG4gICAqIEByZXR1cm5zIG51bWJlclxuICAgKi9cbiAgbWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCkge1xuICAgIHJldHVybiBhYmlNZXRob2QuaW5wdXRzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogZ2V0IG1ldGhvZCBkZWZpbml0aW9uIGZyb20gYWJpXG4gICAqIEBwYXJhbSBuYW1lIHN0cmluZ1xuICAgKiBAcmV0dXJucyBGdW5jdGlvbkFiaSB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0TWV0aG9kKG5hbWUpIHtcbiAgICBjb25zdCBpbnRmID0gdGhpcy5hYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpO1xuICAgIHJldHVybiBpbnRmLml0ZW1zLmZpbmQoKGl0KSA9PiBpdC5uYW1lID09PSBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IEFiaSBpbiBsZWdhY3kgZm9ybWF0XG4gICAqIEByZXR1cm5zIEFiaVxuICAgKi9cbiAgZ2V0TGVnYWN5Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmFiaS5mbGF0TWFwKChlKSA9PiB7XG4gICAgICBpZiAoZS50eXBlID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgIHJldHVybiBlLml0ZW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvaW5kZXgudHNcbmZ1bmN0aW9uIGNyZWF0ZUFiaVBhcnNlcihhYmkpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGdldEFiaVZlcnNpb24oYWJpKTtcbiAgaWYgKHZlcnNpb24gPT09IDAgfHwgdmVyc2lvbiA9PT0gMSkge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMShhYmkpO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAyKSB7XG4gICAgcmV0dXJuIG5ldyBBYmlQYXJzZXIyKGFiaSk7XG4gIH1cbiAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIEFCSSB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbn1cbmZ1bmN0aW9uIGdldEFiaVZlcnNpb24oYWJpKSB7XG4gIGlmIChhYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpKVxuICAgIHJldHVybiAyO1xuICBpZiAoaXNDYWlybzFBYmkoYWJpKSlcbiAgICByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3NDYWxsZGF0YSwgYWJpTWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgPT09IFwiY29uc3RydWN0b3JcIiAmJiAhYWJpTWV0aG9kICYmICFhcmdzQ2FsbGRhdGEubGVuZ3RoO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvdHVwbGUudHNcbmZ1bmN0aW9uIHBhcnNlTmFtZWRUdXBsZShuYW1lZFR1cGxlKSB7XG4gIGNvbnN0IG5hbWUgPSBuYW1lZFR1cGxlLnN1YnN0cmluZygwLCBuYW1lZFR1cGxlLmluZGV4T2YoXCI6XCIpKTtcbiAgY29uc3QgdHlwZSA9IG5hbWVkVHVwbGUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoICsgXCI6XCIubGVuZ3RoKTtcbiAgcmV0dXJuIHsgbmFtZSwgdHlwZSB9O1xufVxuZnVuY3Rpb24gcGFyc2VTdWJUdXBsZShzKSB7XG4gIGlmICghcy5pbmNsdWRlcyhcIihcIikpXG4gICAgcmV0dXJuIHsgc3ViVHVwbGU6IFtdLCByZXN1bHQ6IHMgfTtcbiAgY29uc3Qgc3ViVHVwbGUgPSBbXTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBzLmxlbmd0aCkge1xuICAgIGlmIChzW2ldID09PSBcIihcIikge1xuICAgICAgbGV0IGNvdW50ZXIgPSAxO1xuICAgICAgY29uc3QgbEJyYWNrZXQgPSBpO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGNvdW50ZXIpIHtcbiAgICAgICAgaWYgKHNbaV0gPT09IFwiKVwiKVxuICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgaWYgKHNbaV0gPT09IFwiKFwiKVxuICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgc3ViVHVwbGUucHVzaChzLnN1YnN0cmluZyhsQnJhY2tldCwgaSkpO1xuICAgICAgcmVzdWx0ICs9IFwiIFwiO1xuICAgICAgaS0tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gc1tpXTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3ViVHVwbGUsXG4gICAgcmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiBleHRyYWN0Q2Fpcm8wVHVwbGUodHlwZSkge1xuICBjb25zdCBjbGVhblR5cGUgPSB0eXBlLnJlcGxhY2UoL1xccy9nLCBcIlwiKS5zbGljZSgxLCAtMSk7XG4gIGNvbnN0IHsgc3ViVHVwbGUsIHJlc3VsdCB9ID0gcGFyc2VTdWJUdXBsZShjbGVhblR5cGUpO1xuICBsZXQgcmVjb21wb3NlZCA9IHJlc3VsdC5zcGxpdChcIixcIikubWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBzdWJUdXBsZS5sZW5ndGggPyBpdC5yZXBsYWNlKFwiIFwiLCBzdWJUdXBsZS5zaGlmdCgpKSA6IGl0O1xuICB9KTtcbiAgaWYgKGlzVHlwZU5hbWVkVHVwbGUodHlwZSkpIHtcbiAgICByZWNvbXBvc2VkID0gcmVjb21wb3NlZC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlTmFtZWRUdXBsZShpdCkpO1xuICAgIH0sIFtdKTtcbiAgfVxuICByZXR1cm4gcmVjb21wb3NlZDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDYWlybzFUdXBsZSh0eXBlKSB7XG4gIGNvbnN0IGNsZWFuVHlwZSA9IHR5cGUucmVwbGFjZSgvXFxzL2csIFwiXCIpLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgeyBzdWJUdXBsZSwgcmVzdWx0IH0gPSBwYXJzZVN1YlR1cGxlKGNsZWFuVHlwZSk7XG4gIGNvbnN0IHJlY29tcG9zZWQgPSByZXN1bHQuc3BsaXQoXCIsXCIpLm1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gc3ViVHVwbGUubGVuZ3RoID8gaXQucmVwbGFjZShcIiBcIiwgc3ViVHVwbGUuc2hpZnQoKSkgOiBpdDtcbiAgfSk7XG4gIHJldHVybiByZWNvbXBvc2VkO1xufVxuZnVuY3Rpb24gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXModHlwZSkge1xuICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RDYWlybzFUdXBsZSh0eXBlKTtcbiAgfVxuICByZXR1cm4gZXh0cmFjdENhaXJvMFR1cGxlKHR5cGUpO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcHJvcGVydHlPcmRlci50c1xuZnVuY3Rpb24gZXJyb3JVMjU2KGtleSkge1xuICByZXR1cm4gRXJyb3IoXG4gICAgYFlvdXIgb2JqZWN0IGluY2x1ZGVzIHRoZSBwcm9wZXJ0eSA6ICR7a2V5fSwgY29udGFpbmluZyBhbiBVaW50MjU2IG9iamVjdCB3aXRob3V0IHRoZSAnbG93JyBhbmQgJ2hpZ2gnIGtleXMuYFxuICApO1xufVxuZnVuY3Rpb24gb3JkZXJQcm9wc0J5QWJpKHVub3JkZXJlZE9iamVjdCwgYWJpT2ZPYmplY3QsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGNvbnN0IG9yZGVySW5wdXQgPSAodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSkgPT4ge1xuICAgIGlmIChpc1R5cGVBcnJheShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyQXJyYXkodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFbnVtKGFiaVR5cGUsIGVudW1zKSkge1xuICAgICAgY29uc3QgYWJpT2JqID0gZW51bXNbYWJpVHlwZV07XG4gICAgICByZXR1cm4gb3JkZXJFbnVtKHVub3JkZXJlZEl0ZW0sIGFiaU9iaik7XG4gICAgfVxuICAgIGlmIChpc1R5cGVUdXBsZShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyVHVwbGUodW5vcmRlcmVkSXRlbSwgYWJpVHlwZSk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVFdGhBZGRyZXNzKGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVVpbnQyNTYoYWJpVHlwZSkpIHtcbiAgICAgIGNvbnN0IHUyNTYgPSB1bm9yZGVyZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiB1MjU2ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB1MjU2O1xuICAgICAgfVxuICAgICAgaWYgKCEoXCJsb3dcIiBpbiB1MjU2ICYmIFwiaGlnaFwiIGluIHUyNTYpKSB7XG4gICAgICAgIHRocm93IGVycm9yVTI1NihhYmlUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGxvdzogdTI1Ni5sb3csIGhpZ2g6IHUyNTYuaGlnaCB9O1xuICAgIH1cbiAgICBpZiAoaXNUeXBlU3RydWN0KGFiaVR5cGUsIHN0cnVjdHMpKSB7XG4gICAgICBjb25zdCBhYmlPZlN0cnVjdCA9IHN0cnVjdHNbYWJpVHlwZV0ubWVtYmVycztcbiAgICAgIHJldHVybiBvcmRlclN0cnVjdCh1bm9yZGVyZWRJdGVtLCBhYmlPZlN0cnVjdCk7XG4gICAgfVxuICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICB9O1xuICBjb25zdCBvcmRlclN0cnVjdCA9ICh1bm9yZGVyZWRPYmplY3QyLCBhYmlPYmplY3QpID0+IHtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IGFiaU9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtLm5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlID8/IHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV1cbiAgICAgIH0pO1xuICAgICAgaWYgKHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKGlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSB8fCAhaXNMZW4oYWJpUGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgWW91ciBvYmplY3QgbmVlZHMgYSBwcm9wZXJ0eSB3aXRoIGtleSA6ICR7YWJpUGFyYW0ubmFtZX0gLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDJbYWJpUGFyYW0ubmFtZV0sIGFiaVBhcmFtLnR5cGUpKTtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDI7XG4gIH07XG4gIGZ1bmN0aW9uIG9yZGVyQXJyYXkobXlBcnJheSwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlSW5BcnJheSA9IGdldEFycmF5VHlwZShhYmlQYXJhbSk7XG4gICAgaWYgKHR5cGVvZiBteUFycmF5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbXlBcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIG15QXJyYXkubWFwKChteUVsZW0pID0+IG9yZGVySW5wdXQobXlFbGVtLCB0eXBlSW5BcnJheSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9yZGVyVHVwbGUodW5vcmRlcmVkT2JqZWN0MiwgYWJpUGFyYW0pIHtcbiAgICBjb25zdCB0eXBlTGlzdCA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKGFiaVBhcmFtKTtcbiAgICBjb25zdCBvcmRlcmVkT2JqZWN0MiA9IHR5cGVMaXN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpVHlwZUNhaXJvWCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IG15T2JqS2V5cyA9IE9iamVjdC5rZXlzKHVub3JkZXJlZE9iamVjdDIpO1xuICAgICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBpbmRleC50b1N0cmluZygpLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB1bm9yZGVyZWRPYmplY3QyW215T2JqS2V5c1tpbmRleF1dXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFiaVR5cGUgPSBhYmlUeXBlQ2Fpcm9YPy50eXBlID8gYWJpVHlwZUNhaXJvWC50eXBlIDogYWJpVHlwZUNhaXJvWDtcbiAgICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0MltteU9iaktleXNbaW5kZXhdXSwgYWJpVHlwZSkpO1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0MjtcbiAgfVxuICBjb25zdCBvcmRlckVudW0gPSAodW5vcmRlcmVkT2JqZWN0MiwgYWJpT2JqZWN0KSA9PiB7XG4gICAgaWYgKGlzVHlwZVJlc3VsdChhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZFJlc3VsdCA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRPa1R5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCIsXCIpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzdWx0RXJyVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIixcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkUmVzdWx0LmlzT2soKSkge1xuICAgICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAgIDAgLyogT2sgKi8sXG4gICAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRPa1R5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KFxuICAgICAgICAxIC8qIEVyciAqLyxcbiAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyLnVud3JhcCgpLCByZXN1bHRFcnJUeXBlKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZU9wdGlvbihhYmlPYmplY3QubmFtZSkpIHtcbiAgICAgIGNvbnN0IHVub3JkZXJlZE9wdGlvbiA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgICBjb25zdCByZXN1bHRTb21lVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodW5vcmRlcmVkT3B0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oXG4gICAgICAgICAgMCAvKiBTb21lICovLFxuICAgICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT3B0aW9uLnVud3JhcCgpLCByZXN1bHRTb21lVHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24oMSAvKiBOb25lICovLCB7fSk7XG4gICAgfVxuICAgIGNvbnN0IHVub3JkZXJlZEN1c3RvbUVudW0gPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgIGNvbnN0IHZhcmlhbnRzID0gT2JqZWN0LmVudHJpZXModW5vcmRlcmVkQ3VzdG9tRW51bS52YXJpYW50KTtcbiAgICBjb25zdCBuZXdFbnRyaWVzID0gdmFyaWFudHMubWFwKCh2YXJpYW50KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhcmlhbnRbMV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCB2YXJpYW50VHlwZSA9IGFiaU9iamVjdC50eXBlLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0LnR5cGUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHZhcmlhbnRUeXBlID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3ZhcmlhbnRbMF0sIG9yZGVySW5wdXQodW5vcmRlcmVkQ3VzdG9tRW51bS51bndyYXAoKSwgdmFyaWFudFR5cGUpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bShPYmplY3QuZnJvbUVudHJpZXMobmV3RW50cmllcykpO1xuICB9O1xuICBjb25zdCBmaW5hbE9yZGVyZWRPYmplY3QgPSBhYmlPZk9iamVjdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtKSA9PiB7XG4gICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbS5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoaXNMZW4oYWJpUGFyYW0ubmFtZSkgJiYgIWlzQ2Fpcm8xVHlwZShhYmlQYXJhbS50eXBlKSkge1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfVxuICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0W2FiaVBhcmFtLm5hbWVdLCBhYmlQYXJhbS50eXBlKSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGZpbmFsT3JkZXJlZE9iamVjdDtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3JlcXVlc3RQYXJzZXIudHNcbmZ1bmN0aW9uIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbCkge1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZVVpbnQyNTYodHlwZSk6XG4gICAgICBjb25zdCBlbF91aW50MjU2ID0gdWludDI1Nih2YWwpO1xuICAgICAgcmV0dXJuIFtmZWx0KGVsX3VpbnQyNTYubG93KSwgZmVsdChlbF91aW50MjU2LmhpZ2gpXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZlbHQodmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUdXBsZShlbGVtZW50LCB0eXBlU3RyKSB7XG4gIGNvbnN0IG1lbWJlclR5cGVzID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXModHlwZVN0cik7XG4gIGNvbnN0IGVsZW1lbnRzID0gT2JqZWN0LnZhbHVlcyhlbGVtZW50KTtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gbWVtYmVyVHlwZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgUGFyc2VUdXBsZTogcHJvdmlkZWQgYW5kIGV4cGVjdGVkIGFiaSB0dXBsZSBzaXplIGRvIG5vdCBtYXRjaC5cbiAgICAgIHByb3ZpZGVkOiAke2VsZW1lbnRzfSBcbiAgICAgIGV4cGVjdGVkOiAke21lbWJlclR5cGVzfWBcbiAgICApO1xuICB9XG4gIHJldHVybiBtZW1iZXJUeXBlcy5tYXAoKGl0LCBkeCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50c1tkeF0sXG4gICAgICB0eXBlOiBpdC50eXBlID8/IGl0XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVVpbnQyNTYoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCB7IGxvdywgaGlnaCB9ID0gZWxlbWVudDtcbiAgICByZXR1cm4gW2ZlbHQobG93KSwgZmVsdChoaWdoKV07XG4gIH1cbiAgY29uc3QgZWxfdWludDI1NiA9IHVpbnQyNTYoZWxlbWVudCk7XG4gIHJldHVybiBbZmVsdChlbF91aW50MjU2LmxvdyksIGZlbHQoZWxfdWludDI1Ni5oaWdoKV07XG59XG5mdW5jdGlvbiBwYXJzZUNhbGxkYXRhVmFsdWUoZWxlbWVudCwgdHlwZSwgc3RydWN0cywgZW51bXMpIHtcbiAgaWYgKGVsZW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHRocm93IEVycm9yKGBNaXNzaW5nIHBhcmFtZXRlciBmb3IgdHlwZSAke3R5cGV9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQucHVzaChmZWx0KGVsZW1lbnQubGVuZ3RoKSk7XG4gICAgY29uc3QgYXJyYXlUeXBlID0gZ2V0QXJyYXlUeXBlKHR5cGUpO1xuICAgIHJldHVybiBlbGVtZW50LnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YVZhbHVlKGl0LCBhcnJheVR5cGUsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuICBpZiAoc3RydWN0c1t0eXBlXSAmJiBzdHJ1Y3RzW3R5cGVdLm1lbWJlcnMubGVuZ3RoKSB7XG4gICAgaWYgKGlzVHlwZVVpbnQyNTYodHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZVVpbnQyNTYoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiKVxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIGVsZW1lbnQpO1xuICAgIGNvbnN0IHsgbWVtYmVycyB9ID0gc3RydWN0c1t0eXBlXTtcbiAgICBjb25zdCBzdWJFbGVtZW50ID0gZWxlbWVudDtcbiAgICByZXR1cm4gbWVtYmVycy5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFWYWx1ZShzdWJFbGVtZW50W2l0Lm5hbWVdLCBpdC50eXBlLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH0sIFtdKTtcbiAgfVxuICBpZiAoaXNUeXBlVHVwbGUodHlwZSkpIHtcbiAgICBjb25zdCB0dXBsZWQgPSBwYXJzZVR1cGxlKGVsZW1lbnQsIHR5cGUpO1xuICAgIHJldHVybiB0dXBsZWQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWREYXRhID0gcGFyc2VDYWxsZGF0YVZhbHVlKGl0LmVsZW1lbnQsIGl0LnR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhcnNlZERhdGEpO1xuICAgIH0sIFtdKTtcbiAgfVxuICBpZiAoaXNUeXBlVWludDI1Nih0eXBlKSkge1xuICAgIHJldHVybiBwYXJzZVVpbnQyNTYoZWxlbWVudCk7XG4gIH1cbiAgaWYgKGlzVHlwZUVudW0odHlwZSwgZW51bXMpKSB7XG4gICAgY29uc3QgeyB2YXJpYW50cyB9ID0gZW51bXNbdHlwZV07XG4gICAgaWYgKGlzVHlwZU9wdGlvbih0eXBlKSkge1xuICAgICAgY29uc3QgbXlPcHRpb24gPSBlbGVtZW50O1xuICAgICAgaWYgKG15T3B0aW9uLmlzU29tZSgpKSB7XG4gICAgICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudDIgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IFwiU29tZVwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IE9wdGlvbiBoYXMgbm8gJ1NvbWUnIHZhcmlhbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVZhcmlhbnRTb21lID0gbGlzdFR5cGVWYXJpYW50Mi50eXBlO1xuICAgICAgICBpZiAodHlwZVZhcmlhbnRTb21lID09PSBcIigpXCIpIHtcbiAgICAgICAgICByZXR1cm4gMCAvKiBTb21lICovLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMiA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgICBteU9wdGlvbi51bndyYXAoKSxcbiAgICAgICAgICB0eXBlVmFyaWFudFNvbWUsXG4gICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICBlbnVtc1xuICAgICAgICApO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIyKSkge1xuICAgICAgICAgIHJldHVybiBbMCAvKiBTb21lICovLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCAvKiBTb21lICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEgLyogTm9uZSAqLy50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlUmVzdWx0KHR5cGUpKSB7XG4gICAgICBjb25zdCBteVJlc3VsdCA9IGVsZW1lbnQ7XG4gICAgICBpZiAobXlSZXN1bHQuaXNPaygpKSB7XG4gICAgICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudDMgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IFwiT2tcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBSZXN1bHQgaGFzIG5vICdPaycgdmFyaWFudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlVmFyaWFudE9rID0gbGlzdFR5cGVWYXJpYW50My50eXBlO1xuICAgICAgICBpZiAodHlwZVZhcmlhbnRPayA9PT0gXCIoKVwiKSB7XG4gICAgICAgICAgcmV0dXJuIDAgLyogT2sgKi8udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIzID0gcGFyc2VDYWxsZGF0YVZhbHVlKFxuICAgICAgICAgIG15UmVzdWx0LnVud3JhcCgpLFxuICAgICAgICAgIHR5cGVWYXJpYW50T2ssXG4gICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICBlbnVtc1xuICAgICAgICApO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIzKSkge1xuICAgICAgICAgIHJldHVybiBbMCAvKiBPayAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAgLyogT2sgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyM107XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQyID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIkVyclwiKTtcbiAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogUmVzdWx0IGhhcyBubyAnRXJyJyB2YXJpYW50LmApO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZVZhcmlhbnRFcnIgPSBsaXN0VHlwZVZhcmlhbnQyLnR5cGU7XG4gICAgICBpZiAodHlwZVZhcmlhbnRFcnIgPT09IFwiKClcIikge1xuICAgICAgICByZXR1cm4gMSAvKiBFcnIgKi8udG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjIgPSBwYXJzZUNhbGxkYXRhVmFsdWUobXlSZXN1bHQudW53cmFwKCksIHR5cGVWYXJpYW50RXJyLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIyKSkge1xuICAgICAgICByZXR1cm4gWzEgLyogRXJyICovLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsxIC8qIEVyciAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICB9XG4gICAgY29uc3QgbXlFbnVtID0gZWxlbWVudDtcbiAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gbXlFbnVtLmFjdGl2ZVZhcmlhbnQoKTtcbiAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IGFjdGl2ZVZhcmlhbnQpO1xuICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBFcnJvcihgTm90IGZpbmQgaW4gYWJpIDogRW51bSBoYXMgbm8gJyR7YWN0aXZlVmFyaWFudH0nIHZhcmlhbnQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVBY3RpdmVWYXJpYW50ID0gbGlzdFR5cGVWYXJpYW50LnR5cGU7XG4gICAgY29uc3QgbnVtQWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmRJbmRleCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBhY3RpdmVWYXJpYW50KTtcbiAgICBpZiAodHlwZUFjdGl2ZVZhcmlhbnQgPT09IFwiKClcIikge1xuICAgICAgcmV0dXJuIG51bUFjdGl2ZVZhcmlhbnQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyID0gcGFyc2VDYWxsZGF0YVZhbHVlKG15RW51bS51bndyYXAoKSwgdHlwZUFjdGl2ZVZhcmlhbnQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRQYXJhbWV0ZXIpKSB7XG4gICAgICByZXR1cm4gW251bUFjdGl2ZVZhcmlhbnQudG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIFtudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcl07XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhcmFtZXRlciAke2VsZW1lbnR9IGRvIG5vdCBhbGlnbiB3aXRoIGFiaSBwYXJhbWV0ZXIgJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGlucHV0O1xuICBsZXQgeyB2YWx1ZSB9ID0gYXJnc0l0ZXJhdG9yLm5leHQoKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIWlzVGV4dCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEFCSSBleHBlY3RlZCBwYXJhbWV0ZXIgJHtuYW1lfSB0byBiZSBhcnJheSBvciBsb25nIHN0cmluZywgZ290ICR7dmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXRMb25nU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIGlucHV0LnR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCI6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICAgIGNhc2UgKGlzVHlwZVN0cnVjdCh0eXBlLCBzdHJ1Y3RzKSB8fCBpc1R5cGVUdXBsZSh0eXBlKSB8fCBpc1R5cGVVaW50MjU2KHR5cGUpKTpcbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIHR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZUVudW0odHlwZSwgZW51bXMpOlxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN0cnVjdHMsXG4gICAgICAgIGVudW1zXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXNwb25zZVBhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIGl0KSB7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUJvb2wodHlwZSk6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oQmlnSW50KHRlbXApKTtcbiAgICBjYXNlIGlzVHlwZVVpbnQyNTYodHlwZSk6XG4gICAgICBjb25zdCBsb3cgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBoaWdoID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIHVpbnQyNTZUb0JOKHsgbG93LCBoaWdoIH0pO1xuICAgIGNhc2UgdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjpcbiAgICAgIHRlbXAgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQmlnSW50KHRlbXApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJpZ0ludCh0ZW1wKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsZW1lbnQsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGlmIChlbGVtZW50LnR5cGUgPT09IFwiKClcIikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoaXNUeXBlVWludDI1NihlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgbG93ID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgY29uc3QgaGlnaCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIHJldHVybiB1aW50MjU2VG9CTih7IGxvdywgaGlnaCB9KTtcbiAgfVxuICBpZiAoaXNUeXBlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogZ2V0QXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBsZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGxlbikge1xuICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gIH1cbiAgaWYgKHN0cnVjdHMgJiYgZWxlbWVudC50eXBlIGluIHN0cnVjdHMgJiYgc3RydWN0c1tlbGVtZW50LnR5cGVdKSB7XG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMihlbGVtZW50LnR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0c1tlbGVtZW50LnR5cGVdLm1lbWJlcnMucmVkdWNlKChhY2MsIGVsKSA9PiB7XG4gICAgICBhY2NbZWwubmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGlmIChlbnVtcyAmJiBlbGVtZW50LnR5cGUgaW4gZW51bXMgJiYgZW51bXNbZWxlbWVudC50eXBlXSkge1xuICAgIGNvbnN0IHZhcmlhbnROdW0gPSBOdW1iZXIocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIGNvbnN0IHJhd0VudW0gPSBlbnVtc1tlbGVtZW50LnR5cGVdLnZhcmlhbnRzLnJlZHVjZSgoYWNjLCB2YXJpYW50LCBudW0pID0+IHtcbiAgICAgIGlmIChudW0gPT09IHZhcmlhbnROdW0pIHtcbiAgICAgICAgYWNjW3ZhcmlhbnQubmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUoXG4gICAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgICB7IG5hbWU6IFwiXCIsIHR5cGU6IHZhcmlhbnQudHlwZSB9LFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKFwiY29yZTo6b3B0aW9uOjpPcHRpb25cIikpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB2YXJpYW50TnVtID09PSAwIC8qIFNvbWUgKi8gPyByYXdFbnVtLlNvbWUgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdFwiKSkge1xuICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICBpZiAodmFyaWFudE51bSA9PT0gMCAvKiBPayAqLykge1xuICAgICAgICBjb250ZW50ID0gcmF3RW51bS5PaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgPSByYXdFbnVtLkVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9SZXN1bHQodmFyaWFudE51bSwgY29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGN1c3RvbUVudW0gPSBuZXcgQ2Fpcm9DdXN0b21FbnVtKHJhd0VudW0pO1xuICAgIHJldHVybiBjdXN0b21FbnVtO1xuICB9XG4gIGlmIChpc1R5cGVUdXBsZShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgbWVtYmVyVHlwZXMgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyhlbGVtZW50LnR5cGUpO1xuICAgIHJldHVybiBtZW1iZXJUeXBlcy5yZWR1Y2UoKGFjYywgaXQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGl0Py5uYW1lID8gaXQubmFtZSA6IGlkeDtcbiAgICAgIGNvbnN0IHR5cGUgPSBpdD8udHlwZSA/IGl0LnR5cGUgOiBpdDtcbiAgICAgIGNvbnN0IGVsID0geyBuYW1lLCB0eXBlIH07XG4gICAgICBhY2NbbmFtZV0gPSBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG4gIGlmIChpc1R5cGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgIGNvbnN0IGVsID0geyBuYW1lOiBcIlwiLCB0eXBlOiBnZXRBcnJheVR5cGUoZWxlbWVudC50eXBlKSB9O1xuICAgIGNvbnN0IGxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBwYXJzZWREYXRhQXJyLnB1c2gocGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgfVxuICByZXR1cm4gcGFyc2VCYXNlVHlwZXMyKGVsZW1lbnQudHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG59XG5mdW5jdGlvbiByZXNwb25zZVBhcnNlcihyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zLCBwYXJzZWRSZXN1bHQpIHtcbiAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBvdXRwdXQ7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzTGVuKG5hbWUpOlxuICAgICAgdGVtcCA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJpZ0ludCh0ZW1wKTtcbiAgICBjYXNlIChzdHJ1Y3RzICYmIHR5cGUgaW4gc3RydWN0cyB8fCBpc1R5cGVUdXBsZSh0eXBlKSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgKGVudW1zICYmIGlzVHlwZUVudW0odHlwZSwgZW51bXMpKTpcbiAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICAgIGlmIChwYXJzZWRSZXN1bHQgJiYgcGFyc2VkUmVzdWx0W2Ake25hbWV9X2xlbmBdKSB7XG4gICAgICAgIGNvbnN0IGFyckxlbiA9IHBhcnNlZFJlc3VsdFtgJHtuYW1lfV9sZW5gXTtcbiAgICAgICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgYXJyTGVuKSB7XG4gICAgICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKFxuICAgICAgICAgICAgcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgICAgICByZXNwb25zZUl0ZXJhdG9yLFxuICAgICAgICAgICAgICB7IG5hbWUsIHR5cGU6IG91dHB1dC50eXBlLnJlcGxhY2UoXCIqXCIsIFwiXCIpIH0sXG4gICAgICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgICAgIGVudW1zXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIodHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3ZhbGlkYXRlLnRzXG52YXIgdmFsaWRhdGVGZWx0ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcImJpZ2ludFwiLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgZmVsdCB0eXBlZCBhcyAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KWBcbiAgKTtcbiAgaWYgKHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgJiYgIWlzSGV4KHBhcmFtZXRlcikpXG4gICAgcmV0dXJuO1xuICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgYXNzZXJ0KFxuICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjY2XG4gICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjUybiAtIDFuLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVVpbnQgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBpZiAodHlwZW9mIHBhcmFtZXRlciA9PT0gXCJudW1iZXJcIikge1xuICAgIGFzc2VydChcbiAgICAgIHBhcmFtZXRlciA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgIGBWYWxpZGF0aW9uOiBQYXJhbWV0ZXIgaXMgdG8gbGFyZ2UgdG8gYmUgdHlwZWQgYXMgTnVtYmVyIHVzZSAoQmlnSW50IG9yIFN0cmluZylgXG4gICAgKTtcbiAgfVxuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiBcImxvd1wiIGluIHBhcmFtZXRlciAmJiBcImhpZ2hcIiBpbiBwYXJhbWV0ZXIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBvZiBjYWlybyB0eXBlICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIHR5cGUgKFN0cmluZywgTnVtYmVyIG9yIEJpZ0ludCksIGJ1dCBpcyAke3R5cGVvZiBwYXJhbWV0ZXJ9ICR7cGFyYW1ldGVyfS5gXG4gICk7XG4gIGNvbnN0IHBhcmFtID0gdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiA/IHVpbnQyNTZUb0JOKHBhcmFtZXRlcikgOiB0b0JpZ0ludChwYXJhbWV0ZXIpO1xuICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dThcIiAvKiB1OCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMjU1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCAtIDI1NV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUxNlwiIC8qIHUxNiAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gNjU1MzVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCA2NTUzNV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUzMlwiIC8qIHUzMiAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gNDI5NDk2NzI5NW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDQyOTQ5NjcyOTVdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1NjRcIiAvKiB1NjQgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDY0biAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjY0LTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MTI4XCIgLyogdTEyOCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMTI4biAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjEyOC0xXWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIC8qIHUyNTYgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Nm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyAke2lucHV0LnR5cGV9IDAgLSAyXjI1Ni0xYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjpzdGFya25ldDo6Y2xhc3NfaGFzaDo6Q2xhc3NIYXNoXCIgLyogQ2xhc3NIYXNoICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTY3MFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjpzdGFya25ldDo6Y29udHJhY3RfYWRkcmVzczo6Q29udHJhY3RBZGRyZXNzXCIgLyogQ29udHJhY3RBZGRyZXNzICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI0NVxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTJuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMjUyLTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUJvb2wgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJib29sZWFuXCIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBvZiBjYWlybyB0eXBlICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIHR5cGUgKEJvb2xlYW4pYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVN0cnVjdCA9IChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzKSA9PiB7XG4gIGlmIChpbnB1dC50eXBlID09PSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovKSB7XG4gICAgdmFsaWRhdGVVaW50KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5wdXQudHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIikge1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBwYXJhbWV0ZXIgIT09IFwib2JqZWN0XCIsXG4gICAgICBgRXRoQWRkcmVzcyB0eXBlIGlzIHdhaXRpbmcgYSBCaWdOdW1iZXJpc2guIEdvdCAke3BhcmFtZXRlcn1gXG4gICAgKTtcbiAgICBjb25zdCBwYXJhbSA9IEJpZ0ludChwYXJhbWV0ZXIudG9TdHJpbmcoMTApKTtcbiAgICBhc3NlcnQoXG4gICAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI1OVxuICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMTYwbiAtIDFuLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4xNjAtMV1gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzIGNhaXJvIHR5cGUgc3RydWN0ICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgc3RydWN0c1tpbnB1dC50eXBlXS5tZW1iZXJzLmZvckVhY2goKHsgbmFtZSB9KSA9PiB7XG4gICAgYXNzZXJ0KFxuICAgICAgT2JqZWN0LmtleXMocGFyYW1ldGVyKS5pbmNsdWRlcyhuYW1lKSxcbiAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGhhdmUgYSBwcm9wZXJ0eSAke25hbWV9YFxuICAgICk7XG4gIH0pO1xufTtcbnZhciB2YWxpZGF0ZUVudW0gPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBFbnVtICgke2lucHV0LnR5cGV9KSwgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGFzIGpzIG9iamVjdCAobm90IGFycmF5KWBcbiAgKTtcbiAgY29uc3QgbWV0aG9kc0tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyYW1ldGVyKSk7XG4gIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyYW1ldGVyKSwgLi4ubWV0aG9kc0tleXNdO1xuICBpZiAoaXNUeXBlT3B0aW9uKGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNUeXBlUmVzdWx0KGlucHV0LnR5cGUpICYmIGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBWYWxpZGF0ZSBFbnVtOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlIHJlY2VpdmVkICR7cGFyYW1ldGVyfSwgaXMgbm90IGFuIEVudW0uYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZVR1cGxlID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIHR1cGxlIChkZWZpbmVkIGFzIG9iamVjdClgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlQXJyYXkgPSAocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cywgZW51bXMpID0+IHtcbiAgY29uc3QgYmFzZVR5cGUgPSBnZXRBcnJheVR5cGUoaW5wdXQudHlwZSk7XG4gIGlmIChpc1R5cGVGZWx0KGJhc2VUeXBlKSAmJiBpc0xvbmdUZXh0KHBhcmFtZXRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSwgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYW4gQXJyYXlgKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVGZWx0KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVGZWx0KHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVUdXBsZShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlVHVwbGUoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVBcnJheShiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaChcbiAgICAgICAgKHBhcmFtKSA9PiB2YWxpZGF0ZUFycmF5KHBhcmFtLCB7IG5hbWU6IFwiXCIsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMsIGVudW1zKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlU3RydWN0KGJhc2VUeXBlLCBzdHJ1Y3RzKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAoaXQpID0+IHZhbGlkYXRlU3RydWN0KGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0sIHN0cnVjdHMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVFbnVtKGJhc2VUeXBlLCBlbnVtcyk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgoaXQpID0+IHZhbGlkYXRlRW51bShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChpc1R5cGVVaW50KGJhc2VUeXBlKSB8fCBpc1R5cGVMaXR0ZXJhbChiYXNlVHlwZSkpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZVVpbnQocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUJvb2woYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZUJvb2wocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKChhY2MsIGlucHV0KSA9PiB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gYXJnc1thY2NdO1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBpc0xlbihpbnB1dC5uYW1lKTpcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIGNhc2UgaXNUeXBlRmVsdChpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVGZWx0KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgKGlzVHlwZVVpbnQoaW5wdXQudHlwZSkgfHwgaXNUeXBlTGl0dGVyYWwoaW5wdXQudHlwZSkpOlxuICAgICAgICB2YWxpZGF0ZVVpbnQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVCb29sKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZUJvb2wocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVBcnJheShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVBcnJheShwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVTdHJ1Y3QoaW5wdXQudHlwZSwgc3RydWN0cyk6XG4gICAgICAgIHZhbGlkYXRlU3RydWN0KHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlRW51bShpbnB1dC50eXBlLCBlbnVtcyk6XG4gICAgICAgIHZhbGlkYXRlRW51bShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZVR1cGxlKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZVR1cGxlKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIDE7XG4gIH0sIDApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvaW5kZXgudHNcbnZhciBDYWxsRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYWJpKSB7XG4gICAgdGhpcy5zdHJ1Y3RzID0gQ2FsbERhdGEuZ2V0QWJpU3RydWN0KGFiaSk7XG4gICAgdGhpcy5lbnVtcyA9IENhbGxEYXRhLmdldEFiaUVudW0oYWJpKTtcbiAgICB0aGlzLnBhcnNlciA9IGNyZWF0ZUFiaVBhcnNlcihhYmkpO1xuICAgIHRoaXMuYWJpID0gdGhpcy5wYXJzZXIuZ2V0TGVnYWN5Rm9ybWF0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBhcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBvbmVzIGluIHRoZSBhYmlcbiAgICogQHBhcmFtIHR5cGUgVmFsaWRhdGVUeXBlIC0gdHlwZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gbmFtZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBhcmdzIEFyZ3NPckNhbGxkYXRhIC0gYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqL1xuICB2YWxpZGF0ZSh0eXBlLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIGlmICh0eXBlICE9PSBcIkRFUExPWVwiIC8qIERFUExPWSAqLykge1xuICAgICAgY29uc3QgaW52b2NhYmxlRnVuY3Rpb25OYW1lcyA9IHRoaXMuYWJpLmZpbHRlcigoYWJpKSA9PiB7XG4gICAgICAgIGlmIChhYmkudHlwZSAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaXNWaWV3ID0gYWJpLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgYWJpLnN0YXRlX211dGFiaWxpdHkgPT09IFwidmlld1wiO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8gPyAhaXNWaWV3IDogaXNWaWV3O1xuICAgICAgfSkubWFwKChhYmkpID0+IGFiaS5uYW1lKTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgaW52b2NhYmxlRnVuY3Rpb25OYW1lcy5pbmNsdWRlcyhtZXRob2QpLFxuICAgICAgICBgJHt0eXBlID09PSBcIklOVk9LRVwiIC8qIElOVk9LRSAqLyA/IFwiaW52b2NhYmxlXCIgOiBcInZpZXdhYmxlXCJ9IG1ldGhvZCBub3QgZm91bmQgaW4gYWJpYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZChcbiAgICAgIChhYmkpID0+IHR5cGUgPT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovID8gYWJpLm5hbWUgPT09IG1ldGhvZCAmJiBhYmkudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiIDogYWJpLm5hbWUgPT09IG1ldGhvZCAmJiBhYmkudHlwZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgKTtcbiAgICBpZiAoaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzLCBhYmlNZXRob2QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0c0xlbmd0aCA9IHRoaXMucGFyc2VyLm1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gaW5wdXRzTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cywgZXhwZWN0ZWQgJHtpbnB1dHNMZW5ndGh9IGFyZ3VtZW50cywgYnV0IGdvdCAke2FyZ3MubGVuZ3RofWBcbiAgICAgICk7XG4gICAgfVxuICAgIHZhbGlkYXRlRmllbGRzKGFiaU1ldGhvZCwgYXJncywgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBjb250cmFjdCBjYWxsRGF0YSB3aXRoIGFiaVxuICAgKiBQYXJzZSB0aGUgY2FsbGRhdGEgYnkgdXNpbmcgaW5wdXQgZmllbGRzIGZyb20gdGhlIGFiaSBmb3IgdGhhdCBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gYXJncyBSYXdBcmdzIC0gYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLiBDYW4gYmUgYW4gYXJyYXkgb2YgYXJndW1lbnRzIChpbiB0aGUgb3JkZXIgb2YgYWJpIGRlZmluaXRpb24pLCBvciBhbiBvYmplY3QgY29uc3RydWN0ZWQgaW4gY29uZm9ybWl0eSB3aXRoIGFiaSAoaW4gdGhpcyBjYXNlLCB0aGUgcGFyYW1ldGVyIGNhbiBiZSBpbiBhIHdyb25nIG9yZGVyKS5cbiAgICogQHJldHVybiBDYWxsZGF0YSAtIHBhcnNlZCBhcmd1bWVudHMgaW4gZm9ybWF0IHRoYXQgY29udHJhY3QgaXMgZXhwZWN0aW5nXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY2FsbGRhdGEgPSBteUNhbGxEYXRhLmNvbXBpbGUoXCJjb25zdHJ1Y3RvclwiLCBbXCIweDM0YVwiLCBbMSwgM25dXSk7XG4gICAqIGBgYFxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNhbGxkYXRhMiA9IG15Q2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHtsaXN0OlsxLCAzbl0sIGJhbGFuY2U6XCIweDM0XCJ9KTsgLy8gd3Jvbmcgb3JkZXIgaXMgdmFsaWRcbiAgICogYGBgXG4gICAqL1xuICBjb21waWxlKG1ldGhvZCwgYXJnc0NhbGxkYXRhKSB7XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZCgoYWJpRnVuY3Rpb24pID0+IGFiaUZ1bmN0aW9uLm5hbWUgPT09IG1ldGhvZCk7XG4gICAgaWYgKGlzTm9Db25zdHJ1Y3RvclZhbGlkKG1ldGhvZCwgYXJnc0NhbGxkYXRhLCBhYmlNZXRob2QpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBhcmdzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NDYWxsZGF0YSkpIHtcbiAgICAgIGFyZ3MgPSBhcmdzQ2FsbGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9yZGVyZWRPYmplY3QgPSBvcmRlclByb3BzQnlBYmkoXG4gICAgICAgIGFyZ3NDYWxsZGF0YSxcbiAgICAgICAgYWJpTWV0aG9kLmlucHV0cyxcbiAgICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgICB0aGlzLmVudW1zXG4gICAgICApO1xuICAgICAgYXJncyA9IE9iamVjdC52YWx1ZXMob3JkZXJlZE9iamVjdCk7XG4gICAgICB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3NJdGVyYXRvciA9IGFyZ3NbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGNhbGxBcnJheSA9IGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKFxuICAgICAgKGFjYywgaW5wdXQpID0+IGlzTGVuKGlucHV0Lm5hbWUpICYmICFpc0NhaXJvMVR5cGUoaW5wdXQudHlwZSkgPyBhY2MgOiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpKSxcbiAgICAgIFtdXG4gICAgKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FsbEFycmF5LCBcIl9fY29tcGlsZWRfX1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxBcnJheTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBjb250cmFjdCBjYWxsRGF0YSB3aXRob3V0IGFiaVxuICAgKiBAcGFyYW0gcmF3QXJncyBSYXdBcmdzIHJlcHJlc2VudGluZyBjYWlybyBtZXRob2QgYXJndW1lbnRzIG9yIHN0cmluZyBhcnJheSBvZiBjb21waWxlZCBkYXRhXG4gICAqIEByZXR1cm5zIENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgY29tcGlsZShyYXdBcmdzKSB7XG4gICAgY29uc3QgY3JlYXRlVHJlZSA9IChvYmopID0+IHtcbiAgICAgIGNvbnN0IGdldEVudHJpZXMgPSAobywgcHJlZml4ID0gXCIuXCIpID0+IHtcbiAgICAgICAgY29uc3Qgb2UgPSBBcnJheS5pc0FycmF5KG8pID8gW28ubGVuZ3RoLnRvU3RyaW5nKCksIC4uLm9dIDogbztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9lKS5mbGF0TWFwKChbaywgdl0pID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB2O1xuICAgICAgICAgIGlmIChrID09PSBcImVudHJ5cG9pbnRcIilcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0U2VsZWN0b3JGcm9tTmFtZSh2YWx1ZSk7XG4gICAgICAgICAgZWxzZSBpZiAoaXNMb25nVGV4dCh2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9IHNwbGl0TG9uZ1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgY29uc3Qga2sgPSBBcnJheS5pc0FycmF5KG9lKSAmJiBrID09PSBcIjBcIiA/IFwiJCRsZW5cIiA6IGs7XG4gICAgICAgICAgaWYgKGlzQmlnSW50KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFsdWUpXV07XG4gICAgICAgICAgaWYgKE9iamVjdCh2YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2RzS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSksIC4uLm1ldGhvZHNLZXlzXTtcbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwiaXNTb21lXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc05vbmVcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlPcHRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5iID0gbXlPcHRpb24uaXNTb21lKCkgPyAwIC8qIFNvbWUgKi8gOiAxIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgIGlmIChteU9wdGlvbi5pc1NvbWUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IHZhcmlhbnROYiwgMTogbXlPcHRpb24udW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhcmlhbnROYildXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwiaXNPa1wiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNFcnJcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlSZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFudE5iID0gbXlSZXN1bHQuaXNPaygpID8gMCAvKiBPayAqLyA6IDEgLyogRXJyICovO1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IHZhcmlhbnROYiwgMTogbXlSZXN1bHQudW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJ2YXJpYW50XCIpICYmIGtleXMuaW5jbHVkZXMoXCJhY3RpdmVWYXJpYW50XCIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG15RW51bSA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gbXlFbnVtLmFjdGl2ZVZhcmlhbnQoKTtcbiAgICAgICAgICAgICAgY29uc3QgbGlzdFZhcmlhbnRzID0gT2JqZWN0LmtleXMobXlFbnVtLnZhcmlhbnQpO1xuICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWYXJpYW50TmIgPSBsaXN0VmFyaWFudHMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICh2YXJpYW50KSA9PiB2YXJpYW50ID09PSBhY3RpdmVWYXJpYW50XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbXlFbnVtLnVud3JhcCgpID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKG15RW51bS51bndyYXAoKSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdChhY3RpdmVWYXJpYW50TmIpXV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXMoeyAwOiBhY3RpdmVWYXJpYW50TmIsIDE6IG15RW51bS51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh2YWx1ZSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhbHVlKV1dO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0RW50cmllcyhvYmopKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBsZXQgY2FsbFRyZWVBcnJheTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3QXJncykpIHtcbiAgICAgIGNvbnN0IGNhbGxUcmVlID0gY3JlYXRlVHJlZShyYXdBcmdzKTtcbiAgICAgIGNhbGxUcmVlQXJyYXkgPSBPYmplY3QudmFsdWVzKGNhbGxUcmVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2FsbE9iaiA9IHsgLi4ucmF3QXJncyB9O1xuICAgICAgY29uc3QgY2FsbFRyZWUgPSBjcmVhdGVUcmVlKGNhbGxPYmopO1xuICAgICAgY2FsbFRyZWVBcnJheSA9IE9iamVjdC52YWx1ZXMoY2FsbFRyZWUpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FsbFRyZWVBcnJheSwgXCJfX2NvbXBpbGVkX19cIiwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBjYWxsVHJlZUFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBlbGVtZW50cyBvZiB0aGUgcmVzcG9uc2UgYXJyYXkgYW5kIHN0cnVjdHVyaW5nIHRoZW0gaW50byByZXNwb25zZSBvYmplY3RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSByZXNwb25zZSBmcm9tIHRoZSBtZXRob2RcbiAgICogQHJldHVybiBSZXN1bHQgLSBwYXJzZWQgcmVzcG9uc2UgY29ycmVzcG9uZGluZyB0byB0aGUgYWJpXG4gICAqL1xuICBwYXJzZShtZXRob2QsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgeyBvdXRwdXRzIH0gPSB0aGlzLmFiaS5maW5kKChhYmkpID0+IGFiaS5uYW1lID09PSBtZXRob2QpO1xuICAgIGNvbnN0IHJlc3BvbnNlSXRlcmF0b3IgPSByZXNwb25zZS5mbGF0KClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IHBhcnNlZCA9IG91dHB1dHMuZmxhdCgpLnJlZHVjZSgoYWNjLCBvdXRwdXQsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgcHJvcE5hbWUgPSBvdXRwdXQubmFtZSA/PyBpZHg7XG4gICAgICBhY2NbcHJvcE5hbWVdID0gcmVzcG9uc2VQYXJzZXIocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMsIGFjYyk7XG4gICAgICBpZiAoYWNjW3Byb3BOYW1lXSAmJiBhY2NbYCR7cHJvcE5hbWV9X2xlbmBdKSB7XG4gICAgICAgIGRlbGV0ZSBhY2NbYCR7cHJvcE5hbWV9X2xlbmBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoID09PSAxICYmIDAgaW4gcGFyc2VkID8gcGFyc2VkWzBdIDogcGFyc2VkO1xuICB9XG4gIC8qKlxuICAgKiBGb3JtYXQgY2Fpcm8gbWV0aG9kIHJlc3BvbnNlIGRhdGEgdG8gbmF0aXZlIGpzIHZhbHVlcyBiYXNlZCBvbiBwcm92aWRlZCBmb3JtYXQgc2NoZW1hXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gY2Fpcm8gbWV0aG9kIG5hbWVcbiAgICogQHBhcmFtIHJlc3BvbnNlIHN0cmluZ1tdIC0gY2Fpcm8gbWV0aG9kIHJlc3BvbnNlXG4gICAqIEBwYXJhbSBmb3JtYXQgb2JqZWN0IC0gZm9ybWF0dGVyIG9iamVjdCBzY2hlbWFcbiAgICogQHJldHVybnMgUmVzdWx0IC0gcGFyc2VkIGFuZCBmb3JtYXR0ZWQgcmVzcG9uc2Ugb2JqZWN0XG4gICAqL1xuICBmb3JtYXQobWV0aG9kLCByZXNwb25zZSwgZm9ybWF0KSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZShtZXRob2QsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyKHBhcnNlZCwgZm9ybWF0KTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIHRvIGV4dHJhY3Qgc3RydWN0cyBmcm9tIGFiaVxuICAgKiBAcGFyYW0gYWJpIEFiaVxuICAgKiBAcmV0dXJucyBBYmlTdHJ1Y3RzIC0gc3RydWN0cyBmcm9tIGFiaVxuICAgKi9cbiAgc3RhdGljIGdldEFiaVN0cnVjdChhYmkpIHtcbiAgICByZXR1cm4gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwic3RydWN0XCIpLnJlZHVjZShcbiAgICAgIChhY2MsIGFiaUVudHJ5KSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFthYmlFbnRyeS5uYW1lXTogYWJpRW50cnlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBlbnVtcyBmcm9tIGFiaVxuICAgKiBAcGFyYW0gYWJpIEFiaVxuICAgKiBAcmV0dXJucyBBYmlFbnVtcyAtIGVudW1zIGZyb20gYWJpXG4gICAqL1xuICBzdGF0aWMgZ2V0QWJpRW51bShhYmkpIHtcbiAgICBjb25zdCBmdWxsRW51bUxpc3QgPSBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJlbnVtXCIpLnJlZHVjZShcbiAgICAgIChhY2MsIGFiaUVudHJ5KSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFthYmlFbnRyeS5uYW1lXTogYWJpRW50cnlcbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICAgIGRlbGV0ZSBmdWxsRW51bUxpc3RbXCJjb3JlOjpib29sXCJdO1xuICAgIHJldHVybiBmdWxsRW51bUxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlcjogQ29tcGlsZSBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcGFyYW0gcmF3Q2FsbGRhdGEgSGV4Q2FsbGRhdGEgfCBSYXdDYWxsZGF0YSB8IFJhd0FyZ3NcbiAgICogQHJldHVybnMgQ2FsbGRhdGFcbiAgICovXG4gIHN0YXRpYyB0b0NhbGxkYXRhKHJhd0NhbGxkYXRhID0gW10pIHtcbiAgICByZXR1cm4gQ2FsbERhdGEuY29tcGlsZShyYXdDYWxsZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlcjogQ29udmVydCByYXcgdG8gSGV4Q2FsbGRhdGFcbiAgICogQHBhcmFtIHJhdyBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcmV0dXJucyBIZXhDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIHRvSGV4KHJhdyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKHJhdyk7XG4gICAgcmV0dXJuIGNhbGxkYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9oYXNoLnRzXG52YXIgaGFzaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChoYXNoX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2g6ICgpID0+IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoLFxuICBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVEZXBsb3lUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjogKCkgPT4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uLFxuICBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb21waWxlZENsYXNzSGFzaCxcbiAgY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2gsXG4gIGNvbXB1dGVIYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2gsXG4gIGRlZmF1bHQ6ICgpID0+IGNvbXB1dGVIaW50ZWRDbGFzc0hhc2gsXG4gIGZlZVRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gZmVlVHJhbnNhY3Rpb25WZXJzaW9uLFxuICBmZWVUcmFuc2FjdGlvblZlcnNpb25fMjogKCkgPT4gZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzIsXG4gIGZvcm1hdFNwYWNlczogKCkgPT4gZm9ybWF0U3BhY2VzLFxuICBnZXRTZWxlY3RvcjogKCkgPT4gZ2V0U2VsZWN0b3IsXG4gIGdldFNlbGVjdG9yRnJvbU5hbWU6ICgpID0+IGdldFNlbGVjdG9yRnJvbU5hbWUsXG4gIGdldFZlcnNpb25zQnlUeXBlOiAoKSA9PiBnZXRWZXJzaW9uc0J5VHlwZSxcbiAga2VjY2FrQm46ICgpID0+IGtlY2Nha0JuLFxuICBwb3NlaWRvbjogKCkgPT4gcG9zZWlkb24sXG4gIHN0YXJrbmV0S2VjY2FrOiAoKSA9PiBzdGFya25ldEtlY2NhayxcbiAgdHJhbnNhY3Rpb25WZXJzaW9uOiAoKSA9PiB0cmFuc2FjdGlvblZlcnNpb24sXG4gIHRyYW5zYWN0aW9uVmVyc2lvbl8yOiAoKSA9PiB0cmFuc2FjdGlvblZlcnNpb25fMlxufSk7XG5pbXBvcnQgeyBwb3NlaWRvbkhhc2hNYW55IH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuXG4vLyBzcmMvdXRpbHMvZWMudHNcbnZhciBlY19leHBvcnRzID0ge307XG5fX2V4cG9ydChlY19leHBvcnRzLCB7XG4gIHN0YXJrQ3VydmU6ICgpID0+IHN0YXJrQ3VydmUsXG4gIHdlaWVyc3RyYXNzOiAoKSA9PiB3ZWllcnN0cmFzc1xufSk7XG5pbXBvcnQgKiBhcyBzdGFya0N1cnZlIGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmltcG9ydCAqIGFzIHdlaWVyc3RyYXNzIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzXCI7XG5cbi8vIHNyYy91dGlscy9qc29uLnRzXG52YXIganNvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChqc29uX2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlMixcbiAgcGFyc2VBbHdheXNBc0JpZzogKCkgPT4gcGFyc2VBbHdheXNBc0JpZyxcbiAgc3RyaW5naWZ5OiAoKSA9PiBzdHJpbmdpZnkyLFxuICBzdHJpbmdpZnlBbHdheXNBc0JpZzogKCkgPT4gc3RyaW5naWZ5QWx3YXlzQXNCaWdcbn0pO1xuaW1wb3J0ICogYXMganNvbiBmcm9tIFwibG9zc2xlc3MtanNvblwiO1xudmFyIHBhcnNlSW50QXNOdW1iZXJPckJpZ0ludCA9ICh4KSA9PiB7XG4gIGlmICghanNvbi5pc0ludGVnZXIoeCkpXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoeCk7XG4gIGNvbnN0IHYgPSBwYXJzZUludCh4LCAxMCk7XG4gIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2KSA/IHYgOiBCaWdJbnQoeCk7XG59O1xudmFyIHBhcnNlMiA9ICh4KSA9PiBqc29uLnBhcnNlKFN0cmluZyh4KSwgdm9pZCAwLCBwYXJzZUludEFzTnVtYmVyT3JCaWdJbnQpO1xudmFyIHBhcnNlQWx3YXlzQXNCaWcgPSAoeCkgPT4ganNvbi5wYXJzZShTdHJpbmcoeCksIHZvaWQgMCwganNvbi5wYXJzZU51bWJlckFuZEJpZ0ludCk7XG52YXIgc3RyaW5naWZ5MiA9ICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBudW1iZXJTdHJpbmdpZmllcnMpID0+IGpzb24uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIG51bWJlclN0cmluZ2lmaWVycyk7XG52YXIgc3RyaW5naWZ5QWx3YXlzQXNCaWcgPSBzdHJpbmdpZnkyO1xuXG4vLyBzcmMvdXRpbHMvaGFzaC50c1xuaW1wb3J0ICogYXMgcG9zZWlkb24gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvcG9zZWlkb25cIjtcbnZhciB0cmFuc2FjdGlvblZlcnNpb24gPSBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzE7XG52YXIgdHJhbnNhY3Rpb25WZXJzaW9uXzIgPSBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzI7XG52YXIgZmVlVHJhbnNhY3Rpb25WZXJzaW9uID0gQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTtcbnZhciBmZWVUcmFuc2FjdGlvblZlcnNpb25fMiA9IEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzI7XG5mdW5jdGlvbiBnZXRWZXJzaW9uc0J5VHlwZSh2ZXJzaW9uVHlwZSkge1xuICByZXR1cm4gdmVyc2lvblR5cGUgPT09IFwiZmVlXCIgPyB7IHYxOiBmZWVUcmFuc2FjdGlvblZlcnNpb24sIHYyOiBmZWVUcmFuc2FjdGlvblZlcnNpb25fMiB9IDogeyB2MTogdHJhbnNhY3Rpb25WZXJzaW9uLCB2MjogdHJhbnNhY3Rpb25WZXJzaW9uXzIgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhKSB7XG4gIHJldHVybiBbLi4uZGF0YSwgZGF0YS5sZW5ndGhdLnJlZHVjZSgoeCwgeSkgPT4gc3RhcmtDdXJ2ZS5wZWRlcnNlbih0b0JpZ0ludCh4KSwgdG9CaWdJbnQoeSkpLCAwKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKHR4SGFzaFByZWZpeCwgdmVyc2lvbiwgY29udHJhY3RBZGRyZXNzLCBlbnRyeVBvaW50U2VsZWN0b3IsIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIGFkZGl0aW9uYWxEYXRhID0gW10pIHtcbiAgY29uc3QgY2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNhbGxkYXRhKTtcbiAgY29uc3QgZGF0YVRvSGFzaCA9IFtcbiAgICB0eEhhc2hQcmVmaXgsXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlQb2ludFNlbGVjdG9yLFxuICAgIGNhbGxkYXRhSGFzaCxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICAuLi5hZGRpdGlvbmFsRGF0YVxuICBdO1xuICByZXR1cm4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGRhdGFUb0hhc2gpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVwbG95VHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgY29uc3RydWN0b3JDYWxsZGF0YSwgdmVyc2lvbiwgY2hhaW5JZCwgY29uc3RydWN0b3JOYW1lID0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU3MDZjNmY3OVwiIC8qIERFUExPWSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBnZXRTZWxlY3RvckZyb21OYW1lKGNvbnN0cnVjdG9yTmFtZSksXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAwLFxuICAgIGNoYWluSWRcbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2goY2xhc3NIYXNoLCBzZW5kZXJBZGRyZXNzLCB2ZXJzaW9uLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlLCBjb21waWxlZENsYXNzSGFzaCkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2NDY1NjM2YzYxNzI2NVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIDAsXG4gICAgW2NsYXNzSGFzaF0sXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlLCAuLi5jb21waWxlZENsYXNzSGFzaCA/IFtjb21waWxlZENsYXNzSGFzaF0gOiBbXV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2goY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNhbHQsIHZlcnNpb24sIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UpIHtcbiAgY29uc3QgY2FsbGRhdGEgPSBbY2xhc3NIYXNoLCBzYWx0LCAuLi5jb25zdHJ1Y3RvckNhbGxkYXRhXTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4NjQ2NTcwNmM2Zjc5NWY2MTYzNjM2Zjc1NmU3NFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIDAsXG4gICAgY2FsbGRhdGEsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgdmVyc2lvbiwgY2FsbGRhdGEsIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4Njk2ZTc2NmY2YjY1XCIgLyogSU5WT0tFICovLFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIDAsXG4gICAgY2FsbGRhdGEsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goc2FsdCwgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBkZXBsb3llckFkZHJlc3MpIHtcbiAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNvbXBpbGVkQ2FsbGRhdGEpO1xuICBjb25zdCBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCA9IGZlbHQoXCIweDUzNTQ0MTUyNGI0ZTQ1NTQ1ZjQzNGY0ZTU0NTI0MTQzNTQ1ZjQxNDQ0NDUyNDU1MzUzXCIpO1xuICBjb25zdCBoYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFtcbiAgICBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCxcbiAgICBkZXBsb3llckFkZHJlc3MsXG4gICAgc2FsdCxcbiAgICBjbGFzc0hhc2gsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YUhhc2hcbiAgXSk7XG4gIHJldHVybiB0b0hleChCaWdJbnQoaGFzaCkgJSBBRERSX0JPVU5EKTtcbn1cbmZ1bmN0aW9uIG51bGxTa2lwUmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09PSBcImF0dHJpYnV0ZXNcIiB8fCBrZXkgPT09IFwiYWNjZXNzaWJsZV9zY29wZXNcIikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiB2YWx1ZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImRlYnVnX2luZm9cIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZm9ybWF0U3BhY2VzKGpzb24yKSB7XG4gIGxldCBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcbiAgY29uc3QgbmV3U3RyaW5nID0gW107XG4gIGZvciAoY29uc3QgY2hhciBvZiBqc29uMikge1xuICAgIGlmIChjaGFyID09PSAnXCInICYmIChuZXdTdHJpbmcubGVuZ3RoID4gMCAmJiBuZXdTdHJpbmcuc2xpY2UoLTEpWzBdID09PSBcIlxcXFxcIikgPT09IGZhbHNlKSB7XG4gICAgICBpbnNpZGVRdW90ZXMgPSAhaW5zaWRlUXVvdGVzO1xuICAgIH1cbiAgICBpZiAoaW5zaWRlUXVvdGVzKSB7XG4gICAgICBuZXdTdHJpbmcucHVzaChjaGFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RyaW5nLnB1c2goY2hhciA9PT0gXCI6XCIgPyBcIjogXCIgOiBjaGFyID09PSBcIixcIiA/IFwiLCBcIiA6IGNoYXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3U3RyaW5nLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBjb21wdXRlSGludGVkQ2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpIHtcbiAgY29uc3QgeyBhYmksIHByb2dyYW0gfSA9IGNvbXBpbGVkQ29udHJhY3Q7XG4gIGNvbnN0IGNvbnRyYWN0Q2xhc3MgPSB7IGFiaSwgcHJvZ3JhbSB9O1xuICBjb25zdCBzZXJpYWxpemVkSnNvbiA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0Q2xhc3MsIG51bGxTa2lwUmVwbGFjZXIpKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShzZXJpYWxpemVkSnNvbikpLnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2goY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IHR5cGVvZiBjb250cmFjdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IHRvSGV4KEFQSV9WRVJTSU9OKTtcbiAgY29uc3QgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTC5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBsMUhhbmRsZXJFbnRyeVBvaW50c0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5DT05TVFJVQ1RPUi5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBidWlsdGluc0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoXG4gICAgY29tcGlsZWRDb250cmFjdC5wcm9ncmFtLmJ1aWx0aW5zLm1hcCgocykgPT4gZW5jb2RlU2hvcnRTdHJpbmcocykpXG4gICk7XG4gIGNvbnN0IGhpbnRlZENsYXNzSGFzaCA9IGNvbXB1dGVIaW50ZWRDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG4gIGNvbnN0IGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNvbXBpbGVkQ29udHJhY3QucHJvZ3JhbS5kYXRhKTtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50cyhbXG4gICAgYXBpVmVyc2lvbixcbiAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICBsMUhhbmRsZXJFbnRyeVBvaW50c0hhc2gsXG4gICAgY29uc3RydWN0b3JFbnRyeVBvaW50SGFzaCxcbiAgICBidWlsdGluc0hhc2gsXG4gICAgaGludGVkQ2xhc3NIYXNoLFxuICAgIGRhdGFIYXNoXG4gIF0pO1xufVxuZnVuY3Rpb24gaGFzaEJ1aWx0aW5zKGJ1aWx0aW5zKSB7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55KFxuICAgIGJ1aWx0aW5zLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgICByZXR1cm4gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKGl0KSk7XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbnRyeVBvaW50KGRhdGEpIHtcbiAgY29uc3QgYmFzZSA9IGRhdGEuZmxhdE1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gW0JpZ0ludChpdC5zZWxlY3RvciksIEJpZ0ludChpdC5vZmZzZXQpLCBoYXNoQnVpbHRpbnMoaXQuYnVpbHRpbnMpXTtcbiAgfSk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55KGJhc2UpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoKGNhc20pIHtcbiAgY29uc3QgQ09NUElMRURfQ0xBU1NfVkVSU0lPTiA9IFwiQ09NUElMRURfQ0xBU1NfVjFcIjtcbiAgY29uc3QgY29tcGlsZWRDbGFzc1ZlcnNpb24gPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoQ09NUElMRURfQ0xBU1NfVkVSU0lPTikpO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuRVhURVJOQUwpO1xuICBjb25zdCBsMUhhbmRsZXJzID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSKTtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SKTtcbiAgY29uc3QgYnl0ZWNvZGUgPSBwb3NlaWRvbkhhc2hNYW55KGNhc20uYnl0ZWNvZGUubWFwKChpdCkgPT4gQmlnSW50KGl0KSkpO1xuICByZXR1cm4gdG9IZXgoXG4gICAgcG9zZWlkb25IYXNoTWFueShbXG4gICAgICBjb21waWxlZENsYXNzVmVyc2lvbixcbiAgICAgIGV4dGVybmFsRW50cnlQb2ludHNIYXNoLFxuICAgICAgbDFIYW5kbGVycyxcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgYnl0ZWNvZGVcbiAgICBdKVxuICApO1xufVxuZnVuY3Rpb24gaGFzaEVudHJ5UG9pbnRTaWVycmEoZGF0YSkge1xuICBjb25zdCBiYXNlID0gZGF0YS5mbGF0TWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBbQmlnSW50KGl0LnNlbGVjdG9yKSwgQmlnSW50KGl0LmZ1bmN0aW9uX2lkeCldO1xuICB9KTtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkoYmFzZSk7XG59XG5mdW5jdGlvbiBoYXNoQWJpKHNpZXJyYSkge1xuICBjb25zdCBpbmRlbnRTdHJpbmcgPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5MihzaWVycmEuYWJpLCBudWxsKSk7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KGluZGVudFN0cmluZykpLnRvU3RyaW5nKDE2KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoKHNpZXJyYSkge1xuICBjb25zdCBDT05UUkFDVF9DTEFTU19WRVJTSU9OID0gXCJDT05UUkFDVF9DTEFTU19WMC4xLjBcIjtcbiAgY29uc3QgY29tcGlsZWRDbGFzc1ZlcnNpb24gPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoQ09OVFJBQ1RfQ0xBU1NfVkVSU0lPTikpO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTCk7XG4gIGNvbnN0IGwxSGFuZGxlcnMgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUik7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SKTtcbiAgY29uc3QgYWJpSGFzaCA9IGhhc2hBYmkoc2llcnJhKTtcbiAgY29uc3Qgc2llcnJhUHJvZ3JhbSA9IHBvc2VpZG9uSGFzaE1hbnkoc2llcnJhLnNpZXJyYV9wcm9ncmFtLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgIHBvc2VpZG9uSGFzaE1hbnkoW1xuICAgICAgY29tcGlsZWRDbGFzc1ZlcnNpb24sXG4gICAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICAgIGwxSGFuZGxlcnMsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGFiaUhhc2gsXG4gICAgICBzaWVycmFQcm9ncmFtXG4gICAgXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb250cmFjdENsYXNzSGFzaChjb250cmFjdCkge1xuICBjb25zdCBjb21waWxlZENvbnRyYWN0ID0gdHlwZW9mIGNvbnRyYWN0ID09PSBcInN0cmluZ1wiID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICBpZiAoXCJzaWVycmFfcHJvZ3JhbVwiIGluIGNvbXBpbGVkQ29udHJhY3QpIHtcbiAgICByZXR1cm4gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG59XG5cbi8vIHNyYy91dGlscy9zdGFyay50c1xudmFyIHN0YXJrX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN0YXJrX2V4cG9ydHMsIHtcbiAgY29tcHJlc3NQcm9ncmFtOiAoKSA9PiBjb21wcmVzc1Byb2dyYW0sXG4gIGRlY29tcHJlc3NQcm9ncmFtOiAoKSA9PiBkZWNvbXByZXNzUHJvZ3JhbSxcbiAgZXN0aW1hdGVkRmVlVG9NYXhGZWU6ICgpID0+IGVzdGltYXRlZEZlZVRvTWF4RmVlLFxuICBmb3JtYXRTaWduYXR1cmU6ICgpID0+IGZvcm1hdFNpZ25hdHVyZSxcbiAgbWFrZUFkZHJlc3M6ICgpID0+IG1ha2VBZGRyZXNzLFxuICByYW5kb21BZGRyZXNzOiAoKSA9PiByYW5kb21BZGRyZXNzLFxuICBzaWduYXR1cmVUb0RlY2ltYWxBcnJheTogKCkgPT4gc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXksXG4gIHNpZ25hdHVyZVRvSGV4QXJyYXk6ICgpID0+IHNpZ25hdHVyZVRvSGV4QXJyYXlcbn0pO1xuaW1wb3J0IHsgZ2V0U3RhcmtLZXksIHV0aWxzIH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuaW1wb3J0IHsgZ3ppcCwgdW5nemlwIH0gZnJvbSBcInBha29cIjtcbmZ1bmN0aW9uIGNvbXByZXNzUHJvZ3JhbShqc29uUHJvZ3JhbSkge1xuICBjb25zdCBzdHJpbmdpZmllZCA9IHR5cGVvZiBqc29uUHJvZ3JhbSA9PT0gXCJzdHJpbmdcIiA/IGpzb25Qcm9ncmFtIDogc3RyaW5naWZ5Mihqc29uUHJvZ3JhbSk7XG4gIGNvbnN0IGNvbXByZXNzZWRQcm9ncmFtID0gZ3ppcChzdHJpbmdpZmllZCk7XG4gIHJldHVybiBidG9hVW5pdmVyc2FsKGNvbXByZXNzZWRQcm9ncmFtKTtcbn1cbmZ1bmN0aW9uIGRlY29tcHJlc3NQcm9ncmFtKGJhc2U2NDIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFzZTY0MikpXG4gICAgcmV0dXJuIGJhc2U2NDI7XG4gIGNvbnN0IGRlY29tcHJlc3NlZCA9IGFycmF5QnVmZmVyVG9TdHJpbmcodW5nemlwKGF0b2JVbml2ZXJzYWwoYmFzZTY0MikpKTtcbiAgcmV0dXJuIHBhcnNlMihkZWNvbXByZXNzZWQpO1xufVxuZnVuY3Rpb24gcmFuZG9tQWRkcmVzcygpIHtcbiAgY29uc3QgcmFuZG9tS2V5UGFpciA9IHV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgcmV0dXJuIGdldFN0YXJrS2V5KHJhbmRvbUtleVBhaXIpO1xufVxuZnVuY3Rpb24gbWFrZUFkZHJlc3MoaW5wdXQpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChpbnB1dCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNpZ25hdHVyZShzaWcpIHtcbiAgaWYgKCFzaWcpXG4gICAgdGhyb3cgRXJyb3IoXCJmb3JtYXRTaWduYXR1cmU6IHByb3ZpZGVkIHNpZ25hdHVyZSBpcyB1bmRlZmluZWRcIik7XG4gIGlmIChBcnJheS5pc0FycmF5KHNpZykpIHtcbiAgICByZXR1cm4gc2lnLm1hcCgoaXQpID0+IHRvSGV4KGl0KSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZztcbiAgICByZXR1cm4gW3RvSGV4KHIpLCB0b0hleChzKV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgbmVlZCB0byBiZSB3ZWllcnN0cmFzcy5TaWduYXR1cmVUeXBlIG9yIGFuIGFycmF5IGZvciBjdXN0b21cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5KHNpZykge1xuICByZXR1cm4gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheShmb3JtYXRTaWduYXR1cmUoc2lnKSk7XG59XG5mdW5jdGlvbiBzaWduYXR1cmVUb0hleEFycmF5KHNpZykge1xuICByZXR1cm4gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkoZm9ybWF0U2lnbmF0dXJlKHNpZykpO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVkRmVlVG9NYXhGZWUoZXN0aW1hdGVkRmVlLCBvdmVyaGVhZCA9IDAuNSkge1xuICBjb25zdCBvdmVySGVhZFBlcmNlbnQgPSBNYXRoLnJvdW5kKCgxICsgb3ZlcmhlYWQpICogMTAwKTtcbiAgcmV0dXJuIHRvQmlnSW50KGVzdGltYXRlZEZlZSkgKiB0b0JpZ0ludChvdmVySGVhZFBlcmNlbnQpIC8gMTAwbjtcbn1cblxuLy8gc3JjL3V0aWxzL2NvbnRyYWN0LnRzXG5mdW5jdGlvbiBpc1NpZXJyYShjb250cmFjdCkge1xuICBjb25zdCBjb21waWxlZENvbnRyYWN0ID0gdHlwZW9mIGNvbnRyYWN0ID09PSBcInN0cmluZ1wiID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICByZXR1cm4gXCJzaWVycmFfcHJvZ3JhbVwiIGluIGNvbXBpbGVkQ29udHJhY3Q7XG59XG5mdW5jdGlvbiBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCkge1xuICBjb25zdCByZXNwb25zZSA9IHsgLi4ucGF5bG9hZCB9O1xuICBpZiAoaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkpIHtcbiAgICBpZiAoIXBheWxvYWQuY29tcGlsZWRDbGFzc0hhc2ggJiYgcGF5bG9hZC5jYXNtKSB7XG4gICAgICByZXNwb25zZS5jb21waWxlZENsYXNzSGFzaCA9IGNvbXB1dGVDb21waWxlZENsYXNzSGFzaChwYXlsb2FkLmNhc20pO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmNvbXBpbGVkQ2xhc3NIYXNoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4dHJhY3QgY29tcGlsZWRDbGFzc0hhc2ggZmFpbGVkLCBwcm92aWRlIChDYWlyb0Fzc2VtYmx5KS5jYXNtIGZpbGUgb3IgY29tcGlsZWRDbGFzc0hhc2hcIlxuICAgICAgKTtcbiAgfVxuICByZXNwb25zZS5jbGFzc0hhc2ggPSBwYXlsb2FkLmNsYXNzSGFzaCA/PyBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2gocGF5bG9hZC5jb250cmFjdCk7XG4gIGlmICghcmVzcG9uc2UuY2xhc3NIYXNoKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4dHJhY3QgY2xhc3NIYXNoIGZhaWxlZCwgcHJvdmlkZSAoQ29tcGlsZWRDb250cmFjdCkuanNvbiBmaWxlIG9yIGNsYXNzSGFzaFwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gY29udHJhY3RDbGFzc1Jlc3BvbnNlVG9MZWdhY3lDb21waWxlZENvbnRyYWN0KGNjcikge1xuICBpZiAoaXNTaWVycmEoY2NyKSkge1xuICAgIHRocm93IEVycm9yKFwiQ29udHJhY3RDbGFzc1Jlc3BvbnNlIG5lZWQgdG8gYmUgTGVnYWN5Q29udHJhY3RDbGFzcyAoY2Fpcm8wIHJlc3BvbnNlIGNsYXNzKVwiKTtcbiAgfVxuICBjb25zdCBjb250cmFjdCA9IGNjcjtcbiAgcmV0dXJuIHsgLi4uY29udHJhY3QsIHByb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnByb2dyYW0pIH07XG59XG5cbi8vIHNyYy91dGlscy9mZXRjaFBvbnlmaWxsLnRzXG5pbXBvcnQgaXNvbW9ycGhpY0ZldGNoIGZyb20gXCJpc29tb3JwaGljLWZldGNoXCI7XG52YXIgZmV0Y2hQb255ZmlsbF9kZWZhdWx0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZmV0Y2ggfHwgLy8gdXNlIGJ1aWxkaW4gZmV0Y2ggaW4gYnJvd3NlciBpZiBhdmFpbGFibGVcbnR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmZldGNoIHx8IC8vIHVzZSBidWlsZGluIGZldGNoIGluIG5vZGUsIHJlYWN0LW5hdGl2ZSBhbmQgc2VydmljZSB3b3JrZXIgaWYgYXZhaWxhYmxlXG5pc29tb3JwaGljRmV0Y2g7XG5cbi8vIHNyYy91dGlscy9wcm92aWRlci50c1xudmFyIHByb3ZpZGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHByb3ZpZGVyX2V4cG9ydHMsIHtcbiAgY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzczogKCkgPT4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyxcbiAgcGFyc2VDb250cmFjdDogKCkgPT4gcGFyc2VDb250cmFjdCxcbiAgd2FpdDogKCkgPT4gd2FpdFxufSk7XG5mdW5jdGlvbiB3YWl0KGRlbGF5KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgc2V0VGltZW91dChyZXMsIGRlbGF5KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzKGNvbnRyYWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uY29udHJhY3QgfTtcbiAgZGVsZXRlIHJlc3VsdC5zaWVycmFfcHJvZ3JhbV9kZWJ1Z19pbmZvO1xuICByZXN1bHQuYWJpID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3QuYWJpKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGNvbXByZXNzUHJvZ3JhbShyZXN1bHQuc2llcnJhX3Byb2dyYW0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VDb250cmFjdChjb250cmFjdCkge1xuICBjb25zdCBwYXJzZWRDb250cmFjdCA9IHR5cGVvZiBjb250cmFjdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKCFpc1NpZXJyYShjb250cmFjdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkQ29udHJhY3QsXG4gICAgICAuLi5cInByb2dyYW1cIiBpbiBwYXJzZWRDb250cmFjdCAmJiB7IHByb2dyYW06IGNvbXByZXNzUHJvZ3JhbShwYXJzZWRDb250cmFjdC5wcm9ncmFtKSB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyhwYXJzZWRDb250cmFjdCk7XG59XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9ycGMudHNcbnZhciBSUENSZXNwb25zZVBhcnNlciA9IGNsYXNzIHtcbiAgcGFyc2VHZXRCbG9ja1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lc3RhbXA6IHJlcy50aW1lc3RhbXAsXG4gICAgICBibG9ja19oYXNoOiBcImJsb2NrX2hhc2hcIiBpbiByZXMgPyByZXMuYmxvY2tfaGFzaCA6IFwiXCIsXG4gICAgICBibG9ja19udW1iZXI6IFwiYmxvY2tfbnVtYmVyXCIgaW4gcmVzID8gcmVzLmJsb2NrX251bWJlciA6IC0xLFxuICAgICAgbmV3X3Jvb3Q6IFwibmV3X3Jvb3RcIiBpbiByZXMgPyByZXMubmV3X3Jvb3QgOiBcIlwiLFxuICAgICAgcGFyZW50X2hhc2g6IHJlcy5wYXJlbnRfaGFzaCxcbiAgICAgIHN0YXR1czogXCJzdGF0dXNcIiBpbiByZXMgPyByZXMuc3RhdHVzIDogXCJQRU5ESU5HXCIgLyogUEVORElORyAqLyxcbiAgICAgIHRyYW5zYWN0aW9uczogcmVzLnRyYW5zYWN0aW9uc1xuICAgIH07XG4gIH1cbiAgcGFyc2VHZXRUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICBjYWxsZGF0YTogXCJjYWxsZGF0YVwiIGluIHJlcyA/IHJlcy5jYWxsZGF0YSA6IFtdLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogXCJjb250cmFjdF9hZGRyZXNzXCIgaW4gcmVzID8gcmVzLmNvbnRyYWN0X2FkZHJlc3MgOiBcIlwiLFxuICAgICAgc2VuZGVyX2FkZHJlc3M6IFwic2VuZGVyX2FkZHJlc3NcIiBpbiByZXMgPyByZXMuc2VuZGVyX2FkZHJlc3MgOiBcIlwiLFxuICAgICAgbWF4X2ZlZTogXCJtYXhfZmVlXCIgaW4gcmVzID8gcmVzLm1heF9mZWUgOiBcIlwiLFxuICAgICAgbm9uY2U6IFwibm9uY2VcIiBpbiByZXMgPyByZXMubm9uY2UgOiBcIlwiLFxuICAgICAgc2lnbmF0dXJlOiBcInNpZ25hdHVyZVwiIGluIHJlcyA/IHJlcy5zaWduYXR1cmUgOiBbXSxcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IHJlcy50cmFuc2FjdGlvbl9oYXNoLFxuICAgICAgdmVyc2lvbjogcmVzLnZlcnNpb25cbiAgICB9O1xuICB9XG4gIHBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHJlc1swXS5vdmVyYWxsX2ZlZSksXG4gICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHJlc1swXS5nYXNfY29uc3VtZWQpLFxuICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludChyZXNbMF0uZ2FzX3ByaWNlKVxuICAgIH07XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZUJ1bGtSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gcmVzLm1hcCgodmFsKSA9PiAoe1xuICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHZhbC5nYXNfY29uc3VtZWQpLFxuICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludCh2YWwuZ2FzX3ByaWNlKVxuICAgIH0pKTtcbiAgfVxuICBwYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHJlc1xuICAgIH07XG4gIH1cbiAgcGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHJlcy5tYXAoKGl0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pdCxcbiAgICAgICAgc3VnZ2VzdGVkTWF4RmVlOiBlc3RpbWF0ZWRGZWVUb01heEZlZShCaWdJbnQoaXQuZmVlX2VzdGltYXRpb24ub3ZlcmFsbF9mZWUpKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBwYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzLFxuICAgICAgYWJpOiB0eXBlb2YgcmVzLmFiaSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UocmVzLmFiaSkgOiByZXMuYWJpXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2Vycm9ycy50c1xuZnVuY3Rpb24gZml4U3RhY2sodGFyZ2V0LCBmbiA9IHRhcmdldC5jb25zdHJ1Y3Rvcikge1xuICBjb25zdCB7IGNhcHR1cmVTdGFja1RyYWNlIH0gPSBFcnJvcjtcbiAgY2FwdHVyZVN0YWNrVHJhY2UgJiYgY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0LCBmbik7XG59XG5mdW5jdGlvbiBmaXhQcm90byh0YXJnZXQsIHByb3RvdHlwZSkge1xuICBjb25zdCB7IHNldFByb3RvdHlwZU9mIH0gPSBPYmplY3Q7XG4gIHNldFByb3RvdHlwZU9mID8gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90b3R5cGUpIDogdGFyZ2V0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbn1cbnZhciBDdXN0b21FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICB2YWx1ZTogbmV3LnRhcmdldC5uYW1lLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBmaXhQcm90byh0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgZml4U3RhY2sodGhpcyk7XG4gIH1cbn07XG52YXIgTGlicmFyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBDdXN0b21FcnJvciB7XG59O1xudmFyIEdhdGV3YXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgTGlicmFyeUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JDb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gIH1cbn07XG52YXIgSHR0cEVycm9yID0gY2xhc3MgZXh0ZW5kcyBMaWJyYXJ5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3N0YXJrbmV0SWQudHNcbnZhciBzdGFya25ldElkX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN0YXJrbmV0SWRfZXhwb3J0cywge1xuICBTdGFya25ldElkQ29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRDb250cmFjdCxcbiAgZ2V0U3RhcmtuZXRJZENvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkQ29udHJhY3QsXG4gIHVzZURlY29kZWQ6ICgpID0+IHVzZURlY29kZWQsXG4gIHVzZUVuY29kZWQ6ICgpID0+IHVzZUVuY29kZWRcbn0pO1xudmFyIGJhc2ljQWxwaGFiZXQgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1cIjtcbnZhciBiYXNpY1NpemVQbHVzT25lID0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoICsgMSk7XG52YXIgYmlnQWxwaGFiZXQgPSBcIlxcdThGRDlcXHU2NzY1XCI7XG52YXIgYmFzaWNBbHBoYWJldFNpemUgPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGgpO1xudmFyIGJpZ0FscGhhYmV0U2l6ZSA9IEJpZ0ludChiaWdBbHBoYWJldC5sZW5ndGgpO1xudmFyIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmUgPSBCaWdJbnQoYmlnQWxwaGFiZXQubGVuZ3RoICsgMSk7XG5mdW5jdGlvbiBleHRyYWN0U3RhcnMoc3RyKSB7XG4gIGxldCBrID0gMDtcbiAgd2hpbGUgKHN0ci5lbmRzV2l0aChiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXSkpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICBrICs9IDE7XG4gIH1cbiAgcmV0dXJuIFtzdHIsIGtdO1xufVxuZnVuY3Rpb24gdXNlRGVjb2RlZChlbmNvZGVkKSB7XG4gIGxldCBkZWNvZGVkID0gXCJcIjtcbiAgZW5jb2RlZC5mb3JFYWNoKChzdWJkb21haW4pID0+IHtcbiAgICB3aGlsZSAoc3ViZG9tYWluICE9PSBaRVJPKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3ViZG9tYWluICUgYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIHN1YmRvbWFpbiAvPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgaWYgKGNvZGUgPT09IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCkpIHtcbiAgICAgICAgY29uc3QgbmV4dFN1YmRvbWFpbiA9IHN1YmRvbWFpbiAvIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmU7XG4gICAgICAgIGlmIChuZXh0U3ViZG9tYWluID09PSBaRVJPKSB7XG4gICAgICAgICAgY29uc3QgY29kZTIgPSBzdWJkb21haW4gJSBiaWdBbHBoYWJldFNpemVQbHVzT25lO1xuICAgICAgICAgIHN1YmRvbWFpbiA9IG5leHRTdWJkb21haW47XG4gICAgICAgICAgaWYgKGNvZGUyID09PSBaRVJPKVxuICAgICAgICAgICAgZGVjb2RlZCArPSBiYXNpY0FscGhhYmV0WzBdO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlY29kZWQgKz0gYmlnQWxwaGFiZXRbTnVtYmVyKGNvZGUyKSAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNvZGUyID0gc3ViZG9tYWluICUgYmlnQWxwaGFiZXRTaXplO1xuICAgICAgICAgIGRlY29kZWQgKz0gYmlnQWxwaGFiZXRbTnVtYmVyKGNvZGUyKV07XG4gICAgICAgICAgc3ViZG9tYWluIC89IGJpZ0FscGhhYmV0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGRlY29kZWQgKz0gYmFzaWNBbHBoYWJldFtOdW1iZXIoY29kZSldO1xuICAgIH1cbiAgICBjb25zdCBbc3RyLCBrXSA9IGV4dHJhY3RTdGFycyhkZWNvZGVkKTtcbiAgICBpZiAoaylcbiAgICAgIGRlY29kZWQgPSBzdHIgKyAoayAlIDIgPT09IDAgPyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoayAvIDIgLSAxKSArIGJpZ0FscGhhYmV0WzBdICsgYmFzaWNBbHBoYWJldFsxXSA6IGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgoayAtIDEpIC8gMiArIDEpKTtcbiAgICBkZWNvZGVkICs9IFwiLlwiO1xuICB9KTtcbiAgaWYgKCFkZWNvZGVkKSB7XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbiAgcmV0dXJuIGRlY29kZWQuY29uY2F0KFwic3RhcmtcIik7XG59XG5mdW5jdGlvbiB1c2VFbmNvZGVkKGRlY29kZWQpIHtcbiAgbGV0IGVuY29kZWQgPSBCaWdJbnQoMCk7XG4gIGxldCBtdWx0aXBsaWVyID0gQmlnSW50KDEpO1xuICBpZiAoZGVjb2RlZC5lbmRzV2l0aChiaWdBbHBoYWJldFswXSArIGJhc2ljQWxwaGFiZXRbMV0pKSB7XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZC5zdWJzdHJpbmcoMCwgZGVjb2RlZC5sZW5ndGggLSAyKSk7XG4gICAgZGVjb2RlZCA9IHN0ciArIGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgyICogKGsgKyAxKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZCk7XG4gICAgaWYgKGspXG4gICAgICBkZWNvZGVkID0gc3RyICsgYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KDEgKyAyICogKGsgLSAxKSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IGRlY29kZWRbaV07XG4gICAgY29uc3QgaW5kZXggPSBiYXNpY0FscGhhYmV0LmluZGV4T2YoY2hhcik7XG4gICAgY29uc3QgYm5JbmRleCA9IEJpZ0ludChiYXNpY0FscGhhYmV0LmluZGV4T2YoY2hhcikpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChpID09PSBkZWNvZGVkLmxlbmd0aCAtIDEgJiYgZGVjb2RlZFtpXSA9PT0gYmFzaWNBbHBoYWJldFswXSkge1xuICAgICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBiYXNpY0FscGhhYmV0U2l6ZTtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBibkluZGV4O1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiaWdBbHBoYWJldC5pbmRleE9mKGNoYXIpICE9PSAtMSkge1xuICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYmFzaWNBbHBoYWJldFNpemU7XG4gICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBjb25zdCBuZXdpZCA9IChpID09PSBkZWNvZGVkLmxlbmd0aCAtIDEgPyAxIDogMCkgKyBiaWdBbHBoYWJldC5pbmRleE9mKGNoYXIpO1xuICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogQmlnSW50KG5ld2lkKTtcbiAgICAgIG11bHRpcGxpZXIgKj0gYmlnQWxwaGFiZXRTaXplO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cbnZhciBTdGFya25ldElkQ29udHJhY3QgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldElkQ29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRDb250cmFjdDJbXCJNQUlOTkVUXCJdID0gXCIweDZhYzU5N2Y4MTE2Zjg4NmZhMWM5N2EyM2ZhNGUwODI5OTk3NWVjYWY2YjU5ODg3M2NhNjc5MmI5YmJmYjY3OFwiO1xuICBTdGFya25ldElkQ29udHJhY3QyW1wiVEVTVE5FVFwiXSA9IFwiMHgzYmFiMjY4ZTkzMmQyY2VjZDE5NDZmMTAwYWU2N2NlM2RmZjlmZDIzNDExOWVhMmY2ZGE1N2QxNmQyOWZjZVwiO1xuICByZXR1cm4gU3RhcmtuZXRJZENvbnRyYWN0Mjtcbn0pKFN0YXJrbmV0SWRDb250cmFjdCB8fCB7fSk7XG5mdW5jdGlvbiBnZXRTdGFya25ldElkQ29udHJhY3QoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICByZXR1cm4gXCIweDZhYzU5N2Y4MTE2Zjg4NmZhMWM5N2EyM2ZhNGUwODI5OTk3NWVjYWY2YjU5ODg3M2NhNjc5MmI5YmJmYjY3OFwiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovOlxuICAgICAgcmV0dXJuIFwiMHgzYmFiMjY4ZTkzMmQyY2VjZDE5NDZmMTAwYWU2N2NlM2RmZjlmZDIzNDExOWVhMmY2ZGE1N2QxNmQyOWZjZVwiIC8qIFRFU1RORVQgKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCIpO1xuICB9XG59XG5cbi8vIHNyYy9wcm92aWRlci9zdGFya25ldElkLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRTdGFya05hbWUocHJvdmlkZXIsIGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBoZXhEb21haW4gPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdCxcbiAgICAgIGVudHJ5cG9pbnQ6IFwiYWRkcmVzc190b19kb21haW5cIixcbiAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgYWRkcmVzc1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCBkZWNpbWFsRG9tYWluID0gaGV4RG9tYWluLnJlc3VsdC5tYXAoKGVsZW1lbnQpID0+IEJpZ0ludChlbGVtZW50KSkuc2xpY2UoMSk7XG4gICAgY29uc3Qgc3RyaW5nRG9tYWluID0gdXNlRGVjb2RlZChkZWNpbWFsRG9tYWluKTtcbiAgICBpZiAoIXN0cmluZ0RvbWFpbikge1xuICAgICAgdGhyb3cgRXJyb3IoXCJTdGFya25hbWUgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nRG9tYWluO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UgPT09IFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgc3RhcmsgbmFtZVwiKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUocHJvdmlkZXIsIG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBhZGRyZXNzRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmNhbGxDb250cmFjdCh7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0LFxuICAgICAgZW50cnlwb2ludDogXCJkb21haW5fdG9fYWRkcmVzc1wiLFxuICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICBkb21haW46IFt1c2VFbmNvZGVkKG5hbWUucmVwbGFjZShcIi5zdGFya1wiLCBcIlwiKSkudG9TdHJpbmcoMTApXVxuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gYWRkcmVzc0RhdGEucmVzdWx0WzBdO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgYWRkcmVzcyBmcm9tIHN0YXJrIG5hbWVcIik7XG4gIH1cbn1cblxuLy8gc3JjL3Byb3ZpZGVyL3V0aWxzLnRzXG52YXIgdmFsaWRCbG9ja1RhZ3MgPSBPYmplY3QudmFsdWVzKEJsb2NrVGFnKTtcbnZhciBCbG9jayA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX2lkZW50aWZpZXIpIHtcbiAgICB0aGlzLmhhc2ggPSBudWxsO1xuICAgIHRoaXMubnVtYmVyID0gbnVsbDtcbiAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgdGhpcy52YWx1ZU9mID0gKCkgPT4gdGhpcy5udW1iZXI7XG4gICAgdGhpcy50b1N0cmluZyA9ICgpID0+IHRoaXMuaGFzaDtcbiAgICB0aGlzLnNldElkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICB9XG4gIHNldElkZW50aWZpZXIoX19pZGVudGlmaWVyKSB7XG4gICAgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwic3RyaW5nXCIgJiYgaXNIZXgoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy5oYXNoID0gX19pZGVudGlmaWVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF9faWRlbnRpZmllciA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgdGhpcy5oYXNoID0gdG9IZXgoX19pZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMubnVtYmVyID0gX19pZGVudGlmaWVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF9faWRlbnRpZmllciA9PT0gXCJzdHJpbmdcIiAmJiB2YWxpZEJsb2NrVGFncy5pbmNsdWRlcyhfX2lkZW50aWZpZXIpKSB7XG4gICAgICB0aGlzLnRhZyA9IF9faWRlbnRpZmllcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWcgPSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovO1xuICAgIH1cbiAgfVxuICAvLyBUT0RPOiBmaXggYW55XG4gIGdldCBxdWVyeUlkZW50aWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubnVtYmVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYGJsb2NrTnVtYmVyPSR7dGhpcy5udW1iZXJ9YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGBibG9ja0hhc2g9JHt0aGlzLmhhc2h9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBibG9ja051bWJlcj0ke3RoaXMudGFnfWA7XG4gIH1cbiAgLy8gVE9ETzogZml4IGFueVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICBpZiAodGhpcy5udW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGJsb2NrX251bWJlcjogdGhpcy5udW1iZXIgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgYmxvY2tfaGFzaDogdGhpcy5oYXNoIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZztcbiAgfVxuICBzZXQgaWRlbnRpZmllcihfaWRlbnRpZmllcikge1xuICAgIHRoaXMuc2V0SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gIH1cbiAgZ2V0IHNlcXVlbmNlcklkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzaCAhPT0gbnVsbCA/IHsgYmxvY2tIYXNoOiB0aGlzLmhhc2ggfSA6IHsgYmxvY2tOdW1iZXI6IHRoaXMubnVtYmVyID8/IHRoaXMudGFnIH07XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9ycGMudHNcbnZhciBnZXREZWZhdWx0Tm9kZVVybCA9IChuZXR3b3JrTmFtZSwgbXV0ZSA9IGZhbHNlLCB2ZXJzaW9uID0gUlBDX0RFRkFVTFRfVkVSU0lPTikgPT4ge1xuICBpZiAoIW11dGUpXG4gICAgY29uc29sZS53YXJuKFwiVXNpbmcgZGVmYXVsdCBwdWJsaWMgbm9kZSB1cmwsIHBsZWFzZSBwcm92aWRlIG5vZGVVcmwgaW4gcHJvdmlkZXIgb3B0aW9ucyFcIik7XG4gIGNvbnN0IG5vZGVzID0gUlBDX05PREVTW25ldHdvcmtOYW1lID8/IFwiU05fR09FUkxJXCIgLyogU05fR09FUkxJICovXTtcbiAgY29uc3QgcmFuZElkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCk7XG4gIHJldHVybiBgJHtub2Rlc1tyYW5kSWR4XX0ke3ZlcnNpb259YDtcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgYmxvY2tJZGVudGlmaWVyOiBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovLFxuICByZXRyaWVzOiAyMDBcbn07XG52YXIgUnBjUHJvdmlkZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgdGhpcy5yZXNwb25zZVBhcnNlciA9IG5ldyBSUENSZXNwb25zZVBhcnNlcigpO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpOyAod2lsbCBiZSByZW1vdmVkIGluIG5leHQgbWlub3IgdmVyc2lvbilcbiAgICAgKi9cbiAgICB0aGlzLmdldEJsb2NrSGFzaEFuZE51bWJlciA9IHRoaXMuZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZDtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIGdldEJsb2NrU3RhdGVVcGRhdGUoKTtcbiAgICAgKi9cbiAgICB0aGlzLmdldFN0YXRlVXBkYXRlID0gdGhpcy5nZXRCbG9ja1N0YXRlVXBkYXRlO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV4ZWN1dGlvbiB0cmFjZXMgb2YgYWxsIHRyYW5zYWN0aW9ucyBpbmNsdWRlZCBpbiB0aGUgZ2l2ZW4gYmxvY2tcbiAgICAgKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIGdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKClcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNlQmxvY2tUcmFuc2FjdGlvbnMgPSB0aGlzLmdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBpbiBhIGJsb2NrIGdpdmVuIGEgYmxvY2sgaWRcbiAgICAgKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCgpXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIHRyYW5zYWN0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudCA9IHRoaXMuZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gZ2V0VHJhbnNhY3Rpb25UcmFjZSgpO1xuICAgICAqIEZvciBhIGdpdmVuIGV4ZWN1dGVkIHRyYW5zYWN0aW9uLCByZXR1cm4gdGhlIHRyYWNlIG9mIGl0cyBleGVjdXRpb24sIGluY2x1ZGluZyBpbnRlcm5hbCBjYWxsc1xuICAgICAqL1xuICAgIHRoaXMudHJhY2VUcmFuc2FjdGlvbiA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25UcmFjZTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIHNpbXVsYXRlVHJhbnNhY3Rpb24oKTtcbiAgICAgKi9cbiAgICB0aGlzLmdldFNpbXVsYXRlVHJhbnNhY3Rpb24gPSB0aGlzLnNpbXVsYXRlVHJhbnNhY3Rpb247XG4gICAgY29uc3QgeyBub2RlVXJsLCByZXRyaWVzLCBoZWFkZXJzLCBibG9ja0lkZW50aWZpZXIsIGNoYWluSWQsIHJwY1ZlcnNpb24gfSA9IG9wdGlvbnNPclByb3ZpZGVyIHx8IHt9O1xuICAgIGlmIChPYmplY3QudmFsdWVzKE5ldHdvcmtOYW1lKS5pbmNsdWRlcyhub2RlVXJsKSkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwoXG4gICAgICAgIG5vZGVVcmwsXG4gICAgICAgIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0LFxuICAgICAgICBycGNWZXJzaW9uXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobm9kZVVybCkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gbm9kZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwodm9pZCAwLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCwgcnBjVmVyc2lvbik7XG4gICAgfVxuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXMgfHwgZGVmYXVsdE9wdGlvbnMucmV0cmllcztcbiAgICB0aGlzLmhlYWRlcnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLmhlYWRlcnMsIC4uLmhlYWRlcnMgfTtcbiAgICB0aGlzLmJsb2NrSWRlbnRpZmllciA9IGJsb2NrSWRlbnRpZmllciB8fCBkZWZhdWx0T3B0aW9ucy5ibG9ja0lkZW50aWZpZXI7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgY29uc3QgcnBjUmVxdWVzdEJvZHkgPSB7XG4gICAgICBpZCxcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICBtZXRob2QsXG4gICAgICAuLi5wYXJhbXMgJiYgeyBwYXJhbXMgfVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoUG9ueWZpbGxfZGVmYXVsdCh0aGlzLm5vZGVVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBzdHJpbmdpZnkyKHJwY1JlcXVlc3RCb2R5KSxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgIH0pO1xuICB9XG4gIGVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgcnBjRXJyb3IsIG90aGVyRXJyb3IpIHtcbiAgICBpZiAocnBjRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gcnBjRXJyb3I7XG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKFxuICAgICAgICBgUlBDOiAke21ldGhvZH0gd2l0aCBwYXJhbXMgJHtzdHJpbmdpZnkyKHBhcmFtcyl9XG4gJHtjb2RlfTogJHttZXNzYWdlfTogJHtzdHJpbmdpZnkyKGRhdGEpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yIGluc3RhbmNlb2YgTGlicmFyeUVycm9yKSB7XG4gICAgICB0aHJvdyBvdGhlckVycm9yO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvcikge1xuICAgICAgdGhyb3cgRXJyb3Iob3RoZXJFcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmV0Y2hFbmRwb2ludChtZXRob2QsIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgIGNvbnN0IHsgZXJyb3IsIHJlc3VsdCB9ID0gYXdhaXQgcmF3UmVzdWx0Lmpzb24oKTtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3I/LnJlc3BvbnNlPy5kYXRhLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICB0aGlzLmNoYWluSWQgPz8gKHRoaXMuY2hhaW5JZCA9IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2NoYWluSWRcIikpO1xuICAgIHJldHVybiB0aGlzLmNoYWluSWQ7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGUgU3RhcmtuZXQgSlNPTi1SUEMgc3BlY2lmaWNhdGlvbiBiZWluZyB1c2VkXG4gICAqL1xuICBhc3luYyBnZXRTcGVjVmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3BlY1ZlcnNpb25cIik7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldE5vbmNlXCIsIHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZ2V0QmxvY2tXaXRoVHhIYXNoZXMgb3IgZ2V0QmxvY2tXaXRoVHhzICh3aWxsIGJlIHJlbW92ZWQgb24gc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2soYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0QmxvY2tSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgaGFzaCBhbmQgbnVtYmVyXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9ibG9ja0hhc2hBbmROdW1iZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHJlZHVuZGFudCB1c2UgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpO1xuICAgKiBHZXQgdGhlIG1vc3QgcmVjZW50IGFjY2VwdGVkIGJsb2NrIG51bWJlclxuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdGhlIGxhdGVzdCBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrTnVtYmVyXCIpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeEhhc2hlc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFR4cyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoVHhzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RhdGVVcGRhdGVcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VCbG9ja1RyYW5zYWN0aW9uc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50XCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0cmFuc2FjdGlvbnMgZnJvbSBwZW5kaW5nIGJsb2NrXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQgdXNlIGdldEJsb2NrKEJsb2NrVGFnLnBlbmRpbmcpOyAod2lsbCBiZSByZW1vdmVkIGluIG5leHQgbWlub3IgdmVyc2lvbilcbiAgICovXG4gIGFzeW5jIGdldFBlbmRpbmdUcmFuc2FjdGlvbnMoKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IGF3YWl0IHRoaXMuZ2V0QmxvY2soXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLyk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmdldFRyYW5zYWN0aW9uQnlIYXNoKGl0KSkpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZ2V0VHJhbnNhY3Rpb25CeUhhc2ggb3IgZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleCAod2lsbCBiZSByZW1vdmVkIG9uIHNlcXVlbmNlciBkZXByZWNhdGlvbilcbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2hcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXhcIiwgeyBibG9ja19pZCwgaW5kZXggfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uVHJhY2UodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3RyYWNlVHJhbnNhY3Rpb25cIiwgeyB0cmFuc2FjdGlvbl9oYXNoIH0pO1xuICB9XG4gIC8qKlxuICAgKiBORVc6IEdldCB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblN0YXR1c1wiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zIGJsb2NrSWRlbnRpZmllciBhbmQgZmxhZ3MgdG8gc2tpcCB2YWxpZGF0aW9uIGFuZCBmZWUgY2hhcmdlPGJyLz5cbiAgICogLSBibG9ja0lkZW50aWZpZXI8YnIvPlxuICAgKiAtIHNraXBWYWxpZGF0ZSAoZGVmYXVsdCBmYWxzZSk8YnIvPlxuICAgKiAtIHNraXBGZWVDaGFyZ2UgKGRlZmF1bHQgdHJ1ZSk8YnIvPlxuICAgKi9cbiAgYXN5bmMgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywge1xuICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLFxuICAgIHNraXBWYWxpZGF0ZSA9IGZhbHNlLFxuICAgIHNraXBGZWVDaGFyZ2UgPSB0cnVlXG4gIH0pIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3Qgc2ltdWxhdGlvbkZsYWdzID0gW107XG4gICAgaWYgKHNraXBWYWxpZGF0ZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKHJwY19leHBvcnRzLkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFKTtcbiAgICBpZiAoc2tpcEZlZUNoYXJnZSlcbiAgICAgIHNpbXVsYXRpb25GbGFncy5wdXNoKHJwY19leHBvcnRzLkVTaW11bGF0aW9uRmxhZy5TS0lQX0ZFRV9DSEFSR0UpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zaW11bGF0ZVRyYW5zYWN0aW9uc1wiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIHRyYW5zYWN0aW9uczogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0KSksXG4gICAgICBzaW11bGF0aW9uX2ZsYWdzOiBzaW11bGF0aW9uRmxhZ3NcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIGxldCB7IHJldHJpZXMgfSA9IHRoaXM7XG4gICAgbGV0IG9uY2hhaW4gPSBmYWxzZTtcbiAgICBsZXQgaXNFcnJvclN0YXRlID0gZmFsc2U7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IG9wdGlvbnM/LnJldHJ5SW50ZXJ2YWwgPz8gNWUzO1xuICAgIGNvbnN0IGVycm9yU3RhdGVzID0gb3B0aW9ucz8uZXJyb3JTdGF0ZXMgPz8gW1xuICAgICAgcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uU3RhdHVzLlJFSkVDVEVEXG4gICAgICAvLyBUT0RPOiBjb21tZW50ZWQgb3V0IHRvIHByZXNlcnZlIHRoZSBsb25nLXN0YW5kaW5nIGJlaGF2aW9yIG9mIFwicmV2ZXJ0ZWRcIiBub3QgYmVpbmcgdHJlYXRlZCBhcyBhbiBlcnJvciBieSBkZWZhdWx0XG4gICAgICAvLyBzaG91bGQgZGVjaWRlIHdoaWNoIGJlaGF2aW9yIHRvIGtlZXAgaW4gdGhlIGZ1dHVyZVxuICAgICAgLy8gUlBDLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5SRVZFUlRFRCxcbiAgICBdO1xuICAgIGNvbnN0IHN1Y2Nlc3NTdGF0ZXMgPSBvcHRpb25zPy5zdWNjZXNzU3RhdGVzID8/IFtcbiAgICAgIHJwY19leHBvcnRzLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5TVUNDRUVERUQsXG4gICAgICBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDIsXG4gICAgICBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDFcbiAgICBdO1xuICAgIGxldCB0eFN0YXR1cztcbiAgICB3aGlsZSAoIW9uY2hhaW4pIHtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICB0eFN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uU3RhdHVzID0gdHhTdGF0dXMuZXhlY3V0aW9uX3N0YXR1cztcbiAgICAgICAgY29uc3QgZmluYWxpdHlTdGF0dXMgPSB0eFN0YXR1cy5maW5hbGl0eV9zdGF0dXM7XG4gICAgICAgIGlmICghZmluYWxpdHlTdGF0dXMpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIndhaXRpbmcgZm9yIHRyYW5zYWN0aW9uIHN0YXR1c1wiKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBlcnJvclN0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7ZXhlY3V0aW9uU3RhdHVzfTogJHtmaW5hbGl0eVN0YXR1c31gO1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gdHhTdGF0dXM7XG4gICAgICAgICAgaXNFcnJvclN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBlbHNlIGlmIChzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhmaW5hbGl0eVN0YXR1cykpIHtcbiAgICAgICAgICBvbmNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgaXNFcnJvclN0YXRlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICB9XG4gICAgbGV0IHR4UmVjZWlwdCA9IG51bGw7XG4gICAgd2hpbGUgKHR4UmVjZWlwdCA9PT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdHhSZWNlaXB0O1xuICB9XG4gIGFzeW5jIGdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBwYXJzZWRLZXkgPSB0b1N0b3JhZ2VLZXkoa2V5KTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFN0b3JhZ2VBdFwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAga2V5OiBwYXJzZWRLZXksXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzSGFzaEF0XCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgY29udHJhY3RfYWRkcmVzc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCkge1xuICAgIHJldHVybiB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNsYXNzX2hhc2ggPSB0b0hleChjbGFzc0hhc2gpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NcIiwge1xuICAgICAgY2xhc3NfaGFzaCxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKF9jb250cmFjdEFkZHJlc3MsIF9ibG9ja0lkZW50aWZpZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSUEMgZG9lcyBub3QgaW1wbGVtZW50IGdldENvZGUgZnVuY3Rpb25cIik7XG4gIH1cbiAgYXN5bmMgZ2V0Q29udHJhY3RWZXJzaW9uKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCB7IGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBjb21waWxlciA9IHRydWUgfSA9IHt9KSB7XG4gICAgbGV0IGNvbnRyYWN0Q2xhc3M7XG4gICAgaWYgKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmIChjbGFzc0hhc2gpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJnZXRDb250cmFjdFZlcnNpb24gcmVxdWlyZSBjb250cmFjdEFkZHJlc3Mgb3IgY2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBpZiAoaXNTaWVycmEoY29udHJhY3RDbGFzcykpIHtcbiAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICBjb25zdCBhYmlUZXN0ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGNvbnRyYWN0Q2xhc3MuYWJpKTtcbiAgICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogYWJpVGVzdC5jb21waWxlciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogdm9pZCAwIH07XG4gICAgfVxuICAgIHJldHVybiB7IGNhaXJvOiBcIjBcIiwgY29tcGlsZXI6IFwiMFwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXQqdHlwZSpFc3RpbWF0ZUZlZSAod2lsbCBiZSByZWZhY3RvcmVkIGJhc2VkIG9uIHR5cGUgYWZ0ZXIgc2VxdWVuY2VyIGRlcHJlY2F0aW9uKVxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgLi4uaW52b2NhdGlvbkRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogW3RyYW5zYWN0aW9uXSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVjbGFyZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlRmVlXCIsIHtcbiAgICAgIHJlcXVlc3Q6IFt0cmFuc2FjdGlvbl0sXG4gICAgICBibG9ja19pZFxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlRmVlXCIsIHtcbiAgICAgIHJlcXVlc3Q6IFt0cmFuc2FjdGlvbl0sXG4gICAgICBibG9ja19pZFxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UgfSkge1xuICAgIGlmIChza2lwVmFsaWRhdGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImdldEVzdGltYXRlRmVlQnVsayBSUEMgZG9lcyBub3Qgc3VwcG9ydCBza2lwVmFsaWRhdGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogaW52b2NhdGlvbnMubWFwKChpdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKGl0LCBcImZlZVwiKSksXG4gICAgICBibG9ja19pZFxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBpbnZva2VGdW5jdGlvbihmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgaW52b2tlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiBcIjB4MVwiLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVDb250cmFjdCh7IGNvbnRyYWN0LCBzaWduYXR1cmUsIHNlbmRlckFkZHJlc3MsIGNvbXBpbGVkQ2xhc3NIYXNoIH0sIGRldGFpbHMpIHtcbiAgICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHByb2dyYW06IGNvbnRyYWN0LnByb2dyYW0sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVyc2lvbjogSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzEsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgIGRlY2xhcmVfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5zaWVycmFfcHJvZ3JhbSksXG4gICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgdmVyc2lvbjogSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzIsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnRDb250cmFjdCh7IGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgYWRkcmVzc1NhbHQsIHNpZ25hdHVyZSB9LCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICBkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbjoge1xuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHR5cGU6IHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChkZXRhaWxzLnZlcnNpb24gfHwgMCksXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QoY2FsbCwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2FsbFwiLCB7XG4gICAgICByZXF1ZXN0OiB7XG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNhbGwuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3JGcm9tTmFtZShjYWxsLmVudHJ5cG9pbnQpLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY2FsbC5jYWxsZGF0YSlcbiAgICAgIH0sXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ2FsbENvbnRyYWN0UmVzcG9uc2UocmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogTkVXOiBFc3RpbWF0ZSB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSBMMVxuICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIEZyb20gTDFcbiAgICovXG4gIGFzeW5jIGVzdGltYXRlTWVzc2FnZUZlZShtZXNzYWdlLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IHsgZnJvbV9hZGRyZXNzLCB0b19hZGRyZXNzLCBlbnRyeV9wb2ludF9zZWxlY3RvciwgcGF5bG9hZCB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0ge1xuICAgICAgZnJvbV9hZGRyZXNzOiB0b0hleChmcm9tX2FkZHJlc3MpLFxuICAgICAgdG9fYWRkcmVzczogdG9IZXgodG9fYWRkcmVzcyksXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3IoZW50cnlfcG9pbnRfc2VsZWN0b3IpLFxuICAgICAgcGF5bG9hZDogZ2V0SGV4U3RyaW5nQXJyYXkocGF5bG9hZClcbiAgICB9O1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVNZXNzYWdlRmVlXCIsIHtcbiAgICAgIG1lc3NhZ2U6IGZvcm1hdHRlZE1lc3NhZ2UsXG4gICAgICBibG9ja19pZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBhYm91dCB0aGUgc3luYyBzdGF0dXMsIG9yIGZhbHNlIGlmIHRoZSBub2RlIGlzIG5vdCBzeW5jaGluZ1xuICAgKiBAcmV0dXJucyBPYmplY3Qgd2l0aCB0aGUgc3RhdHMgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0U3luY2luZ1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zeW5jaW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlclxuICAgKiBAcmV0dXJucyBldmVudHMgYW5kIHRoZSBwYWdpbmF0aW9uIG9mIHRoZSBldmVudHNcbiAgICovXG4gIGFzeW5jIGdldEV2ZW50cyhldmVudEZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRFdmVudHNcIiwgeyBmaWx0ZXI6IGV2ZW50RmlsdGVyIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdGFya25ldElkIEVuZHBvaW50IChnZXQgbmFtZSBmcm9tIGFkZHJlc3MpXG4gICAqL1xuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRTdGFya05hbWUodGhpcywgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJrbmV0SWQgRW5kcG9pbnQgKGdldCBhZGRyZXNzIGZyb20gbmFtZSlcbiAgICovXG4gIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUodGhpcywgbmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uLCB2ZXJzaW9uVHlwZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9ucyA9IGdldFZlcnNpb25zQnlUeXBlKHZlcnNpb25UeXBlKTtcbiAgICBjb25zdCBkZXRhaWxzID0ge1xuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KGludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgIG5vbmNlOiB0b0hleChpbnZvY2F0aW9uLm5vbmNlKSxcbiAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgfTtcbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgIC8vIERpZmYgYmV0d2VlbiBzZXF1ZW5jZXIgYW5kIHJwYyBpbnZva2UgdHlwZVxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8pIHtcbiAgICAgIGlmICghaXNTaWVycmEoaW52b2NhdGlvbi5jb250cmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBjb21waWxlZF9jbGFzc19oYXNoXG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShpbnZvY2F0aW9uLmNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKVxuICAgICAgICB9LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBpbnZvY2F0aW9uLmNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjIpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGludm9jYXRpb24uY2xhc3NIYXNoKSxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChpbnZvY2F0aW9uLmFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJSUEMgYnVpbGRUcmFuc2FjdGlvbiByZWNlaXZlZCB1bmtub3duIFRyYW5zYWN0aW9uVHlwZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL3NlcXVlbmNlci50c1xuaW1wb3J0IHVybGpvaW4yIGZyb20gXCJ1cmwtam9pblwiO1xuXG4vLyBzcmMvdXRpbHMvcmVzcG9uc2VQYXJzZXIvaW5kZXgudHNcbnZhciBSZXNwb25zZVBhcnNlciA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9zZXF1ZW5jZXIudHNcbnZhciBTZXF1ZW5jZXJBUElSZXNwb25zZVBhcnNlciA9IGNsYXNzIGV4dGVuZHMgUmVzcG9uc2VQYXJzZXIge1xuICBwYXJzZUdldEJsb2NrUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIG5ld19yb290OiByZXMuc3RhdGVfcm9vdCxcbiAgICAgIHBhcmVudF9oYXNoOiByZXMucGFyZW50X2Jsb2NrX2hhc2gsXG4gICAgICB0cmFuc2FjdGlvbnM6IE9iamVjdC52YWx1ZXMocmVzLnRyYW5zYWN0aW9ucykubWFwKCh2YWx1ZSkgPT4gXCJ0cmFuc2FjdGlvbl9oYXNoXCIgaW4gdmFsdWUgJiYgdmFsdWUudHJhbnNhY3Rpb25faGFzaCkuZmlsdGVyKEJvb2xlYW4pXG4gICAgfTtcbiAgfVxuICBwYXJzZUdldFRyYW5zYWN0aW9uUmVzcG9uc2UocmVzKSB7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovICYmIHJlcy5maW5hbGl0eV9zdGF0dXMgPT09IFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovKSB7XG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBjYWxsZGF0YTogXCJjYWxsZGF0YVwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5jYWxsZGF0YSA6IFtdLFxuICAgICAgY29udHJhY3RfY2xhc3M6IFwiY29udHJhY3RfY2xhc3NcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24uY29udHJhY3RfY2xhc3MgOiB2b2lkIDAsXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogXCJlbnRyeV9wb2ludF9zZWxlY3RvclwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5lbnRyeV9wb2ludF9zZWxlY3RvciA6IHZvaWQgMCxcbiAgICAgIG1heF9mZWU6IFwibWF4X2ZlZVwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5tYXhfZmVlIDogdm9pZCAwLFxuICAgICAgbm9uY2U6IHJlcy50cmFuc2FjdGlvbi5ub25jZSxcbiAgICAgIHNlbmRlcl9hZGRyZXNzOiBcInNlbmRlcl9hZGRyZXNzXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLnNlbmRlcl9hZGRyZXNzIDogdm9pZCAwLFxuICAgICAgc2lnbmF0dXJlOiBcInNpZ25hdHVyZVwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5zaWduYXR1cmUgOiB2b2lkIDAsXG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiBcInRyYW5zYWN0aW9uX2hhc2hcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24udHJhbnNhY3Rpb25faGFzaCA6IHZvaWQgMCxcbiAgICAgIHZlcnNpb246IFwidmVyc2lvblwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi52ZXJzaW9uIDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBwYXJzZUdldFRyYW5zYWN0aW9uUmVjZWlwdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXMsXG4gICAgICBtZXNzYWdlc19zZW50OiByZXMubDJfdG9fbDFfbWVzc2FnZXMsXG4gICAgICAuLi5cInJldmVydF9lcnJvclwiIGluIHJlcyAmJiB7IHJldmVydF9yZWFzb246IHJlcy5yZXZlcnRfZXJyb3IgfVxuICAgIH07XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHJlcykge1xuICAgIGlmIChcIm92ZXJhbGxfZmVlXCIgaW4gcmVzKSB7XG4gICAgICBsZXQgZ2FzSW5mbyA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ2FzSW5mbyA9IHtcbiAgICAgICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHJlcy5nYXNfdXNhZ2UpLFxuICAgICAgICAgIGdhc19wcmljZTogdG9CaWdJbnQocmVzLmdhc19wcmljZSlcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHJlcy5vdmVyYWxsX2ZlZSksXG4gICAgICAgIC4uLmdhc0luZm9cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQocmVzLmFtb3VudClcbiAgICB9O1xuICB9XG4gIHBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChyZXMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKFwib3ZlcmFsbF9mZWVcIiBpbiBpdGVtKSB7XG4gICAgICAgIGxldCBnYXNJbmZvID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2FzSW5mbyA9IHtcbiAgICAgICAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQoaXRlbS5nYXNfdXNhZ2UpLFxuICAgICAgICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludChpdGVtLmdhc19wcmljZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludChpdGVtLm92ZXJhbGxfZmVlKSxcbiAgICAgICAgICAuLi5nYXNJbmZvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQoaXRlbS5hbW91bnQpXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZSA9IFwib3ZlcmFsbF9mZWVcIiBpbiByZXMuZmVlX2VzdGltYXRpb24gPyByZXMuZmVlX2VzdGltYXRpb24ub3ZlcmFsbF9mZWUgOiByZXMuZmVlX2VzdGltYXRpb24uYW1vdW50O1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRyYW5zYWN0aW9uX3RyYWNlOiByZXMudHJhY2UsXG4gICAgICAgIGZlZV9lc3RpbWF0aW9uOiByZXMuZmVlX2VzdGltYXRpb24sXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZTogZXN0aW1hdGVkRmVlVG9NYXhGZWUoQmlnSW50KHN1Z2dlc3RlZE1heEZlZSkpXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBwYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHJlcy5yZXN1bHRcbiAgICB9O1xuICB9XG4gIHBhcnNlSW52b2tlRnVuY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2hcbiAgICB9O1xuICB9XG4gIHBhcnNlRGVwbG95Q29udHJhY3RSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgICBjb250cmFjdF9hZGRyZXNzOiByZXMuYWRkcmVzc1xuICAgIH07XG4gIH1cbiAgcGFyc2VEZWNsYXJlQ29udHJhY3RSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaDogcmVzLnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgICBjbGFzc19oYXNoOiByZXMuY2xhc3NfaGFzaFxuICAgIH07XG4gIH1cbiAgcGFyc2VHZXRTdGF0ZVVwZGF0ZVJlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IG5vbmNlcyA9IE9iamVjdC5lbnRyaWVzKHJlcy5zdGF0ZV9kaWZmLm5vbmNlcykubWFwKChbY29udHJhY3RfYWRkcmVzcywgbm9uY2VdKSA9PiAoe1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIG5vbmNlXG4gICAgfSkpO1xuICAgIGNvbnN0IHN0b3JhZ2VfZGlmZnMgPSBPYmplY3QuZW50cmllcyhyZXMuc3RhdGVfZGlmZi5zdG9yYWdlX2RpZmZzKS5tYXAoXG4gICAgICAoW2FkZHJlc3MsIHN0b3JhZ2VfZW50cmllc10pID0+ICh7IGFkZHJlc3MsIHN0b3JhZ2VfZW50cmllcyB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIHN0YXRlX2RpZmY6IHtcbiAgICAgICAgLi4ucmVzLnN0YXRlX2RpZmYsXG4gICAgICAgIHN0b3JhZ2VfZGlmZnMsXG4gICAgICAgIG5vbmNlc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBpc1NpZXJyYShyZXMpID8gcmVzIDogcGFyc2VDb250cmFjdChyZXMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIGFiaTogdHlwZW9mIHJlc3BvbnNlLmFiaSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UocmVzcG9uc2UuYWJpKSA6IHJlc3BvbnNlLmFiaVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy91cmwudHNcbmltcG9ydCB1cmxqb2luIGZyb20gXCJ1cmwtam9pblwiO1xudmFyIHByb3RvY29sQW5kRG9tYWluUkUgPSAvXig/Olxcdys6KT9cXC9cXC8oXFxTKykkLztcbnZhciBsb2NhbGhvc3REb21haW5SRSA9IC9ebG9jYWxob3N0Wzo/XFxkXSooPzpbXjo/XFxkXVxcUyopPyQvO1xudmFyIG5vbkxvY2FsaG9zdERvbWFpblJFID0gL15bXlxccy5dK1xcLlxcU3syLH0kLztcbmZ1bmN0aW9uIGlzVXJsKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IHMubWF0Y2gocHJvdG9jb2xBbmREb21haW5SRSk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wgPSBtYXRjaFsxXTtcbiAgaWYgKCFldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkgfHwgbm9uTG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBidWlsZFVybChiYXNlVXJsLCBkZWZhdWx0UGF0aCwgdXJsT3JQYXRoKSB7XG4gIHJldHVybiBpc1VybCh1cmxPclBhdGgpID8gdXJsT3JQYXRoIDogdXJsam9pbihiYXNlVXJsLCB1cmxPclBhdGggPz8gZGVmYXVsdFBhdGgpO1xufVxuXG4vLyBzcmMvcHJvdmlkZXIvc2VxdWVuY2VyLnRzXG5mdW5jdGlvbiBpc0VtcHR5UXVlcnlPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHZvaWQgMCB8fCBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCB8fCBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMSAmJiBPYmplY3QuZW50cmllcyhvYmopLmV2ZXJ5KChbaywgdl0pID0+IGsgPT09IFwiYmxvY2tJZGVudGlmaWVyXCIgJiYgdiA9PT0gbnVsbCk7XG59XG52YXIgZGVmYXVsdE9wdGlvbnMyID0ge1xuICBuZXR3b3JrOiBcIlNOX0dPRVJMSVwiIC8qIFNOX0dPRVJMSSAqLyxcbiAgYmxvY2tJZGVudGlmaWVyOiBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovXG59O1xudmFyIFNlcXVlbmNlclByb3ZpZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zT3JQcm92aWRlciA9IGRlZmF1bHRPcHRpb25zMikge1xuICAgIHRoaXMucmVzcG9uc2VQYXJzZXIgPSBuZXcgU2VxdWVuY2VyQVBJUmVzcG9uc2VQYXJzZXIoKTtcbiAgICBpZiAoXCJuZXR3b3JrXCIgaW4gb3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuYmFzZVVybCA9IFNlcXVlbmNlclByb3ZpZGVyLmdldE5ldHdvcmtGcm9tTmFtZShvcHRpb25zT3JQcm92aWRlci5uZXR3b3JrKTtcbiAgICAgIHRoaXMuZmVlZGVyR2F0ZXdheVVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJmZWVkZXJfZ2F0ZXdheVwiKTtcbiAgICAgIHRoaXMuZ2F0ZXdheVVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJnYXRld2F5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJhc2VVcmwgPSBvcHRpb25zT3JQcm92aWRlci5iYXNlVXJsO1xuICAgICAgdGhpcy5mZWVkZXJHYXRld2F5VXJsID0gYnVpbGRVcmwoXG4gICAgICAgIHRoaXMuYmFzZVVybCxcbiAgICAgICAgXCJmZWVkZXJfZ2F0ZXdheVwiLFxuICAgICAgICBvcHRpb25zT3JQcm92aWRlci5mZWVkZXJHYXRld2F5VXJsXG4gICAgICApO1xuICAgICAgdGhpcy5nYXRld2F5VXJsID0gYnVpbGRVcmwodGhpcy5iYXNlVXJsLCBcImdhdGV3YXlcIiwgb3B0aW9uc09yUHJvdmlkZXIuZ2F0ZXdheVVybCk7XG4gICAgfVxuICAgIHRoaXMuY2hhaW5JZCA9IG9wdGlvbnNPclByb3ZpZGVyPy5jaGFpbklkID8/IFNlcXVlbmNlclByb3ZpZGVyLmdldENoYWluSWRGcm9tQmFzZVVybCh0aGlzLmJhc2VVcmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnNPclByb3ZpZGVyLmhlYWRlcnM7XG4gICAgdGhpcy5ibG9ja0lkZW50aWZpZXIgPSBvcHRpb25zT3JQcm92aWRlcj8uYmxvY2tJZGVudGlmaWVyIHx8IGRlZmF1bHRPcHRpb25zMi5ibG9ja0lkZW50aWZpZXI7XG4gIH1cbiAgc3RhdGljIGdldE5ldHdvcmtGcm9tTmFtZShuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiU05fTUFJTlwiIC8qIFNOX01BSU4gKi86XG4gICAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICAgIHJldHVybiBcImh0dHBzOi8vYWxwaGEtbWFpbm5ldC5zdGFya25ldC5pb1wiIC8qIFNOX01BSU4gKi87XG4gICAgICBjYXNlIFwiU05fR09FUkxJXCIgLyogU05fR09FUkxJICovOlxuICAgICAgY2FzZSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovOlxuICAgICAgICByZXR1cm4gXCJodHRwczovL2FscGhhNC5zdGFya25ldC5pb1wiIC8qIFNOX0dPRVJMSSAqLztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlY3QgYmFzZSB1cmwgZnJvbSBOZXR3b3JrTmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldENoYWluSWRGcm9tQmFzZVVybChiYXNlVXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICBpZiAodXJsLmhvc3QuaW5jbHVkZXMoXCJtYWlubmV0LnN0YXJrbmV0LmlvXCIpKSB7XG4gICAgICAgIHJldHVybiBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi87XG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgYmFzZVVybDogJHtiYXNlVXJsfWApO1xuICAgICAgcmV0dXJuIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi87XG4gICAgfVxuICB9XG4gIGdldEZldGNoVXJsKGVuZHBvaW50KSB7XG4gICAgY29uc3QgZ2F0ZXdheVVybEVuZHBvaW50cyA9IFtcImFkZF90cmFuc2FjdGlvblwiXTtcbiAgICByZXR1cm4gZ2F0ZXdheVVybEVuZHBvaW50cy5pbmNsdWRlcyhlbmRwb2ludCkgPyB0aGlzLmdhdGV3YXlVcmwgOiB0aGlzLmZlZWRlckdhdGV3YXlVcmw7XG4gIH1cbiAgZ2V0RmV0Y2hNZXRob2QoZW5kcG9pbnQpIHtcbiAgICBjb25zdCBwb3N0TWV0aG9kRW5kcG9pbnRzID0gW1xuICAgICAgXCJhZGRfdHJhbnNhY3Rpb25cIixcbiAgICAgIFwiY2FsbF9jb250cmFjdFwiLFxuICAgICAgXCJlc3RpbWF0ZV9mZWVcIixcbiAgICAgIFwiZXN0aW1hdGVfbWVzc2FnZV9mZWVcIixcbiAgICAgIFwiZXN0aW1hdGVfZmVlX2J1bGtcIixcbiAgICAgIFwic2ltdWxhdGVfdHJhbnNhY3Rpb25cIlxuICAgIF07XG4gICAgcmV0dXJuIHBvc3RNZXRob2RFbmRwb2ludHMuaW5jbHVkZXMoZW5kcG9pbnQpID8gXCJQT1NUXCIgOiBcIkdFVFwiO1xuICB9XG4gIGdldFF1ZXJ5U3RyaW5nKHF1ZXJ5KSB7XG4gICAgaWYgKGlzRW1wdHlRdWVyeU9iamVjdChxdWVyeSkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5lbnRyaWVzKHF1ZXJ5KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJibG9ja0lkZW50aWZpZXJcIikge1xuICAgICAgICBjb25zdCBibG9jayA9IG5ldyBCbG9jayh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBgJHtibG9jay5xdWVyeUlkZW50aWZpZXJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHtrZXl9PSR7dmFsdWV9YDtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgICByZXR1cm4gYD8ke3F1ZXJ5U3RyaW5nfWA7XG4gIH1cbiAgZ2V0SGVhZGVycyhtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLnRoaXMuaGVhZGVyc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGVhZGVycztcbiAgfVxuICAvLyB0eXBlc2FmZSBmZXRjaFxuICBhc3luYyBmZXRjaEVuZHBvaW50KGVuZHBvaW50LCAuLi5bcXVlcnksIHJlcXVlc3RdKSB7XG4gICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0RmV0Y2hVcmwoZW5kcG9pbnQpO1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuZ2V0RmV0Y2hNZXRob2QoZW5kcG9pbnQpO1xuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdGhpcy5nZXRRdWVyeVN0cmluZyhxdWVyeSk7XG4gICAgY29uc3QgdXJsID0gdXJsam9pbjIoYmFzZVVybCwgZW5kcG9pbnQsIHF1ZXJ5U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmZXRjaChlbmRwb2ludCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJcIiwgZW5kcG9pbnQpO1xuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnM/Lm1ldGhvZCA/PyBcIkdFVFwiO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEhlYWRlcnMobWV0aG9kKTtcbiAgICBjb25zdCBib2R5ID0gc3RyaW5naWZ5MihvcHRpb25zPy5ib2R5KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodXJsLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0UmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGxldCByZXNwb25zZUJvZHk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2VCb2R5ID0gcGFyc2UyKHRleHRSZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgR2F0ZXdheUVycm9yKHJlc3BvbnNlQm9keS5tZXNzYWdlLCByZXNwb25zZUJvZHkuY29kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZUNob2ljZSA9IG9wdGlvbnM/LnBhcnNlQWx3YXlzQXNCaWdJbnQgPyBwYXJzZUFsd2F5c0FzQmlnIDogcGFyc2UyO1xuICAgICAgcmV0dXJuIHBhcnNlQ2hvaWNlKHRleHRSZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBMaWJyYXJ5RXJyb3IpKVxuICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90ICR7bWV0aG9kfSBmcm9tIGVuZHBvaW50IFxcYCR7dXJsfVxcYDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNoYWluSWQpO1xuICB9XG4gIGFzeW5jIGNhbGxDb250cmFjdCh7IGNvbnRyYWN0QWRkcmVzcywgZW50cnlwb2ludDogZW50cnlQb2ludFNlbGVjdG9yLCBjYWxsZGF0YSA9IFtdIH0sIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcbiAgICAgIFwiY2FsbF9jb250cmFjdFwiLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETyAtIGRldGVybWluZSBiZXN0IGNob2ljZSBvbmNlIGJvdGggYXJlIGZ1bGx5IHN1cHBvcnRlZCBpbiBkZXZuZXRcbiAgICAgICAgLy8gc2lnbmF0dXJlOiBbXSxcbiAgICAgICAgLy8gc2VuZGVyX2FkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3JGcm9tTmFtZShlbnRyeVBvaW50U2VsZWN0b3IpLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsZGF0YSlcbiAgICAgIH1cbiAgICApLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfYmxvY2tcIiwgeyBibG9ja0lkZW50aWZpZXIgfSkudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfbm9uY2VcIiwgeyBjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KTtcbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gdG9CaWdJbnQoa2V5KS50b1N0cmluZygxMCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9zdG9yYWdlX2F0XCIsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGtleTogcGFyc2VkS2V5XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgY29uc3QgdHhIYXNoSGV4ID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3RyYW5zYWN0aW9uXCIsIHsgdHJhbnNhY3Rpb25IYXNoOiB0eEhhc2hIZXggfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhyZXN1bHQpLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihyZXN1bHQuc3RhdHVzKTtcbiAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0eEhhc2hIZXggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfdHJhbnNhY3Rpb25fcmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0VHJhbnNhY3Rpb25SZWNlaXB0UmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfZnVsbF9jb250cmFjdFwiLCB7IGJsb2NrSWRlbnRpZmllciwgY29udHJhY3RBZGRyZXNzIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9jbGFzc19oYXNoX2F0XCIsIHsgYmxvY2tJZGVudGlmaWVyLCBjb250cmFjdEFkZHJlc3MgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NCeUhhc2goY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY2xhc3NfYnlfaGFzaFwiLCB7IGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDb21waWxlZENsYXNzQnlDbGFzc0hhc2goY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY29tcGlsZWRfY2xhc3NfYnlfY2xhc3NfaGFzaFwiLCB7IGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyIH0pO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgY29tcGlsZXIgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBjb250cmFjdENsYXNzO1xuICAgIGlmIChjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NIYXNoKSB7XG4gICAgICBjb250cmFjdENsYXNzID0gYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZ2V0Q29udHJhY3RWZXJzaW9uIHJlcXVpcmUgY29udHJhY3RBZGRyZXNzIG9yIGNsYXNzSGFzaFwiKTtcbiAgICB9XG4gICAgaWYgKGlzU2llcnJhKGNvbnRyYWN0Q2xhc3MpKSB7XG4gICAgICBpZiAoY29tcGlsZXIpIHtcbiAgICAgICAgY29uc3QgYWJpVGVzdCA9IGdldEFiaUNvbnRyYWN0VmVyc2lvbihjb250cmFjdENsYXNzLmFiaSk7XG4gICAgICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IGFiaVRlc3QuY29tcGlsZXIgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IHZvaWQgMCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjYWlybzogXCIwXCIsIGNvbXBpbGVyOiBcIjBcIiB9O1xuICB9XG4gIGFzeW5jIGludm9rZUZ1bmN0aW9uKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJhZGRfdHJhbnNhY3Rpb25cIiwgdm9pZCAwLCB7XG4gICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhID8/IFtdKSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgIHZlcnNpb246IFwiMHgxXCJcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VJbnZva2VGdW5jdGlvblJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50Q29udHJhY3QoeyBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGFkZHJlc3NTYWx0LCBzaWduYXR1cmUgfSwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJhZGRfdHJhbnNhY3Rpb25cIiwgdm9pZCAwLCB7XG4gICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IGFkZHJlc3NTYWx0ID8/IHJhbmRvbUFkZHJlc3MoKSxcbiAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEgPz8gW10pLFxuICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgdmVyc2lvbjogdG9IZXgoZGV0YWlscy52ZXJzaW9uIHx8IDApLFxuICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWduYXR1cmUpXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRGVwbG95Q29udHJhY3RSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUNvbnRyYWN0KHsgc2VuZGVyQWRkcmVzcywgY29udHJhY3QsIHNpZ25hdHVyZSwgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiYWRkX3RyYW5zYWN0aW9uXCIsIHZvaWQgMCwge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICBjb250cmFjdF9jbGFzczogY29udHJhY3QsXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWduYXR1cmUpLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KHRyYW5zYWN0aW9uVmVyc2lvbilcbiAgICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZURlY2xhcmVDb250cmFjdFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImFkZF90cmFuc2FjdGlvblwiLCB2b2lkIDAsIHtcbiAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgY29udHJhY3RfY2xhc3M6IGNvbnRyYWN0LFxuICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShzaWduYXR1cmUpLFxuICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICB2ZXJzaW9uOiB0b0hleCh0cmFuc2FjdGlvblZlcnNpb25fMilcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VEZWNsYXJlQ29udHJhY3RSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLmdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSk7XG4gIH1cbiAgYXN5bmMgZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLyxcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgLi4uaW52b2NhdGlvbkRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZXN0aW1hdGVfZmVlXCIsIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSwgdHJhbnNhY3Rpb24pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVjbGFyZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX2ZlZVwiLCB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sIHRyYW5zYWN0aW9uKS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX2ZlZVwiLCB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sIHRyYW5zYWN0aW9uKS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UgfSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCwgXCJmZWVcIikpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXG4gICAgICBcImVzdGltYXRlX2ZlZV9idWxrXCIsXG4gICAgICB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sXG4gICAgICB0cmFuc2FjdGlvbnNcbiAgICApLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlQnVsa1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X2NvZGVcIiwgeyBjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24odHhIYXNoLCBvcHRpb25zKSB7XG4gICAgbGV0IHJlcztcbiAgICBsZXQgY29tcGxldGVkID0gZmFsc2U7XG4gICAgbGV0IHJldHJpZXMgPSAwO1xuICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSBvcHRpb25zPy5yZXRyeUludGVydmFsID8/IDVlMztcbiAgICBjb25zdCBlcnJvclN0YXRlcyA9IG9wdGlvbnM/LmVycm9yU3RhdGVzID8/IFtcbiAgICAgIFwiUkVKRUNURURcIiAvKiBSRUpFQ1RFRCAqLyxcbiAgICAgIFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovLFxuICAgICAgXCJSRVZFUlRFRFwiIC8qIFJFVkVSVEVEICovXG4gICAgXTtcbiAgICBjb25zdCBzdWNjZXNzU3RhdGVzID0gb3B0aW9ucz8uc3VjY2Vzc1N0YXRlcyA/PyBbXG4gICAgICBcIlNVQ0NFRURFRFwiIC8qIFNVQ0NFRURFRCAqLyxcbiAgICAgIFwiQUNDRVBURURfT05fTDFcIiAvKiBBQ0NFUFRFRF9PTl9MMSAqLyxcbiAgICAgIFwiQUNDRVBURURfT05fTDJcIiAvKiBBQ0NFUFRFRF9PTl9MMiAqL1xuICAgIF07XG4gICAgd2hpbGUgKCFjb21wbGV0ZWQpIHtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICByZXMgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uU3RhdHVzKHR4SGFzaCk7XG4gICAgICBpZiAoXCJOT1RfUkVDRUlWRURcIiAvKiBOT1RfUkVDRUlWRUQgKi8gPT09IHJlcy5maW5hbGl0eV9zdGF0dXMgJiYgcmV0cmllcyA8IDMpIHtcbiAgICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKHJlcy5maW5hbGl0eV9zdGF0dXMpIHx8IHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMocmVzLmV4ZWN1dGlvbl9zdGF0dXMpKSB7XG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yU3RhdGVzLmluY2x1ZGVzKHJlcy5maW5hbGl0eV9zdGF0dXMpIHx8IGVycm9yU3RhdGVzLmluY2x1ZGVzKHJlcy5leGVjdXRpb25fc3RhdHVzKSkge1xuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgaWYgKHJlcy50eF9mYWlsdXJlX3JlYXNvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgJHtyZXMudHhfc3RhdHVzfTogJHtyZXMudHhfZmFpbHVyZV9yZWFzb24uY29kZX1cbiR7cmVzLnR4X2ZhaWx1cmVfcmVhc29uLmVycm9yX21lc3NhZ2V9YDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMudHhfcmV2ZXJ0X3JlYXNvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgJHtyZXMudHhfc3RhdHVzfTogJHtyZXMudHhfcmV2ZXJ0X3JlYXNvbn1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSByZXMudHhfc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlcztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgcmV0dXJuIHR4UmVjZWlwdDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB0eEhhc2ggQmlnTnVtYmVyaXNoXG4gICAqIEByZXR1cm5zIEdldFRyYW5zYWN0aW9uU3RhdHVzUmVzcG9uc2UgLSB0aGUgdHJhbnNhY3Rpb24gc3RhdHVzIG9iamVjdFxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHhIYXNoKSB7XG4gICAgY29uc3QgdHhIYXNoSGV4ID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3RyYW5zYWN0aW9uX3N0YXR1c1wiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzbWFydCBjb250cmFjdCBhZGRyZXNzIG9uIHRoZSBnb2VybGkgdGVzdG5ldC5cbiAgICogQHJldHVybnMgR2V0Q29udHJhY3RBZGRyZXNzZXNSZXNwb25zZSAtIHN0YXJrbmV0IHNtYXJ0IGNvbnRyYWN0IGFkZHJlc3Nlc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q29udHJhY3RBZGRyZXNzZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9jb250cmFjdF9hZGRyZXNzZXNcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYW5zYWN0aW9uIHRyYWNlIGZyb20gYSB0eCBpZC5cbiAgICogQHBhcmFtIHR4SGFzaCBCaWdOdW1iZXJpc2hcbiAgICogQHJldHVybnMgVHJhbnNhY3Rpb25UcmFjZVJlc3BvbnNlIC0gdGhlIHRyYW5zYWN0aW9uIHRyYWNlXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIGNvbnN0IHR4SGFzaEhleCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF90cmFuc2FjdGlvbl90cmFjZVwiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlTWVzc2FnZUZlZSh7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB2YWxpZENhbGxMMUhhbmRsZXIgPSB7XG4gICAgICBmcm9tX2FkZHJlc3M6IGdldERlY2ltYWxTdHJpbmcoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IGdldEhleFN0cmluZyh0b19hZGRyZXNzKSxcbiAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvcihlbnRyeV9wb2ludF9zZWxlY3RvciksXG4gICAgICBwYXlsb2FkOiBnZXRIZXhTdHJpbmdBcnJheShwYXlsb2FkKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX21lc3NhZ2VfZmVlXCIsIHsgYmxvY2tJZGVudGlmaWVyIH0sIHZhbGlkQ2FsbEwxSGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIFNpbXVsYXRlIHRyYW5zYWN0aW9uIHVzaW5nIFNlcXVlbmNlciBwcm92aWRlclxuICAgKiBXQVJOSU5HITogU2VxdWVuY2VyIHdpbGwgcHJvY2VzcyBvbmx5IGZpcnN0IGVsZW1lbnQgZnJvbSBpbnZvY2F0aW9ucyBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQXJyYXkgb2YgaW52b2NhdGlvbnMsIGJ1dCBvbmx5IGZpcnN0IGludm9jYXRpb24gd2lsbCBiZSBwcm9jZXNzZWRcbiAgICogQHBhcmFtIGJsb2NrSWRlbnRpZmllciBibG9jayBpZGVudGlmaWVyLCBkZWZhdWx0ICdsYXRlc3QnXG4gICAqIEBwYXJhbSBza2lwVmFsaWRhdGUgU2tpcCBBY2NvdW50IF9fdmFsaWRhdGVfXyBtZXRob2RcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIHtcbiAgICBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcixcbiAgICBza2lwVmFsaWRhdGUgPSBmYWxzZSxcbiAgICBza2lwRXhlY3V0ZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoaW52b2NhdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKFwiU2VxdWVuY2VyIHNpbXVsYXRlIHByb2Nlc3Mgb25seSBmaXJzdCBlbGVtZW50IGZyb20gaW52b2NhdGlvbnMgbGlzdFwiKTtcbiAgICB9XG4gICAgaWYgKHNraXBFeGVjdXRlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJTZXF1ZW5jZXIgY2FuJ3Qgc2tpcCBhY2NvdW50IF9fZXhlY3V0ZV9fXCIpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uc1swXSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcbiAgICAgIFwic2ltdWxhdGVfdHJhbnNhY3Rpb25cIixcbiAgICAgIHtcbiAgICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgICBza2lwVmFsaWRhdGU6IHNraXBWYWxpZGF0ZSA/PyBmYWxzZVxuICAgICAgfSxcbiAgICAgIHRyYW5zYWN0aW9uXG4gICAgKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldFN0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYXJncyA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLnNlcXVlbmNlcklkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9zdGF0ZV91cGRhdGVcIiwgeyAuLi5hcmdzIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0U3RhdGVVcGRhdGVSZXNwb25zZVxuICAgICk7XG4gIH1cbiAgLy8gY29uc2lkZXIgYWRkaW5nIGFuIG9wdGlvbmFsIHRyYWNlIHJldHJpZXZhbCBwYXJhbWV0ZXIgdG8gdGhlIGdldEJsb2NrIG1ldGhvZFxuICBhc3luYyBnZXRCbG9ja1RyYWNlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5zZXF1ZW5jZXJJZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfYmxvY2tfdHJhY2VzXCIsIHsgLi4uYXJncyB9KTtcbiAgfVxuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRTdGFya05hbWUodGhpcywgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUobmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZSh0aGlzLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICAvKipcbiAgICogQnVpbGQgU2luZ2xlIEFjY291bnRUcmFuc2FjdGlvbiBmcm9tIFNpbmdsZSBBY2NvdW50SW52b2NhdGlvblxuICAgKiBAcGFyYW0gaW52b2NhdGlvbiBBY2NvdW50SW52b2NhdGlvbkl0ZW1cbiAgICogQHBhcmFtIHZlcnNpb25UeXBlICdmZWUnIHwgJ3RyYW5zYWN0aW9uJyAtIHVzZWQgdG8gZGV0ZXJtaW5lIGRlZmF1bHQgdmVyc2lvbnNcbiAgICogQHJldHVybnMgQWNjb3VudFRyYW5zYWN0aW9uSXRlbVxuICAgKi9cbiAgYnVpbGRUcmFuc2FjdGlvbihpbnZvY2F0aW9uLCB2ZXJzaW9uVHlwZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9ucyA9IGdldFZlcnNpb25zQnlUeXBlKHZlcnNpb25UeXBlKTtcbiAgICBjb25zdCBkZXRhaWxzID0ge1xuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheShpbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSlcbiAgICB9O1xuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoaW52b2NhdGlvbi5jYWxsZGF0YSA/PyBbXSksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovKSB7XG4gICAgICBpZiAoIWlzU2llcnJhKGludm9jYXRpb24uY29udHJhY3QpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MSksXG4gICAgICAgICAgLy8gZmVlIGZyb20gZ2V0RGVjbGFyZUVzdGltYXRlRmVlIHVzZSB0LnYuIGluc3RlYWQgb2YgZmVldC52LlxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGludm9jYXRpb24uY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLnNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjIpLFxuICAgICAgICAvLyBmZWUgb24gZ2V0RGVjbGFyZUVzdGltYXRlRmVlIHVzZSB0LnYuIGluc3RlYWQgb2YgZmVldC52LlxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoaW52b2NhdGlvbi5jb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoaW52b2NhdGlvbi5jbGFzc0hhc2gpLFxuICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGludm9jYXRpb24uYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIlNlcXVlbmNlciBidWlsZFRyYW5zYWN0aW9uIHJlY2VpdmVkIHVua25vd24gVHJhbnNhY3Rpb25UeXBlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvZGVmYXVsdC50c1xudmFyIFByb3ZpZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihwcm92aWRlck9yT3B0aW9ucykge1xuICAgIGlmIChwcm92aWRlck9yT3B0aW9ucyBpbnN0YW5jZW9mIFByb3ZpZGVyKSB7XG4gICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXJPck9wdGlvbnMucHJvdmlkZXI7XG4gICAgfSBlbHNlIGlmIChwcm92aWRlck9yT3B0aW9ucyBpbnN0YW5jZW9mIFJwY1Byb3ZpZGVyIHx8IHByb3ZpZGVyT3JPcHRpb25zIGluc3RhbmNlb2YgU2VxdWVuY2VyUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlck9yT3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHByb3ZpZGVyT3JPcHRpb25zICYmIFwicnBjXCIgaW4gcHJvdmlkZXJPck9wdGlvbnMpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUnBjUHJvdmlkZXIocHJvdmlkZXJPck9wdGlvbnMucnBjKTtcbiAgICB9IGVsc2UgaWYgKHByb3ZpZGVyT3JPcHRpb25zICYmIFwic2VxdWVuY2VyXCIgaW4gcHJvdmlkZXJPck9wdGlvbnMpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgU2VxdWVuY2VyUHJvdmlkZXIocHJvdmlkZXJPck9wdGlvbnMuc2VxdWVuY2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm92aWRlciA9IG5ldyBScGNQcm92aWRlcigpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRCbG9jayhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBnZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gpO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlKGludm9jYXRpb25XaXRoVHhUeXBlLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbldpdGhUeFR5cGUsIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb25XaXRoVHhUeXBlLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRJbnZva2VFc3RpbWF0ZUZlZShcbiAgICAgIGludm9jYXRpb25XaXRoVHhUeXBlLFxuICAgICAgaW52b2NhdGlvbkRldGFpbHMsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eEhhc2gpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgfVxuICBhc3luYyBjYWxsQ29udHJhY3QocmVxdWVzdCwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY2FsbENvbnRyYWN0KHJlcXVlc3QsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50Q29udHJhY3QocGF5bG9hZCwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmRlcGxveUFjY291bnRDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZWNsYXJlQ29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5kZWNsYXJlQ29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGdldERlY2xhcmVFc3RpbWF0ZUZlZSh0cmFuc2FjdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXREZWNsYXJlRXN0aW1hdGVGZWUodHJhbnNhY3Rpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKTtcbiAgfVxuICBnZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUodHJhbnNhY3Rpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBkZXRhaWxzLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDb2RlKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Q29kZShjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBnZXRTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldFN0YXJrTmFtZSh0aGlzLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKHRoaXMsIG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXIvaW50ZXJmYWNlLnRzXG52YXIgU2lnbmVySW50ZXJmYWNlID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3V0aWxzL3RyYW5zYWN0aW9uLnRzXG52YXIgdHJhbnNhY3Rpb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHJhbnNhY3Rpb25fZXhwb3J0cywge1xuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzEsXG4gIGdldEV4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZ2V0RXhlY3V0ZUNhbGxkYXRhLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzLFxuICB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMTogKCkgPT4gdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzFcbn0pO1xudmFyIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gW107XG4gIGNvbnN0IGNhbGxkYXRhID0gW107XG4gIGNhbGxzLmZvckVhY2goKGNhbGwpID0+IHtcbiAgICBjb25zdCBkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKTtcbiAgICBjYWxsQXJyYXkucHVzaCh7XG4gICAgICB0bzogdG9CaWdJbnQoY2FsbC5jb250cmFjdEFkZHJlc3MpLnRvU3RyaW5nKDEwKSxcbiAgICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICAgIGRhdGFfb2Zmc2V0OiBjYWxsZGF0YS5sZW5ndGgudG9TdHJpbmcoKSxcbiAgICAgIGRhdGFfbGVuOiBkYXRhLmxlbmd0aC50b1N0cmluZygpXG4gICAgfSk7XG4gICAgY2FsbGRhdGEucHVzaCguLi5kYXRhKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbEFycmF5LFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHsgY2FsbGRhdGEgfSlcbiAgfTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgeyBjYWxsQXJyYXksIGNhbGxkYXRhIH0gPSB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzKGNhbGxzKTtcbiAgY29uc3QgY29tcGlsZWRDYWxscyA9IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsQXJyYXkgfSk7XG4gIHJldHVybiBbLi4uY29tcGlsZWRDYWxscywgLi4uY2FsbGRhdGFdO1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSA9IChjYWxscywgbm9uY2UpID0+IHtcbiAgcmV0dXJuIFsuLi5mcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YShjYWxscyksIHRvQmlnSW50KG5vbmNlKS50b1N0cmluZygpXTtcbn07XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5c19jYWlybzEgPSAoY2FsbHMpID0+IHtcbiAgY29uc3QgY2FsbEFycmF5ID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgIHNlbGVjdG9yOiB0b0JpZ0ludChnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCkpLnRvU3RyaW5nKDEwKSxcbiAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsLmNhbGxkYXRhIHx8IFtdKVxuICB9KSk7XG4gIHJldHVybiBjYWxsQXJyYXk7XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBvcmRlckNhbGxzID0gY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlwb2ludDogY2FsbC5lbnRyeXBvaW50LFxuICAgIGNhbGxkYXRhOiBBcnJheS5pc0FycmF5KGNhbGwuY2FsbGRhdGEpICYmIFwiX19jb21waWxlZF9fXCIgaW4gY2FsbC5jYWxsZGF0YSA/IGNhbGwuY2FsbGRhdGEgOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEpXG4gICAgLy8gUmF3QXJnc09iamVjdCB8IFJhd0FyZ3NBcnJheSB0eXBlXG4gIH0pKTtcbiAgcmV0dXJuIENhbGxEYXRhLmNvbXBpbGUoeyBvcmRlckNhbGxzIH0pO1xufTtcbnZhciBnZXRFeGVjdXRlQ2FsbGRhdGEgPSAoY2FsbHMsIGNhaXJvVmVyc2lvbiA9IFwiMFwiKSA9PiB7XG4gIGlmIChjYWlyb1ZlcnNpb24gPT09IFwiMVwiKSB7XG4gICAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMShjYWxscyk7XG4gIH1cbiAgcmV0dXJuIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKTtcbn07XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciB0eXBlZERhdGFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZWREYXRhX2V4cG9ydHMsIHtcbiAgZW5jb2RlRGF0YTogKCkgPT4gZW5jb2RlRGF0YSxcbiAgZW5jb2RlVHlwZTogKCkgPT4gZW5jb2RlVHlwZSxcbiAgZW5jb2RlVmFsdWU6ICgpID0+IGVuY29kZVZhbHVlLFxuICBnZXREZXBlbmRlbmNpZXM6ICgpID0+IGdldERlcGVuZGVuY2llcyxcbiAgZ2V0TWVzc2FnZUhhc2g6ICgpID0+IGdldE1lc3NhZ2VIYXNoLFxuICBnZXRTdHJ1Y3RIYXNoOiAoKSA9PiBnZXRTdHJ1Y3RIYXNoLFxuICBnZXRUeXBlSGFzaDogKCkgPT4gZ2V0VHlwZUhhc2gsXG4gIGlzTWVya2xlVHJlZVR5cGU6ICgpID0+IGlzTWVya2xlVHJlZVR5cGUsXG4gIHByZXBhcmVTZWxlY3RvcjogKCkgPT4gcHJlcGFyZVNlbGVjdG9yXG59KTtcblxuLy8gc3JjL3V0aWxzL21lcmtsZS50c1xudmFyIG1lcmtsZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChtZXJrbGVfZXhwb3J0cywge1xuICBNZXJrbGVUcmVlOiAoKSA9PiBNZXJrbGVUcmVlLFxuICBwcm9vZk1lcmtsZVBhdGg6ICgpID0+IHByb29mTWVya2xlUGF0aFxufSk7XG52YXIgTWVya2xlVHJlZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobGVhZkhhc2hlcykge1xuICAgIHRoaXMuYnJhbmNoZXMgPSBbXTtcbiAgICB0aGlzLmxlYXZlcyA9IGxlYWZIYXNoZXM7XG4gICAgdGhpcy5yb290ID0gdGhpcy5idWlsZChsZWFmSGFzaGVzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIE1lcmtsZSB0cmVlXG4gICAqIEBwYXJhbSBsZWF2ZXMgaGV4LXN0cmluZyBhcnJheVxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmc7IE1lcmtsZSB0cmVlIHJvb3RcbiAgICovXG4gIGJ1aWxkKGxlYXZlcykge1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbGVhdmVzWzBdO1xuICAgIH1cbiAgICBpZiAobGVhdmVzLmxlbmd0aCAhPT0gdGhpcy5sZWF2ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJyYW5jaGVzLnB1c2gobGVhdmVzKTtcbiAgICB9XG4gICAgY29uc3QgbmV3TGVhdmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGlmIChpICsgMSA9PT0gbGVhdmVzLmxlbmd0aCkge1xuICAgICAgICBuZXdMZWF2ZXMucHVzaChNZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBcIjB4MFwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMZWF2ZXMucHVzaChNZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBsZWF2ZXNbaSArIDFdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1aWxkKG5ld0xlYXZlcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBwZWRlcnNlbiBoYXNoIGZyb20gYSBhbmQgYlxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmdcbiAgICovXG4gIHN0YXRpYyBoYXNoKGEsIGIpIHtcbiAgICBjb25zdCBbYVNvcnRlZCwgYlNvcnRlZF0gPSBbdG9CaWdJbnQoYSksIHRvQmlnSW50KGIpXS5zb3J0KCh4LCB5KSA9PiB4ID49IHkgPyAxIDogLTEpO1xuICAgIHJldHVybiBzdGFya0N1cnZlLnBlZGVyc2VuKGFTb3J0ZWQsIGJTb3J0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gcGF0aCB0byBsZWFmXG4gICAqIEBwYXJhbSBsZWFmIGhleC1zdHJpbmdcbiAgICogQHBhcmFtIGJyYW5jaCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoUGF0aCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm5zIGZvcm1hdDogaGV4LXN0cmluZyBhcnJheVxuICAgKi9cbiAgZ2V0UHJvb2YobGVhZiwgYnJhbmNoID0gdGhpcy5sZWF2ZXMsIGhhc2hQYXRoID0gW10pIHtcbiAgICBjb25zdCBpbmRleCA9IGJyYW5jaC5pbmRleE9mKGxlYWYpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxlYWYgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc2hQYXRoO1xuICAgIH1cbiAgICBjb25zdCBpc0xlZnQgPSBpbmRleCAlIDIgPT09IDA7XG4gICAgY29uc3QgbmVlZGVkQnJhbmNoID0gKGlzTGVmdCA/IGJyYW5jaFtpbmRleCArIDFdIDogYnJhbmNoW2luZGV4IC0gMV0pID8/IFwiMHgwXCI7XG4gICAgY29uc3QgbmV3SGFzaFBhdGggPSBbLi4uaGFzaFBhdGgsIG5lZWRlZEJyYW5jaF07XG4gICAgY29uc3QgY3VycmVudEJyYW5jaExldmVsSW5kZXggPSB0aGlzLmxlYXZlcy5sZW5ndGggPT09IGJyYW5jaC5sZW5ndGggPyAtMSA6IHRoaXMuYnJhbmNoZXMuZmluZEluZGV4KChiKSA9PiBiLmxlbmd0aCA9PT0gYnJhbmNoLmxlbmd0aCk7XG4gICAgY29uc3QgbmV4dEJyYW5jaCA9IHRoaXMuYnJhbmNoZXNbY3VycmVudEJyYW5jaExldmVsSW5kZXggKyAxXSA/PyBbdGhpcy5yb290XTtcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9vZihcbiAgICAgIE1lcmtsZVRyZWUuaGFzaChpc0xlZnQgPyBsZWFmIDogbmVlZGVkQnJhbmNoLCBpc0xlZnQgPyBuZWVkZWRCcmFuY2ggOiBsZWFmKSxcbiAgICAgIG5leHRCcmFuY2gsXG4gICAgICBuZXdIYXNoUGF0aFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZk1lcmtsZVBhdGgocm9vdCwgbGVhZiwgcGF0aCkge1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcm9vdCA9PT0gbGVhZjtcbiAgfVxuICBjb25zdCBbbmV4dCwgLi4ucmVzdF0gPSBwYXRoO1xuICByZXR1cm4gcHJvb2ZNZXJrbGVQYXRoKHJvb3QsIE1lcmtsZVRyZWUuaGFzaChsZWFmLCBuZXh0KSwgcmVzdCk7XG59XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbmZ1bmN0aW9uIGdldEhleCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0b0hleCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdG9IZXgoZW5jb2RlU2hvcnRTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJpZ051bWJlcmlzaDogJHt2YWx1ZX1gKTtcbiAgfVxufVxudmFyIHZhbGlkYXRlVHlwZWREYXRhID0gKGRhdGEpID0+IHtcbiAgY29uc3QgdHlwZWREYXRhID0gZGF0YTtcbiAgY29uc3QgdmFsaWQgPSBCb29sZWFuKHR5cGVkRGF0YS50eXBlcyAmJiB0eXBlZERhdGEucHJpbWFyeVR5cGUgJiYgdHlwZWREYXRhLm1lc3NhZ2UpO1xuICByZXR1cm4gdmFsaWQ7XG59O1xuZnVuY3Rpb24gcHJlcGFyZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHJldHVybiBpc0hleChzZWxlY3RvcikgPyBzZWxlY3RvciA6IGdldFNlbGVjdG9yRnJvbU5hbWUoc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gaXNNZXJrbGVUcmVlVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnR5cGUgPT09IFwibWVya2xldHJlZVwiO1xufVxudmFyIGdldERlcGVuZGVuY2llcyA9ICh0eXBlcywgdHlwZSwgZGVwZW5kZW5jaWVzID0gW10pID0+IHtcbiAgaWYgKHR5cGVbdHlwZS5sZW5ndGggLSAxXSA9PT0gXCIqXCIpIHtcbiAgICB0eXBlID0gdHlwZS5zbGljZSgwLCAtMSk7XG4gIH1cbiAgaWYgKGRlcGVuZGVuY2llcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgaWYgKCF0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0eXBlLFxuICAgIC4uLnR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAgIChwcmV2aW91cywgdCkgPT4gW1xuICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgLi4uZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0LnR5cGUsIHByZXZpb3VzKS5maWx0ZXIoXG4gICAgICAgICAgKGRlcGVuZGVuY3kpID0+ICFwcmV2aW91cy5pbmNsdWRlcyhkZXBlbmRlbmN5KVxuICAgICAgICApXG4gICAgICBdLFxuICAgICAgW11cbiAgICApXG4gIF07XG59O1xuZnVuY3Rpb24gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCkge1xuICBpZiAoY3R4LnBhcmVudCAmJiBjdHgua2V5KSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IHR5cGVzW2N0eC5wYXJlbnRdO1xuICAgIGNvbnN0IG1lcmtsZVR5cGUgPSBwYXJlbnRUeXBlLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY3R4LmtleSk7XG4gICAgY29uc3QgaXNNZXJrbGVUcmVlID0gaXNNZXJrbGVUcmVlVHlwZShtZXJrbGVUeXBlKTtcbiAgICBpZiAoIWlzTWVya2xlVHJlZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2N0eC5rZXl9IGlzIG5vdCBhIG1lcmtsZSB0cmVlYCk7XG4gICAgfVxuICAgIGlmIChtZXJrbGVUeXBlLmNvbnRhaW5zLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXJrbGUgdHJlZSBjb250YWluIHByb3BlcnR5IG11c3Qgbm90IGJlIGFuIGFycmF5IGJ1dCB3YXMgZ2l2ZW4gJHtjdHgua2V5fWApO1xuICAgIH1cbiAgICByZXR1cm4gbWVya2xlVHlwZS5jb250YWlucztcbiAgfVxuICByZXR1cm4gXCJyYXdcIjtcbn1cbnZhciBlbmNvZGVUeXBlID0gKHR5cGVzLCB0eXBlKSA9PiB7XG4gIGNvbnN0IFtwcmltYXJ5LCAuLi5kZXBlbmRlbmNpZXNdID0gZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0eXBlKTtcbiAgY29uc3QgbmV3VHlwZXMgPSAhcHJpbWFyeSA/IFtdIDogW3ByaW1hcnksIC4uLmRlcGVuZGVuY2llcy5zb3J0KCldO1xuICByZXR1cm4gbmV3VHlwZXMubWFwKChkZXBlbmRlbmN5KSA9PiB7XG4gICAgcmV0dXJuIGAke2RlcGVuZGVuY3l9KCR7dHlwZXNbZGVwZW5kZW5jeV0ubWFwKCh0KSA9PiBgJHt0Lm5hbWV9OiR7dC50eXBlfWApfSlgO1xuICB9KS5qb2luKFwiXCIpO1xufTtcbnZhciBnZXRUeXBlSGFzaCA9ICh0eXBlcywgdHlwZSkgPT4ge1xuICByZXR1cm4gZ2V0U2VsZWN0b3JGcm9tTmFtZShlbmNvZGVUeXBlKHR5cGVzLCB0eXBlKSk7XG59O1xudmFyIGVuY29kZVZhbHVlID0gKHR5cGVzLCB0eXBlLCBkYXRhLCBjdHggPSB7fSkgPT4ge1xuICBpZiAodHlwZXNbdHlwZV0pIHtcbiAgICByZXR1cm4gW3R5cGUsIGdldFN0cnVjdEhhc2godHlwZXMsIHR5cGUsIGRhdGEpXTtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXModHlwZXMpLm1hcCgoeCkgPT4gYCR7eH0qYCkuaW5jbHVkZXModHlwZSkpIHtcbiAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICByZXR1cm4gZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZS5zbGljZSgwLCAtMSksIHN0cnVjdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFt0eXBlLCBjb21wdXRlSGFzaE9uRWxlbWVudHMoc3RydWN0SGFzaGVzKV07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwibWVya2xldHJlZVwiKSB7XG4gICAgY29uc3QgbWVya2xlVHJlZVR5cGUgPSBnZXRNZXJrbGVUcmVlVHlwZSh0eXBlcywgY3R4KTtcbiAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICByZXR1cm4gZW5jb2RlVmFsdWUodHlwZXMsIG1lcmtsZVRyZWVUeXBlLCBzdHJ1Y3QpWzFdO1xuICAgIH0pO1xuICAgIGNvbnN0IHsgcm9vdCB9ID0gbmV3IE1lcmtsZVRyZWUoc3RydWN0SGFzaGVzKTtcbiAgICByZXR1cm4gW1wiZmVsdFwiLCByb290XTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmZWx0KlwiKSB7XG4gICAgcmV0dXJuIFtcImZlbHQqXCIsIGNvbXB1dGVIYXNoT25FbGVtZW50cyhkYXRhKV07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwic2VsZWN0b3JcIikge1xuICAgIHJldHVybiBbXCJmZWx0XCIsIHByZXBhcmVTZWxlY3RvcihkYXRhKV07XG4gIH1cbiAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xufTtcbnZhciBlbmNvZGVEYXRhID0gKHR5cGVzLCB0eXBlLCBkYXRhKSA9PiB7XG4gIGNvbnN0IFtyZXR1cm5UeXBlcywgdmFsdWVzXSA9IHR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAoW3RzLCB2c10sIGZpZWxkKSA9PiB7XG4gICAgICBpZiAoZGF0YVtmaWVsZC5uYW1lXSA9PT0gdm9pZCAwIHx8IGRhdGFbZmllbGQubmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZW5jb2RlIGRhdGE6IG1pc3NpbmcgZGF0YSBmb3IgJyR7ZmllbGQubmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICBjb25zdCBbdCwgZW5jb2RlZFZhbHVlXSA9IGVuY29kZVZhbHVlKHR5cGVzLCBmaWVsZC50eXBlLCB2YWx1ZSwge1xuICAgICAgICBwYXJlbnQ6IHR5cGUsXG4gICAgICAgIGtleTogZmllbGQubmFtZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbLi4udHMsIHRdLFxuICAgICAgICBbLi4udnMsIGVuY29kZWRWYWx1ZV1cbiAgICAgIF07XG4gICAgfSxcbiAgICBbW1wiZmVsdFwiXSwgW2dldFR5cGVIYXNoKHR5cGVzLCB0eXBlKV1dXG4gICk7XG4gIHJldHVybiBbcmV0dXJuVHlwZXMsIHZhbHVlc107XG59O1xudmFyIGdldFN0cnVjdEhhc2ggPSAodHlwZXMsIHR5cGUsIGRhdGEpID0+IHtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50cyhlbmNvZGVEYXRhKHR5cGVzLCB0eXBlLCBkYXRhKVsxXSk7XG59O1xudmFyIGdldE1lc3NhZ2VIYXNoID0gKHR5cGVkRGF0YSwgYWNjb3VudCkgPT4ge1xuICBpZiAoIXZhbGlkYXRlVHlwZWREYXRhKHR5cGVkRGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlZCBkYXRhIGRvZXMgbm90IG1hdGNoIEpTT04gc2NoZW1hXCIpO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgZW5jb2RlU2hvcnRTdHJpbmcoXCJTdGFya05ldCBNZXNzYWdlXCIpLFxuICAgIGdldFN0cnVjdEhhc2godHlwZWREYXRhLnR5cGVzLCBcIlN0YXJrTmV0RG9tYWluXCIsIHR5cGVkRGF0YS5kb21haW4pLFxuICAgIGFjY291bnQsXG4gICAgZ2V0U3RydWN0SGFzaCh0eXBlZERhdGEudHlwZXMsIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSwgdHlwZWREYXRhLm1lc3NhZ2UpXG4gIF07XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMobWVzc2FnZSk7XG59O1xuXG4vLyBzcmMvc2lnbmVyL2RlZmF1bHQudHNcbnZhciBTaWduZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBrID0gc3RhcmtDdXJ2ZS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpIHtcbiAgICB0aGlzLnBrID0gcGsgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnVmMmhleChwaykgOiB0b0hleChwayk7XG4gIH1cbiAgYXN5bmMgZ2V0UHViS2V5KCkge1xuICAgIHJldHVybiBzdGFya0N1cnZlLmdldFN0YXJrS2V5KHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcyk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbnNEZXRhaWwsIGFiaXMpIHtcbiAgICBpZiAoYWJpcyAmJiBhYmlzLmxlbmd0aCAhPT0gdHJhbnNhY3Rpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUJJIG11c3QgYmUgcHJvdmlkZWQgZm9yIGVhY2ggdHJhbnNhY3Rpb24gb3Igbm8gdHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25zRGV0YWlsLmNhaXJvVmVyc2lvbik7XG4gICAgY29uc3QgbXNnSGFzaCA9IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC53YWxsZXRBZGRyZXNzLFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsLnZlcnNpb24sXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUsXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWwuY2hhaW5JZCxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC5ub25jZVxuICAgICk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgYWRkcmVzc1NhbHQsXG4gICAgbWF4RmVlLFxuICAgIHZlcnNpb24sXG4gICAgY2hhaW5JZCxcbiAgICBub25jZVxuICB9KSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2goXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbWF4RmVlLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG5vbmNlXG4gICAgKTtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5zaWduKG1zZ0hhc2gsIHRoaXMucGspO1xuICB9XG4gIGFzeW5jIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgIGNsYXNzSGFzaCxcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgbWF4RmVlLFxuICAgIHZlcnNpb24sXG4gICAgbm9uY2UsXG4gICAgY29tcGlsZWRDbGFzc0hhc2hcbiAgfSkge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgc2VuZGVyQWRkcmVzcyxcbiAgICAgIHZlcnNpb24sXG4gICAgICBtYXhGZWUsXG4gICAgICBjaGFpbklkLFxuICAgICAgbm9uY2UsXG4gICAgICBjb21waWxlZENsYXNzSGFzaFxuICAgICk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2V2ZW50cy50c1xuZnVuY3Rpb24gcGFyc2VVRENFdmVudCh0eFJlY2VpcHQpIHtcbiAgaWYgKCF0eFJlY2VpcHQuZXZlbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVURDIGVtaXR0ZWQgZXZlbnQgaXMgZW1wdHlcIik7XG4gIH1cbiAgY29uc3QgZXZlbnQgPSB0eFJlY2VpcHQuZXZlbnRzLmZpbmQoXG4gICAgKGl0KSA9PiBjbGVhbkhleChpdC5mcm9tX2FkZHJlc3MpID09PSBjbGVhbkhleChVREMuQUREUkVTUylcbiAgKSB8fCB7XG4gICAgZGF0YTogW11cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2FjdGlvbl9oYXNoOiB0eFJlY2VpcHQudHJhbnNhY3Rpb25faGFzaCxcbiAgICBjb250cmFjdF9hZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGFkZHJlc3M6IGV2ZW50LmRhdGFbMF0sXG4gICAgZGVwbG95ZXI6IGV2ZW50LmRhdGFbMV0sXG4gICAgdW5pcXVlOiBldmVudC5kYXRhWzJdLFxuICAgIGNsYXNzSGFzaDogZXZlbnQuZGF0YVszXSxcbiAgICBjYWxsZGF0YV9sZW46IGV2ZW50LmRhdGFbNF0sXG4gICAgY2FsbGRhdGE6IGV2ZW50LmRhdGEuc2xpY2UoNSwgNSArIHBhcnNlSW50KGV2ZW50LmRhdGFbNF0sIDE2KSksXG4gICAgc2FsdDogZXZlbnQuZGF0YVtldmVudC5kYXRhLmxlbmd0aCAtIDFdXG4gIH07XG59XG5cbi8vIHNyYy9hY2NvdW50L2RlZmF1bHQudHNcbnZhciBBY2NvdW50ID0gY2xhc3MgZXh0ZW5kcyBQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyT3JPcHRpb25zLCBhZGRyZXNzLCBwa09yU2lnbmVyLCBjYWlyb1ZlcnNpb24pIHtcbiAgICBzdXBlcihwcm92aWRlck9yT3B0aW9ucyk7XG4gICAgdGhpcy5kZXBsb3lTZWxmID0gdGhpcy5kZXBsb3lBY2NvdW50O1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnNpZ25lciA9IHR5cGVvZiBwa09yU2lnbmVyID09PSBcInN0cmluZ1wiIHx8IHBrT3JTaWduZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gbmV3IFNpZ25lcihwa09yU2lnbmVyKSA6IHBrT3JTaWduZXI7XG4gICAgaWYgKGNhaXJvVmVyc2lvbikge1xuICAgICAgdGhpcy5jYWlyb1ZlcnNpb24gPSBjYWlyb1ZlcnNpb24udG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldE5vbmNlRm9yQWRkcmVzcyh0aGlzLmFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VTYWZlKG5vbmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b0JpZ0ludChub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gMG47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIENhaXJvIHZlcnNpb24gZnJvbSB0aGUgbmV0d29yayBhbmQgc2V0cyBgY2Fpcm9WZXJzaW9uYCBpZiBub3QgYWxyZWFkeSBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSBjbGFzc0hhc2ggaWYgcHJvdmlkZWQgZGV0ZWN0cyBDYWlybyB2ZXJzaW9uIGZyb20gY2xhc3NIYXNoLCBvdGhlcndpc2UgZnJvbSB0aGUgYWNjb3VudCBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBnZXRDYWlyb1ZlcnNpb24oY2xhc3NIYXNoKSB7XG4gICAgaWYgKCF0aGlzLmNhaXJvVmVyc2lvbikge1xuICAgICAgY29uc3QgeyBjYWlybyB9ID0gY2xhc3NIYXNoID8gYXdhaXQgc3VwZXIuZ2V0Q29udHJhY3RWZXJzaW9uKHZvaWQgMCwgY2xhc3NIYXNoKSA6IGF3YWl0IHN1cGVyLmdldENvbnRyYWN0VmVyc2lvbih0aGlzLmFkZHJlc3MpO1xuICAgICAgdGhpcy5jYWlyb1ZlcnNpb24gPSBjYWlybztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2Fpcm9WZXJzaW9uO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRmVlKGNhbGxzLCBlc3RpbWF0ZUZlZURldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZUludm9rZUZlZShjYWxscywgZXN0aW1hdGVGZWVEZXRhaWxzKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUludm9rZUZlZShjYWxscywgeyBub25jZTogcHJvdmlkZWROb25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSA9IHt9KSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gQXJyYXkuaXNBcnJheShjYWxscykgPyBjYWxscyA6IFtjYWxsc107XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChwcm92aWRlZE5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvQmlnSW50KGZlZVRyYW5zYWN0aW9uVmVyc2lvbik7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkLFxuICAgICAgY2Fpcm9WZXJzaW9uOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpXG4gICAgfTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24odHJhbnNhY3Rpb25zLCBzaWduZXJEZXRhaWxzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN1cGVyLmdldEludm9rZUVzdGltYXRlRmVlKFxuICAgICAgeyAuLi5pbnZvY2F0aW9uIH0sXG4gICAgICB7IHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZSA9IGVzdGltYXRlZEZlZVRvTWF4RmVlKHJlc3BvbnNlLm92ZXJhbGxfZmVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRGVjbGFyZUZlZSh7IGNvbnRyYWN0LCBjbGFzc0hhc2g6IHByb3ZpZGVkQ2xhc3NIYXNoLCBjYXNtLCBjb21waWxlZENsYXNzSGFzaCB9LCB7IGJsb2NrSWRlbnRpZmllciwgbm9uY2U6IHByb3ZpZGVkTm9uY2UsIHNraXBWYWxpZGF0ZSB9ID0ge30pIHtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHByb3ZpZGVkTm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gIWlzU2llcnJhKGNvbnRyYWN0KSA/IGZlZVRyYW5zYWN0aW9uVmVyc2lvbiA6IGZlZVRyYW5zYWN0aW9uVmVyc2lvbl8yO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZChcbiAgICAgIHsgY2xhc3NIYXNoOiBwcm92aWRlZENsYXNzSGFzaCwgY29udHJhY3QsIGNhc20sIGNvbXBpbGVkQ2xhc3NIYXNoIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdXBlci5nZXREZWNsYXJlRXN0aW1hdGVGZWUoXG4gICAgICBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbixcbiAgICAgIHsgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgICk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkTWF4RmVlID0gZXN0aW1hdGVkRmVlVG9NYXhGZWUocmVzcG9uc2Uub3ZlcmFsbF9mZWUpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIHN1Z2dlc3RlZE1heEZlZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzXG4gIH0sIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSA9IHt9KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvQmlnSW50KGZlZVRyYW5zYWN0aW9uVmVyc2lvbik7XG4gICAgY29uc3Qgbm9uY2UgPSBaRVJPO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKFxuICAgICAgeyBjbGFzc0hhc2gsIGFkZHJlc3NTYWx0LCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMFxuICAgICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN1cGVyLmdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShcbiAgICAgIHsgLi4ucGF5bG9hZCB9LFxuICAgICAgeyB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgICBjb25zdCBzdWdnZXN0ZWRNYXhGZWUgPSBlc3RpbWF0ZWRGZWVUb01heEZlZShyZXNwb25zZS5vdmVyYWxsX2ZlZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgc3VnZ2VzdGVkTWF4RmVlXG4gICAgfTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlcGxveUZlZShwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwpIHtcbiAgICBjb25zdCBjYWxscyA9IHRoaXMuYnVpbGRVRENDb250cmFjdFBheWxvYWQocGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIHRyYW5zYWN0aW9uc0RldGFpbCk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCB7IG5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9ID0ge30pIHtcbiAgICBjb25zdCBhY2NvdW50SW52b2NhdGlvbnMgPSBhd2FpdCB0aGlzLmFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkoaW52b2NhdGlvbnMsIHtcbiAgICAgIHZlcnNpb25zOiBbZmVlVHJhbnNhY3Rpb25WZXJzaW9uLCBmZWVUcmFuc2FjdGlvblZlcnNpb25fMl0sXG4gICAgICBub25jZSxcbiAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3VwZXIuZ2V0RXN0aW1hdGVGZWVCdWxrKGFjY291bnRJbnZvY2F0aW9ucywge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChyZXNwb25zZSkubWFwKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCBzdWdnZXN0ZWRNYXhGZWUgPSBlc3RpbWF0ZWRGZWVUb01heEZlZShlbGVtLm92ZXJhbGxfZmVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVsZW0sXG4gICAgICAgIHN1Z2dlc3RlZE1heEZlZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBidWlsZEludm9jYXRpb24oY2FsbCwgc2lnbmVyRGV0YWlscykge1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKGNhbGwsIGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCkpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbihjYWxsLCBzaWduZXJEZXRhaWxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZXhlY3V0ZShjYWxscywgYWJpcyA9IHZvaWQgMCwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBBcnJheS5pc0FycmF5KGNhbGxzKSA/IGNhbGxzIDogW2NhbGxzXTtcbiAgICBjb25zdCBub25jZSA9IHRvQmlnSW50KHRyYW5zYWN0aW9uc0RldGFpbC5ub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IG1heEZlZSA9IHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUgPz8gYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRNYXhGZWUoXG4gICAgICB7IHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovLCBwYXlsb2FkOiBjYWxscyB9LFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsXG4gICAgKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9CaWdJbnQodHJhbnNhY3Rpb25WZXJzaW9uKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQsXG4gICAgICBjYWlyb1ZlcnNpb246IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKClcbiAgICB9O1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIHNpZ25lckRldGFpbHMsIGFiaXMpO1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSk7XG4gICAgcmV0dXJuIHRoaXMuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7IGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLCBjYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBtYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGaXJzdCBjaGVjayBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkLCBpZiBub3QgZGVjbGFyZSBpdFxuICAgKiBJZiBjb250cmFjdCBhbHJlYWR5IGRlY2xhcmVkIHJldHVybmVkIHRyYW5zYWN0aW9uX2hhc2ggaXMgJycuXG4gICAqIE1ldGhvZCB3aWxsIHBhc3MgZXZlbiBpZiBjb250cmFjdCBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbnNEZXRhaWwgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZGVjbGFyZUlmTm90KHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmUocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IFwiXCIsXG4gICAgICBjbGFzc19oYXNoOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkLmNsYXNzSGFzaFxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVjbGFyZShwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwgPSB7fSkge1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFBheWxvYWQgPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgY29uc3QgZGV0YWlscyA9IHt9O1xuICAgIGRldGFpbHMubm9uY2UgPSB0b0JpZ0ludCh0cmFuc2FjdGlvbnNEZXRhaWwubm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBkZXRhaWxzLm1heEZlZSA9IHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUgPz8gYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRNYXhGZWUoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgIHBheWxvYWQ6IGRlY2xhcmVDb250cmFjdFBheWxvYWRcbiAgICAgIH0sXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWxcbiAgICApO1xuICAgIGRldGFpbHMudmVyc2lvbiA9ICFpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSA/IHRyYW5zYWN0aW9uVmVyc2lvbiA6IHRyYW5zYWN0aW9uVmVyc2lvbl8yO1xuICAgIGRldGFpbHMuY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKGRlY2xhcmVDb250cmFjdFBheWxvYWQsIHtcbiAgICAgIC4uLmRldGFpbHMsXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWlyb1ZlcnNpb246IHZvaWQgMFxuICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlY2xhcmVDb250cmFjdChkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiwgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95KHBheWxvYWQsIGRldGFpbHMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQsXG4gICAgICAgIHVuaXF1ZSA9IHRydWUsXG4gICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXVxuICAgICAgfSA9IGl0O1xuICAgICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICAgIGNvbnN0IGRlcGxveVNhbHQgPSBzYWx0ID8/IHJhbmRvbUFkZHJlc3MoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGw6IHtcbiAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IFVEQy5BRERSRVNTLFxuICAgICAgICAgIGVudHJ5cG9pbnQ6IFVEQy5FTlRSWVBPSU5ULFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgICAgICBkZXBsb3lTYWx0LFxuICAgICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAuLi5jb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGFcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGFkZHJlc3M6IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKFxuICAgICAgICAgIHVuaXF1ZSA/IHN0YXJrQ3VydmUucGVkZXJzZW4odGhpcy5hZGRyZXNzLCBkZXBsb3lTYWx0KSA6IGRlcGxveVNhbHQsXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSxcbiAgICAgICAgICB1bmlxdWUgPyBVREMuQUREUkVTUyA6IDBcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjYWxscyA9IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5jYWxsKTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBwYXJhbXMubWFwKChpdCkgPT4gaXQuYWRkcmVzcyk7XG4gICAgY29uc3QgaW52b2tlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGUoY2FsbHMsIHZvaWQgMCwgZGV0YWlscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmludm9rZVJlc3BvbnNlLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogYWRkcmVzc2VzXG4gICAgfTtcbiAgfVxuICBhc3luYyBkZXBsb3lDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgZGVwbG95VHggPSBhd2FpdCB0aGlzLmRlcGxveShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICBjb25zdCB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZXBsb3lUeC50cmFuc2FjdGlvbl9oYXNoKTtcbiAgICByZXR1cm4gcGFyc2VVRENFdmVudCh0eFJlY2VpcHQpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVBbmREZXBsb3kocGF5bG9hZCwgZGV0YWlscykge1xuICAgIGNvbnN0IHsgY29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdW5pcXVlIH0gPSBwYXlsb2FkO1xuICAgIGxldCBkZWNsYXJlID0gYXdhaXQgdGhpcy5kZWNsYXJlSWZOb3QocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgaWYgKGRlY2xhcmUudHJhbnNhY3Rpb25faGFzaCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbihkZWNsYXJlLnRyYW5zYWN0aW9uX2hhc2gpO1xuICAgICAgZGVjbGFyZSA9IHsgLi4uZGVjbGFyZSwgLi4udHggfTtcbiAgICB9XG4gICAgY29uc3QgZGVwbG95ID0gYXdhaXQgdGhpcy5kZXBsb3lDb250cmFjdChcbiAgICAgIHsgY2xhc3NIYXNoOiBkZWNsYXJlLmNsYXNzX2hhc2gsIHNhbHQsIHVuaXF1ZSwgY29uc3RydWN0b3JDYWxsZGF0YSB9LFxuICAgICAgZGV0YWlsc1xuICAgICk7XG4gICAgcmV0dXJuIHsgZGVjbGFyZTogeyAuLi5kZWNsYXJlIH0sIGRlcGxveSB9O1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9CaWdJbnQodHJhbnNhY3Rpb25WZXJzaW9uKTtcbiAgICBjb25zdCBub25jZSA9IFpFUk87XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzID8/IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKGFkZHJlc3NTYWx0LCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2FsbGRhdGEsIDApO1xuICAgIGNvbnN0IG1heEZlZSA9IHRyYW5zYWN0aW9uc0RldGFpbC5tYXhGZWUgPz8gYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRNYXhGZWUoXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsXG4gICAgKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNoYWluSWQsXG4gICAgICBtYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbm9uY2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZXBsb3lBY2NvdW50Q29udHJhY3QoXG4gICAgICB7IGNsYXNzSGFzaCwgYWRkcmVzc1NhbHQsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNpZ25hdHVyZSB9LFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgbWF4RmVlLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduZXIuc2lnbk1lc3NhZ2UodHlwZWREYXRhLCB0aGlzLmFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIGhhc2hNZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiBnZXRNZXNzYWdlSGFzaCh0eXBlZERhdGEsIHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgdmVyaWZ5TWVzc2FnZUhhc2goaGFzaCwgc2lnbmF0dXJlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY2FsbENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiaXNWYWxpZFNpZ25hdHVyZVwiLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgICAgaGFzaDogdG9CaWdJbnQoaGFzaCkudG9TdHJpbmcoKSxcbiAgICAgICAgICBzaWduYXR1cmU6IGZvcm1hdFNpZ25hdHVyZShzaWduYXR1cmUpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyB2ZXJpZnlNZXNzYWdlKHR5cGVkRGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuaGFzaE1lc3NhZ2UodHlwZWREYXRhKTtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlNZXNzYWdlSGFzaChoYXNoLCBzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIGdldFN1Z2dlc3RlZE1heEZlZSh7IHR5cGUsIHBheWxvYWQgfSwgZGV0YWlscykge1xuICAgIGxldCBmZWVFc3RpbWF0ZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZUludm9rZUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZURlY2xhcmVGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZUFjY291bnREZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFUExPWVwiIC8qIERFUExPWSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlRGVwbG95RmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZlZUVzdGltYXRlID0geyBzdWdnZXN0ZWRNYXhGZWU6IFpFUk8sIG92ZXJhbGxfZmVlOiBaRVJPIH07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmVlRXN0aW1hdGUuc3VnZ2VzdGVkTWF4RmVlO1xuICB9XG4gIC8qKlxuICAgKiB3aWxsIGJlIHJlbmFtZWQgdG8gYnVpbGREZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgYnVpbGREZWNsYXJlUGF5bG9hZChwYXlsb2FkLCB7IG5vbmNlLCBjaGFpbklkLCB2ZXJzaW9uLCB3YWxsZXRBZGRyZXNzLCBtYXhGZWUgfSkge1xuICAgIGNvbnN0IHsgY2xhc3NIYXNoLCBjb250cmFjdCwgY29tcGlsZWRDbGFzc0hhc2ggfSA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCBjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCA9IHBhcnNlQ29udHJhY3QoY29udHJhY3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZWNsYXJlVHJhbnNhY3Rpb24oe1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBzZW5kZXJBZGRyZXNzOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG1heEZlZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBub25jZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzZW5kZXJBZGRyZXNzOiB3YWxsZXRBZGRyZXNzLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgY29udHJhY3Q6IGNvbXByZXNzZWRDb21waWxlZENvbnRyYWN0LFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2hcbiAgICB9O1xuICB9XG4gIGFzeW5jIGJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgeyBub25jZSwgY2hhaW5JZCwgdmVyc2lvbiwgbWF4RmVlIH0pIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBwcm92aWRlZENvbnRyYWN0QWRkcmVzcyA/PyBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChhZGRyZXNzU2FsdCwgY2xhc3NIYXNoLCBjb21waWxlZENhbGxkYXRhLCAwKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGNoYWluSWQsXG4gICAgICBtYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbm9uY2UsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGFcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBidWlsZFVEQ0NvbnRyYWN0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgY29uc3QgY2FsbHMgPSBbXS5jb25jYXQocGF5bG9hZCkubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIHNhbHQgPSBcIjBcIixcbiAgICAgICAgdW5pcXVlID0gdHJ1ZSxcbiAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdXG4gICAgICB9ID0gaXQ7XG4gICAgICBjb25zdCBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIHNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBjYWxscztcbiAgfVxuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCB7IG5vbmNlLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSwgc2tpcEV4ZWN1dGUgfSA9IHt9KSB7XG4gICAgY29uc3QgYWNjb3VudEludm9jYXRpb25zID0gYXdhaXQgdGhpcy5hY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7XG4gICAgICB2ZXJzaW9uczogW3RyYW5zYWN0aW9uVmVyc2lvbiwgdHJhbnNhY3Rpb25WZXJzaW9uXzJdLFxuICAgICAgbm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbihhY2NvdW50SW52b2NhdGlvbnMsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZSxcbiAgICAgIHNraXBFeGVjdXRlXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywgeyB2ZXJzaW9ucywgbm9uY2UsIGJsb2NrSWRlbnRpZmllciB9KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25zWzBdO1xuICAgIGNvbnN0IHNhZmVOb25jZSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VTYWZlKG5vbmNlKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgdHgwUGF5bG9hZCA9IFwicGF5bG9hZFwiIGluIGludm9jYXRpb25zWzBdID8gaW52b2NhdGlvbnNbMF0ucGF5bG9hZCA6IGludm9jYXRpb25zWzBdO1xuICAgIGNvbnN0IGNhaXJvVmVyc2lvbiA9IGludm9jYXRpb25zWzBdLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyA/IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKHR4MFBheWxvYWQuY2xhc3NIYXNoKSA6IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgW10uY29uY2F0KGludm9jYXRpb25zKS5tYXAoYXN5bmMgKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB0eFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiB0cmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnBheWxvYWQgOiB0cmFuc2FjdGlvbjtcbiAgICAgICAgY29uc3Qgc2lnbmVyRGV0YWlscyA9IHtcbiAgICAgICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvQmlnSW50KE51bWJlcihzYWZlTm9uY2UpICsgaW5kZXgpLFxuICAgICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgY2Fpcm9WZXJzaW9uXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbW1vbiA9IHtcbiAgICAgICAgICB0eXBlOiB0cmFuc2FjdGlvbi50eXBlLFxuICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgbm9uY2U6IHRvQmlnSW50KE51bWJlcihzYWZlTm9uY2UpICsgaW5kZXgpLFxuICAgICAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgICAgICB9O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8pIHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEludm9jYXRpb24oXG4gICAgICAgICAgICBbXS5jb25jYXQodHhQYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25lckRldGFpbHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9ICFpc1NpZXJyYSh0eFBheWxvYWQuY29udHJhY3QpID8gdG9CaWdJbnQodmVyc2lvbnNbMF0pIDogdG9CaWdJbnQodmVyc2lvbnNbMV0pO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkRGVjbGFyZVBheWxvYWQodHhQYXlsb2FkLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIHZlcnNpb246IHNpZ25lckRldGFpbHMudmVyc2lvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQodHhQYXlsb2FkLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICAgICAgY29uc3QgY2FsbHMgPSB0aGlzLmJ1aWxkVURDQ29udHJhY3RQYXlsb2FkKHR4UGF5bG9hZCk7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKGNhbGxzLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcihgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeTogdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0cmFuc2FjdGlvbn1gKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRTdGFya05hbWUoYWRkcmVzcyA9IHRoaXMuYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBzdXBlci5nZXRTdGFya05hbWUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbnRlcmZhY2UudHNcbnZhciBQcm92aWRlckludGVyZmFjZSA9IGNsYXNzIHtcbn07XG5cbi8vIHNyYy9wcm92aWRlci9pbmRleC50c1xudmFyIGRlZmF1bHRQcm92aWRlciA9IG5ldyBQcm92aWRlcih7IHJwYzogeyBkZWZhdWx0OiB0cnVlIH0gfSk7XG5cbi8vIHNyYy9hY2NvdW50L2ludGVyZmFjZS50c1xudmFyIEFjY291bnRJbnRlcmZhY2UgPSBjbGFzcyBleHRlbmRzIFByb3ZpZGVySW50ZXJmYWNlIHtcbn07XG5cbi8vIHNyYy91dGlscy9ldmVudHMvaW5kZXgudHNcbnZhciBldmVudHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZXZlbnRzX2V4cG9ydHMsIHtcbiAgZ2V0QWJpRXZlbnRzOiAoKSA9PiBnZXRBYmlFdmVudHMsXG4gIHBhcnNlRXZlbnRzOiAoKSA9PiBwYXJzZUV2ZW50c1xufSk7XG5mdW5jdGlvbiBnZXRBYmlFdmVudHMoYWJpKSB7XG4gIHJldHVybiBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJldmVudFwiICYmIChhYmlFbnRyeS5zaXplIHx8IGFiaUVudHJ5LmtpbmQgIT09IFwiZW51bVwiKSkucmVkdWNlKChhY2MsIGFiaUVudHJ5KSA9PiB7XG4gICAgY29uc3QgZW50cnlOYW1lID0gYWJpRW50cnkubmFtZS5zbGljZShhYmlFbnRyeS5uYW1lLmxhc3RJbmRleE9mKFwiOlwiKSArIDEpO1xuICAgIGNvbnN0IGFiaUVudHJ5TW9kID0geyAuLi5hYmlFbnRyeSB9O1xuICAgIGFiaUVudHJ5TW9kLm5hbWUgPSBlbnRyeU5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFthZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoZW50cnlOYW1lKSkudG9TdHJpbmcoMTYpKV06IGFiaUVudHJ5TW9kXG4gICAgfTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudHMocHJvdmlkZXJSZWNlaXZlZEV2ZW50cywgYWJpRXZlbnRzLCBhYmlTdHJ1Y3RzLCBhYmlFbnVtcykge1xuICBjb25zdCByZXQgPSBwcm92aWRlclJlY2VpdmVkRXZlbnRzLmZsYXQoKS5yZWR1Y2UoKGFjYywgcmVjRXZlbnQpID0+IHtcbiAgICBjb25zdCBhYmlFdmVudCA9IGFiaUV2ZW50c1tyZWNFdmVudC5rZXlzWzBdXTtcbiAgICBpZiAoIWFiaUV2ZW50KSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRFdmVudCA9IHt9O1xuICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdID0ge307XG4gICAgcmVjRXZlbnQua2V5cy5zaGlmdCgpO1xuICAgIGNvbnN0IGtleXNJdGVyID0gcmVjRXZlbnQua2V5c1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgZGF0YUl0ZXIgPSByZWNFdmVudC5kYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBhYmlFdmVudEtleXMgPSBhYmlFdmVudC5tZW1iZXJzPy5maWx0ZXIoKGl0KSA9PiBpdC5raW5kID09PSBcImtleVwiKSB8fCBhYmlFdmVudC5rZXlzO1xuICAgIGNvbnN0IGFiaUV2ZW50RGF0YSA9IGFiaUV2ZW50Lm1lbWJlcnM/LmZpbHRlcigoaXQpID0+IGl0LmtpbmQgPT09IFwiZGF0YVwiKSB8fCBhYmlFdmVudC5kYXRhO1xuICAgIGFiaUV2ZW50S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdW2tleS5uYW1lXSA9IHJlc3BvbnNlUGFyc2VyKFxuICAgICAgICBrZXlzSXRlcixcbiAgICAgICAga2V5LFxuICAgICAgICBhYmlTdHJ1Y3RzLFxuICAgICAgICBhYmlFbnVtcyxcbiAgICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgYWJpRXZlbnREYXRhLmZvckVhY2goKGRhdGEpID0+IHtcbiAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdW2RhdGEubmFtZV0gPSByZXNwb25zZVBhcnNlcihcbiAgICAgICAgZGF0YUl0ZXIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGFiaVN0cnVjdHMsXG4gICAgICAgIGFiaUVudW1zLFxuICAgICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBhY2MucHVzaChwYXJzZWRFdmVudCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBzcmMvY29udHJhY3QvZGVmYXVsdC50c1xudmFyIHNwbGl0QXJnc0FuZE9wdGlvbnMgPSAoYXJncykgPT4ge1xuICBjb25zdCBvcHRpb25zID0gW1xuICAgIFwiYmxvY2tJZGVudGlmaWVyXCIsXG4gICAgXCJwYXJzZVJlcXVlc3RcIixcbiAgICBcInBhcnNlUmVzcG9uc2VcIixcbiAgICBcImZvcm1hdFJlc3BvbnNlXCIsXG4gICAgXCJtYXhGZWVcIixcbiAgICBcIm5vbmNlXCIsXG4gICAgXCJzaWduYXR1cmVcIixcbiAgICBcImFkZHJlc3NTYWx0XCJcbiAgXTtcbiAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBsYXN0QXJnID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuc29tZSgoeCkgPT4geCBpbiBsYXN0QXJnKSkge1xuICAgIHJldHVybiB7IGFyZ3MsIG9wdGlvbnM6IGFyZ3MucG9wKCkgfTtcbiAgfVxuICByZXR1cm4geyBhcmdzIH07XG59O1xuZnVuY3Rpb24gYnVpbGRDYWxsKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmNhbGwoZnVuY3Rpb25BYmkubmFtZSwgcGFyYW1zLmFyZ3MsIHtcbiAgICAgIHBhcnNlUmVxdWVzdDogdHJ1ZSxcbiAgICAgIHBhcnNlUmVzcG9uc2U6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICByZXR1cm4gY29udHJhY3QuaW52b2tlKGZ1bmN0aW9uQWJpLm5hbWUsIHBhcmFtcy5hcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHRydWUsXG4gICAgICAuLi5wYXJhbXMub3B0aW9uc1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREZWZhdWx0KGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICBpZiAoZnVuY3Rpb25BYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBmdW5jdGlvbkFiaS5zdGF0ZV9tdXRhYmlsaXR5ID09PSBcInZpZXdcIikge1xuICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbiAgfVxuICByZXR1cm4gYnVpbGRJbnZva2UoY29udHJhY3QsIGZ1bmN0aW9uQWJpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9wdWxhdGUoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0LnBvcHVsYXRlKGZ1bmN0aW9uQWJpLm5hbWUsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFc3RpbWF0ZShjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gY29udHJhY3QuZXN0aW1hdGUoZnVuY3Rpb25BYmkubmFtZSwgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDYWxsZGF0YShhcmdzLCBjYWxsYmFjaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3MpXG4gICAgcmV0dXJuIGFyZ3M7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBhcmdzWzBdKVxuICAgIHJldHVybiBhcmdzWzBdO1xuICByZXR1cm4gY2FsbGJhY2soKTtcbn1cbnZhciBDb250cmFjdCA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnRyYWN0IGNsYXNzIHRvIGhhbmRsZSBjb250cmFjdCBtZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSBhYmkgLSBBYmkgb2YgdGhlIGNvbnRyYWN0IG9iamVjdFxuICAgKiBAcGFyYW0gYWRkcmVzcyAob3B0aW9uYWwpIC0gYWRkcmVzcyB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSBwcm92aWRlck9yQWNjb3VudCAob3B0aW9uYWwpIC0gUHJvdmlkZXIgb3IgQWNjb3VudCB0byBhdHRhY2ggdG9cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFiaSwgYWRkcmVzcywgcHJvdmlkZXJPckFjY291bnQgPSBkZWZhdWx0UHJvdmlkZXIpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzICYmIGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3ZpZGVyT3JBY2NvdW50ID0gcHJvdmlkZXJPckFjY291bnQ7XG4gICAgdGhpcy5jYWxsRGF0YSA9IG5ldyBDYWxsRGF0YShhYmkpO1xuICAgIHRoaXMuc3RydWN0cyA9IENhbGxEYXRhLmdldEFiaVN0cnVjdChhYmkpO1xuICAgIHRoaXMuZXZlbnRzID0gZ2V0QWJpRXZlbnRzKGFiaSk7XG4gICAgY29uc3QgcGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSBwYXJzZXIuZ2V0TGVnYWN5Rm9ybWF0KCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBmdW5jdGlvbnM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIGNhbGxTdGF0aWM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb246IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIGVzdGltYXRlRmVlOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH1cbiAgICB9KTtcbiAgICB0aGlzLmFiaS5mb3JFYWNoKChhYmlFbGVtZW50KSA9PiB7XG4gICAgICBpZiAoYWJpRWxlbWVudC50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGFiaUVsZW1lbnQubmFtZTtcbiAgICAgIGlmICghdGhpc1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZERlZmF1bHQodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZnVuY3Rpb25zLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZERlZmF1bHQodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmNhbGxTdGF0aWMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkQ2FsbCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRQb3B1bGF0ZSh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5lc3RpbWF0ZUZlZVtzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVzdGltYXRlRmVlLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZEVzdGltYXRlKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuICBjb25uZWN0KHByb3ZpZGVyT3JBY2NvdW50KSB7XG4gICAgdGhpcy5wcm92aWRlck9yQWNjb3VudCA9IHByb3ZpZGVyT3JBY2NvdW50O1xuICB9XG4gIGFzeW5jIGRlcGxveWVkKCkge1xuICAgIGlmICh0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgYXdhaXQgdGhpcy5wcm92aWRlck9yQWNjb3VudC53YWl0Rm9yVHJhbnNhY3Rpb24odGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2gpO1xuICAgICAgdGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2ggPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIGNhbGwobWV0aG9kLCBhcmdzID0gW10sIHtcbiAgICBwYXJzZVJlcXVlc3QgPSB0cnVlLFxuICAgIHBhcnNlUmVzcG9uc2UgPSB0cnVlLFxuICAgIGZvcm1hdFJlc3BvbnNlID0gdm9pZCAwLFxuICAgIGJsb2NrSWRlbnRpZmllciA9IHZvaWQgMFxuICB9ID0ge30pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldENhbGxkYXRhKGFyZ3MsICgpID0+IHtcbiAgICAgIGlmIChwYXJzZVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIkNBTExcIiAvKiBDQUxMICovLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5jb21waWxlKG1ldGhvZCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJDYWxsIHNraXBwZWQgcGFyc2luZyBidXQgcHJvdmlkZWQgcmF3QXJncywgcG9zc2libGUgbWFsZnVuY3Rpb24gcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmNhbGxDb250cmFjdChcbiAgICAgIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhLFxuICAgICAgICBlbnRyeXBvaW50OiBtZXRob2RcbiAgICAgIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICApLnRoZW4oKHgpID0+IHtcbiAgICAgIGlmICghcGFyc2VSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geC5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuZm9ybWF0KG1ldGhvZCwgeC5yZXN1bHQsIGZvcm1hdFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLnBhcnNlKG1ldGhvZCwgeC5yZXN1bHQpO1xuICAgIH0pO1xuICB9XG4gIGludm9rZShtZXRob2QsIGFyZ3MgPSBbXSwgeyBwYXJzZVJlcXVlc3QgPSB0cnVlLCBtYXhGZWUsIG5vbmNlLCBzaWduYXR1cmUgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkludm9rZSBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgIH07XG4gICAgaWYgKFwiZXhlY3V0ZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmV4ZWN1dGUoaW52b2NhdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW5vbmNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb25jZSBpcyByZXF1aXJlZCB3aGVuIGludm9raW5nIGEgZnVuY3Rpb24gd2l0aG91dCBhbiBhY2NvdW50YCk7XG4gICAgY29uc29sZS53YXJuKGBJbnZva2luZyAke21ldGhvZH0gd2l0aG91dCBhbiBhY2NvdW50LiBUaGlzIHdpbGwgbm90IHdvcmsgb24gYSBwdWJsaWMgbm9kZS5gKTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5pbnZva2VGdW5jdGlvbihcbiAgICAgIHtcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBub25jZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGUobWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBpZiAoIWdldENhbGxkYXRhKGFyZ3MsICgpID0+IGZhbHNlKSkge1xuICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIklOVk9LRVwiIC8qIElOVk9LRSAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IHRoaXMucG9wdWxhdGUobWV0aG9kLCBhcmdzKTtcbiAgICBpZiAoXCJlc3RpbWF0ZUludm9rZUZlZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmVzdGltYXRlSW52b2tlRmVlKGludm9jYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0IG11c3QgYmUgY29ubmVjdGVkIHRvIHRoZSBhY2NvdW50IGNvbnRyYWN0IHRvIGVzdGltYXRlXCIpO1xuICB9XG4gIHBvcHVsYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kLFxuICAgICAgY2FsbGRhdGFcbiAgICB9O1xuICB9XG4gIHBhcnNlRXZlbnRzKHJlY2VpcHQpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMoXG4gICAgICByZWNlaXB0LmV2ZW50cz8uZmlsdGVyKFxuICAgICAgICAoZXZlbnQpID0+IGNsZWFuSGV4KGV2ZW50LmZyb21fYWRkcmVzcykgPT09IGNsZWFuSGV4KHRoaXMuYWRkcmVzcyksXG4gICAgICAgIFtdXG4gICAgICApIHx8IFtdLFxuICAgICAgdGhpcy5ldmVudHMsXG4gICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICBDYWxsRGF0YS5nZXRBYmlFbnVtKHRoaXMuYWJpKVxuICAgICk7XG4gIH1cbiAgaXNDYWlybzEoKSB7XG4gICAgcmV0dXJuIGNhaXJvX2V4cG9ydHMuaXNDYWlybzFBYmkodGhpcy5hYmkpO1xuICB9XG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgdHlwZWQodEFiaSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBzcmMvY29udHJhY3QvaW50ZXJmYWNlLnRzXG52YXIgQ29udHJhY3RJbnRlcmZhY2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvY29udHJhY3QvY29udHJhY3RGYWN0b3J5LnRzXG52YXIgQ29udHJhY3RGYWN0b3J5ID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIHBhcmFtcyBDRlBhcmFtc1xuICAgKiAgLSBjb21waWxlZENvbnRyYWN0OiBDb21waWxlZENvbnRyYWN0O1xuICAgKiAgLSBhY2NvdW50OiBBY2NvdW50SW50ZXJmYWNlO1xuICAgKiAgLSBjYXNtPzogQ2Fpcm9Bc3NlbWJseTtcbiAgICogIC0gY2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBjb21waWxlZENsYXNzSGFzaD86IHN0cmluZztcbiAgICogIC0gYWJpPzogQWJpO1xuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgdGhpcy5jb21waWxlZENvbnRyYWN0ID0gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3Q7XG4gICAgdGhpcy5hY2NvdW50ID0gcGFyYW1zLmFjY291bnQ7XG4gICAgdGhpcy5jYXNtID0gcGFyYW1zLmNhc207XG4gICAgdGhpcy5hYmkgPSBwYXJhbXMuYWJpID8/IHBhcmFtcy5jb21waWxlZENvbnRyYWN0LmFiaTtcbiAgICB0aGlzLmNsYXNzSGFzaCA9IHBhcmFtcy5jbGFzc0hhc2g7XG4gICAgdGhpcy5jb21waWxlZENsYXNzSGFzaCA9IHBhcmFtcy5jb21waWxlZENsYXNzSGFzaDtcbiAgICB0aGlzLkNhbGxEYXRhID0gbmV3IENhbGxEYXRhKHRoaXMuYWJpKTtcbiAgfVxuICAvKipcbiAgICogRGVwbG95cyBjb250cmFjdCBhbmQgcmV0dXJucyBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvbnRyYWN0XG4gICAqXG4gICAqIElmIGNvbnRyYWN0IGlzIG5vdCBkZWNsYXJlZCBpdCB3aWxsIGZpcnN0IGRlY2xhcmUgaXQsIGFuZCB0aGVuIGRlcGxveVxuICAgKi9cbiAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7IGFyZ3M6IHBhcmFtLCBvcHRpb25zID0geyBwYXJzZVJlcXVlc3Q6IHRydWUgfSB9ID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvckNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEocGFyYW0sICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLkNhbGxEYXRhLnZhbGlkYXRlKFwiREVQTE9ZXCIgLyogREVQTE9ZICovLCBcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkNhbGwgc2tpcHBlZCBwYXJzaW5nIGJ1dCBwcm92aWRlZCByYXdBcmdzLCBwb3NzaWJsZSBtYWxmdW5jdGlvbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlcGxveTogeyBjb250cmFjdF9hZGRyZXNzLCB0cmFuc2FjdGlvbl9oYXNoIH1cbiAgICB9ID0gYXdhaXQgdGhpcy5hY2NvdW50LmRlY2xhcmVBbmREZXBsb3koe1xuICAgICAgY29udHJhY3Q6IHRoaXMuY29tcGlsZWRDb250cmFjdCxcbiAgICAgIGNhc206IHRoaXMuY2FzbSxcbiAgICAgIGNsYXNzSGFzaDogdGhpcy5jbGFzc0hhc2gsXG4gICAgICBjb21waWxlZENsYXNzSGFzaDogdGhpcy5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICBzYWx0OiBvcHRpb25zLmFkZHJlc3NTYWx0XG4gICAgfSk7XG4gICAgYXNzZXJ0KEJvb2xlYW4oY29udHJhY3RfYWRkcmVzcyksIFwiRGVwbG95bWVudCBvZiB0aGUgY29udHJhY3QgZmFpbGVkXCIpO1xuICAgIGNvbnN0IGNvbnRyYWN0SW5zdGFuY2UgPSBuZXcgQ29udHJhY3QoXG4gICAgICB0aGlzLmNvbXBpbGVkQ29udHJhY3QuYWJpLFxuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIHRoaXMuYWNjb3VudFxuICAgICk7XG4gICAgY29udHJhY3RJbnN0YW5jZS5kZXBsb3lUcmFuc2FjdGlvbkhhc2ggPSB0cmFuc2FjdGlvbl9oYXNoO1xuICAgIHJldHVybiBjb250cmFjdEluc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyB0byBuZXcgQWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCAtIG5ldyBBY2NvdW50IHRvIGF0dGFjaCB0b1xuICAgKi9cbiAgY29ubmVjdChhY2NvdW50KSB7XG4gICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgY3VycmVudCBhYmkgYW5kIGFjY291bnQgdG8gdGhlIG5ldyBhZGRyZXNzXG4gICAqL1xuICBhdHRhY2goYWRkcmVzcykge1xuICAgIHJldHVybiBuZXcgQ29udHJhY3QodGhpcy5hYmksIGFkZHJlc3MsIHRoaXMuYWNjb3VudCk7XG4gIH1cbiAgLy8gZXRoZXJzLmpzJyBnZXREZXBsb3lUcmFuc2FjdGlvbiBjYW50IGJlIHN1cHBvcnRlZCBhcyBpdCByZXF1aXJlcyB0aGUgYWNjb3VudCBvciBzaWduZXIgdG8gcmV0dXJuIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG5vdCBwb3NzaWJsZSB3aXRoIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uXG59O1xuXG4vLyBzcmMvdXRpbHMvYWRkcmVzcy50c1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5mdW5jdGlvbiBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgocmVtb3ZlSGV4UHJlZml4KHRvSGV4KGFkZHJlc3MpKS5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpIHtcbiAgYXNzZXJ0SW5SYW5nZShhZGRyZXNzLCBaRVJPLCBBRERSX0JPVU5EIC0gMW4sIFwiU3RhcmtuZXQgQWRkcmVzc1wiKTtcbiAgY29uc3QgcmVzdWx0ID0gYWRkQWRkcmVzc1BhZGRpbmcoYWRkcmVzcyk7XG4gIGlmICghcmVzdWx0Lm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs2NH0kLykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFkZHJlc3MgRm9ybWF0XCIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICBjb25zdCBjaGFycyA9IHJlbW92ZUhleFByZWZpeCh2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyhhZGRyZXNzKSkudG9Mb3dlckNhc2UoKS5zcGxpdChcIlwiKTtcbiAgY29uc3QgaGV4ID0gcmVtb3ZlSGV4UHJlZml4KGtlY2Nha0JuKGFkZHJlc3MpKTtcbiAgY29uc3QgaGFzaGVkID0gaGV4VG9CeXRlczIoaGV4LnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKGhhc2hlZFtpID4+IDFdID4+IDQgPj0gOCkge1xuICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMTUpID49IDgpIHtcbiAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWRkSGV4UHJlZml4KGNoYXJzLmpvaW4oXCJcIikpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICByZXR1cm4gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpID09PSBhZGRyZXNzO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBudW1iZXIgPSBudW1fZXhwb3J0cztcbmV4cG9ydCB7XG4gIEFjY291bnQsXG4gIEFjY291bnRJbnRlcmZhY2UsXG4gIEJsb2NrU3RhdHVzLFxuICBCbG9ja1RhZyxcbiAgQ2Fpcm9DdXN0b21FbnVtLFxuICBDYWlyb09wdGlvbixcbiAgQ2Fpcm9PcHRpb25WYXJpYW50LFxuICBDYWlyb1Jlc3VsdCxcbiAgQ2Fpcm9SZXN1bHRWYXJpYW50LFxuICBDYWxsRGF0YSxcbiAgQ29udHJhY3QsXG4gIENvbnRyYWN0RmFjdG9yeSxcbiAgQ29udHJhY3RJbnRlcmZhY2UsXG4gIEN1c3RvbUVycm9yLFxuICBFbnRyeVBvaW50VHlwZSxcbiAgR2F0ZXdheUVycm9yLFxuICBIdHRwRXJyb3IsXG4gIExpYnJhcnlFcnJvcixcbiAgTGl0dGVyYWwsXG4gIFByb3ZpZGVyLFxuICBQcm92aWRlckludGVyZmFjZSxcbiAgcnBjX2V4cG9ydHMgYXMgUlBDLFxuICBScGNQcm92aWRlcixcbiAgU0lNVUxBVElPTl9GTEFHLFxuICBzZXF1ZW5jZXJfZXhwb3J0cyBhcyBTZXF1ZW5jZXIsXG4gIFNlcXVlbmNlclByb3ZpZGVyLFxuICBTaWduZXIsXG4gIFNpZ25lckludGVyZmFjZSxcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFVpbnQsXG4gIFZhbGlkYXRlVHlwZSxcbiAgYWRkQWRkcmVzc1BhZGRpbmcsXG4gIGJ1aWxkVXJsLFxuICBjYWlyb19leHBvcnRzIGFzIGNhaXJvLFxuICBjb25zdGFudHNfZXhwb3J0cyBhcyBjb25zdGFudHMsXG4gIGNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdCxcbiAgZGVmYXVsdFByb3ZpZGVyLFxuICBlY19leHBvcnRzIGFzIGVjLFxuICBlbmNvZGVfZXhwb3J0cyBhcyBlbmNvZGUsXG4gIGV2ZW50c19leHBvcnRzIGFzIGV2ZW50cyxcbiAgZXh0cmFjdENvbnRyYWN0SGFzaGVzLFxuICBmaXhQcm90byxcbiAgZml4U3RhY2ssXG4gIGdldENhbGxkYXRhLFxuICBnZXRDaGVja3N1bUFkZHJlc3MsXG4gIGdldERlZmF1bHROb2RlVXJsLFxuICBoYXNoX2V4cG9ydHMgYXMgaGFzaCxcbiAgaXNTaWVycmEsXG4gIGlzVXJsLFxuICBqc29uX2V4cG9ydHMgYXMganNvbixcbiAgbWVya2xlX2V4cG9ydHMgYXMgbWVya2xlLFxuICBudW1fZXhwb3J0cyBhcyBudW0sXG4gIG51bWJlcixcbiAgcGFyc2VVRENFdmVudCxcbiAgcHJvdmlkZXJfZXhwb3J0cyBhcyBwcm92aWRlcixcbiAgc2VsZWN0b3JfZXhwb3J0cyBhcyBzZWxlY3RvcixcbiAgc2hvcnRTdHJpbmdfZXhwb3J0cyBhcyBzaG9ydFN0cmluZyxcbiAgc3BsaXRBcmdzQW5kT3B0aW9ucyxcbiAgc3RhcmtfZXhwb3J0cyBhcyBzdGFyayxcbiAgc3RhcmtuZXRJZF9leHBvcnRzIGFzIHN0YXJrbmV0SWQsXG4gIHRyYW5zYWN0aW9uX2V4cG9ydHMgYXMgdHJhbnNhY3Rpb24sXG4gIHR5cGVkRGF0YV9leHBvcnRzIGFzIHR5cGVkRGF0YSxcbiAgdHlwZXNfZXhwb3J0cyBhcyB0eXBlcyxcbiAgdWludDI1Nl9leHBvcnRzIGFzIHVpbnQyNTYsXG4gIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzLFxuICB2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js":
/*!************************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LosslessNumber: () => (/* binding */ LosslessNumber),\n/* harmony export */   isLosslessNumber: () => (/* binding */ isLosslessNumber),\n/* harmony export */   toLosslessNumber: () => (/* binding */ toLosslessNumber)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nvar LosslessNumber = /*#__PURE__*/function () {\n  function LosslessNumber(value) {\n    _classCallCheck(this, LosslessNumber);\n    // numeric value as string\n    // type information\n    _defineProperty(this, \"isLosslessNumber\", true);\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(value)) {\n      throw new Error('Invalid number (value: \"' + value + '\")');\n    }\n    this.value = value;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  _createClass(LosslessNumber, [{\n    key: \"valueOf\",\n    value: function valueOf() {\n      var unsafeReason = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getUnsafeNumberReason)(this.value);\n\n      // safe or truncate_float\n      if (unsafeReason === undefined || unsafeReason === _utils_js__WEBPACK_IMPORTED_MODULE_0__.UnsafeNumberReason.truncate_float) {\n        return parseFloat(this.value);\n      }\n\n      // truncate_integer\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(this.value)) {\n        return BigInt(this.value);\n      }\n\n      // overflow or underflow\n      throw new Error('Cannot safely convert to number: ' + \"the value '\".concat(this.value, \"' would \").concat(unsafeReason, \" and become \").concat(parseFloat(this.value)));\n    }\n\n    /**\n     * Get the value of the LosslessNumber as string.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.value;\n    }\n\n    // Note: we do NOT implement a .toJSON() method, and you should not implement\n    // or use that, it cannot safely turn the numeric value in the string into\n    // stringified JSON since it has to be parsed into a number first.\n  }]);\n  return LosslessNumber;\n}();\n\n/**\n * Test whether a value is a LosslessNumber\n */\nfunction isLosslessNumber(value) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return value && _typeof(value) === 'object' && value.isLosslessNumber === true || false;\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nfunction toLosslessNumber(value) {\n  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.extractSignificantDigits)(value + '').length > 15) {\n    throw new Error('Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself ' + \"(value: \".concat(value, \")\"));\n  }\n  if (isNaN(value)) {\n    throw new Error('Invalid number: NaN');\n  }\n  if (!isFinite(value)) {\n    throw new Error('Invalid number: ' + value);\n  }\n  return new LosslessNumber(String(value));\n}\n//# sourceMappingURL=LosslessNumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9Mb3NzbGVzc051bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsd0JBQXdCLDJCQUEyQixzR0FBc0cscUJBQXFCLG1CQUFtQiw4SEFBOEg7QUFDL1Qsa0RBQWtELDBDQUEwQztBQUM1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDtBQUMvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7QUFDeFEsNENBQTRDLDJCQUEyQixrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9CO0FBQy9OLCtCQUErQix1Q0FBdUM7QUFDdEUscUNBQXFDLGlFQUFpRSxzQ0FBc0MsMEJBQTBCLCtDQUErQywyQ0FBMkMsdUVBQXVFO0FBQ2pOOztBQUV0SDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1EQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0VBQXFCOztBQUU5QztBQUNBLHlEQUF5RCx5REFBa0I7QUFDM0U7QUFDQTs7QUFFQTtBQUNBLFVBQVUsb0RBQVM7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsTUFBTSxtRUFBd0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzcy0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL0xvc3NsZXNzTnVtYmVyLmpzPzk2YjAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuaW1wb3J0IHsgZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzLCBnZXRVbnNhZmVOdW1iZXJSZWFzb24sIGlzSW50ZWdlciwgaXNOdW1iZXIsIFVuc2FmZU51bWJlclJlYXNvbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgbG9zc2xlc3MgbnVtYmVyLiBTdG9yZXMgaXRzIG51bWVyaWMgdmFsdWUgYXMgc3RyaW5nXG4gKi9cbmV4cG9ydCB2YXIgTG9zc2xlc3NOdW1iZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb3NzbGVzc051bWJlcih2YWx1ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb3NzbGVzc051bWJlcik7XG4gICAgLy8gbnVtZXJpYyB2YWx1ZSBhcyBzdHJpbmdcbiAgICAvLyB0eXBlIGluZm9ybWF0aW9uXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNMb3NzbGVzc051bWJlclwiLCB0cnVlKTtcbiAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciAodmFsdWU6IFwiJyArIHZhbHVlICsgJ1wiKScpO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgTG9zc2xlc3NOdW1iZXIgYXMgbnVtYmVyIG9yIGJpZ2ludC5cbiAgICpcbiAgICogLSBhIG51bWJlciBpcyByZXR1cm5lZCBmb3Igc2FmZSBudW1iZXJzIGFuZCBkZWNpbWFsIHZhbHVlcyB0aGF0IG9ubHkgbG9zZSBzb21lIGluc2lnbmlmaWNhbnQgZGlnaXRzXG4gICAqIC0gYSBiaWdpbnQgaXMgcmV0dXJuZWQgZm9yIGJpZyBpbnRlZ2VyIG51bWJlcnNcbiAgICogLSBhbiBFcnJvciBpcyB0aHJvd24gZm9yIHZhbHVlcyB0aGF0IHdpbGwgb3ZlcmZsb3cgb3IgdW5kZXJmbG93XG4gICAqXG4gICAqIE5vdGUgdGhhdCB5b3UgY2FuIGltcGxlbWVudCB5b3VyIG93biBzdHJhdGVneSBmb3IgY29udmVyc2lvbiBieSBqdXN0IGdldHRpbmcgdGhlIHZhbHVlIGFzIHN0cmluZ1xuICAgKiB2aWEgLnRvU3RyaW5nKCksIGFuZCB1c2luZyB1dGlsIGZ1bmN0aW9ucyBsaWtlIGlzSW50ZWdlciwgaXNTYWZlTnVtYmVyLCBnZXRVbnNhZmVOdW1iZXJSZWFzb24sXG4gICAqIGFuZCB0b1NhZmVOdW1iZXJPclRocm93IHRvIGNvbnZlcnQgaXQgdG8gYSBudW1lcmljIHZhbHVlLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKExvc3NsZXNzTnVtYmVyLCBbe1xuICAgIGtleTogXCJ2YWx1ZU9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICB2YXIgdW5zYWZlUmVhc29uID0gZ2V0VW5zYWZlTnVtYmVyUmVhc29uKHRoaXMudmFsdWUpO1xuXG4gICAgICAvLyBzYWZlIG9yIHRydW5jYXRlX2Zsb2F0XG4gICAgICBpZiAodW5zYWZlUmVhc29uID09PSB1bmRlZmluZWQgfHwgdW5zYWZlUmVhc29uID09PSBVbnNhZmVOdW1iZXJSZWFzb24udHJ1bmNhdGVfZmxvYXQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRydW5jYXRlX2ludGVnZXJcbiAgICAgIGlmIChpc0ludGVnZXIodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcmZsb3cgb3IgdW5kZXJmbG93XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzYWZlbHkgY29udmVydCB0byBudW1iZXI6ICcgKyBcInRoZSB2YWx1ZSAnXCIuY29uY2F0KHRoaXMudmFsdWUsIFwiJyB3b3VsZCBcIikuY29uY2F0KHVuc2FmZVJlYXNvbiwgXCIgYW5kIGJlY29tZSBcIikuY29uY2F0KHBhcnNlRmxvYXQodGhpcy52YWx1ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBMb3NzbGVzc051bWJlciBhcyBzdHJpbmcuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiB3ZSBkbyBOT1QgaW1wbGVtZW50IGEgLnRvSlNPTigpIG1ldGhvZCwgYW5kIHlvdSBzaG91bGQgbm90IGltcGxlbWVudFxuICAgIC8vIG9yIHVzZSB0aGF0LCBpdCBjYW5ub3Qgc2FmZWx5IHR1cm4gdGhlIG51bWVyaWMgdmFsdWUgaW4gdGhlIHN0cmluZyBpbnRvXG4gICAgLy8gc3RyaW5naWZpZWQgSlNPTiBzaW5jZSBpdCBoYXMgdG8gYmUgcGFyc2VkIGludG8gYSBudW1iZXIgZmlyc3QuXG4gIH1dKTtcbiAgcmV0dXJuIExvc3NsZXNzTnVtYmVyO1xufSgpO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHZhbHVlIGlzIGEgTG9zc2xlc3NOdW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9zc2xlc3NOdW1iZXIodmFsdWUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB2YWx1ZSAmJiBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuaXNMb3NzbGVzc051bWJlciA9PT0gdHJ1ZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIGludG8gYSBMb3NzbGVzc051bWJlciBpZiB0aGlzIGlzIHBvc3NpYmxlIGluIGEgc2FmZSB3YXlcbiAqIElmIHRoZSB2YWx1ZSBoYXMgdG9vIG1hbnkgZGlnaXRzLCBvciBpcyBOYU4gb3IgSW5maW5pdHksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xvc3NsZXNzTnVtYmVyKHZhbHVlKSB7XG4gIGlmIChleHRyYWN0U2lnbmlmaWNhbnREaWdpdHModmFsdWUgKyAnJykubGVuZ3RoID4gMTUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyOiBjb250YWlucyBtb3JlIHRoYW4gMTUgZGlnaXRzIGFuZCBpcyBtb3N0IGxpa2VseSB0cnVuY2F0ZWQgYW5kIHVuc2FmZSBieSBpdHNlbGYgJyArIFwiKHZhbHVlOiBcIi5jb25jYXQodmFsdWUsIFwiKVwiKSk7XG4gIH1cbiAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXI6IE5hTicpO1xuICB9XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlcjogJyArIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbmV3IExvc3NsZXNzTnVtYmVyKFN0cmluZyh2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9zc2xlc3NOdW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/config.js":
/*!****************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/config.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config)\n/* harmony export */ });\n/**\n * Get and/or set configuration options\n * @deprecated There is no config anymore\n */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction config(options) {\n  // Backward compatibility warning for v1.x\n  throw new Error('config is deprecated, support for circularRefs is removed from the library. ' + 'If you encounter circular references in your data structures, ' + 'please rethink your datastructures: ' + 'better prevent circular references in the first place.');\n}\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzcy0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL2NvbmZpZy5qcz83ZjNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2V0IGFuZC9vciBzZXQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAZGVwcmVjYXRlZCBUaGVyZSBpcyBubyBjb25maWcgYW55bW9yZVxuICovIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbmV4cG9ydCBmdW5jdGlvbiBjb25maWcob3B0aW9ucykge1xuICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdhcm5pbmcgZm9yIHYxLnhcbiAgdGhyb3cgbmV3IEVycm9yKCdjb25maWcgaXMgZGVwcmVjYXRlZCwgc3VwcG9ydCBmb3IgY2lyY3VsYXJSZWZzIGlzIHJlbW92ZWQgZnJvbSB0aGUgbGlicmFyeS4gJyArICdJZiB5b3UgZW5jb3VudGVyIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4geW91ciBkYXRhIHN0cnVjdHVyZXMsICcgKyAncGxlYXNlIHJldGhpbmsgeW91ciBkYXRhc3RydWN0dXJlczogJyArICdiZXR0ZXIgcHJldmVudCBjaXJjdWxhciByZWZlcmVuY2VzIGluIHRoZSBmaXJzdCBwbGFjZS4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LosslessNumber: () => (/* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.LosslessNumber),\n/* harmony export */   UnsafeNumberReason: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.UnsafeNumberReason),\n/* harmony export */   config: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_0__.config),\n/* harmony export */   getUnsafeNumberReason: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.getUnsafeNumberReason),\n/* harmony export */   isInteger: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isInteger),\n/* harmony export */   isLosslessNumber: () => (/* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.isLosslessNumber),\n/* harmony export */   isNumber: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isNumber),\n/* harmony export */   isSafeNumber: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isSafeNumber),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_1__.parse),\n/* harmony export */   parseLosslessNumber: () => (/* reexport safe */ _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__.parseLosslessNumber),\n/* harmony export */   parseNumberAndBigInt: () => (/* reexport safe */ _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__.parseNumberAndBigInt),\n/* harmony export */   reviveDate: () => (/* reexport safe */ _reviveDate_js__WEBPACK_IMPORTED_MODULE_4__.reviveDate),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_2__.stringify),\n/* harmony export */   toLosslessNumber: () => (/* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.toLosslessNumber),\n/* harmony export */   toSafeNumberOrThrow: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.toSafeNumberOrThrow)\n/* harmony export */ });\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/config.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/stringify.js\");\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n/* harmony import */ var _reviveDate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reviveDate.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/reviveDate.js\");\n/* harmony import */ var _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./numberParsers.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/types.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNGO0FBQ1E7QUFDOEM7QUFDNUM7QUFDa0M7QUFDZ0Q7QUFDcEc7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3MtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9pbmRleC5qcz9hMTM2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGNvbmZpZyB9IGZyb20gJy4vY29uZmlnLmpzJztcbmV4cG9ydCB7IHBhcnNlIH0gZnJvbSAnLi9wYXJzZS5qcyc7XG5leHBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5leHBvcnQgeyBMb3NzbGVzc051bWJlciwgaXNMb3NzbGVzc051bWJlciwgdG9Mb3NzbGVzc051bWJlciB9IGZyb20gJy4vTG9zc2xlc3NOdW1iZXIuanMnO1xuZXhwb3J0IHsgcmV2aXZlRGF0ZSB9IGZyb20gJy4vcmV2aXZlRGF0ZS5qcyc7XG5leHBvcnQgeyBwYXJzZUxvc3NsZXNzTnVtYmVyLCBwYXJzZU51bWJlckFuZEJpZ0ludCB9IGZyb20gJy4vbnVtYmVyUGFyc2Vycy5qcyc7XG5leHBvcnQgeyBVbnNhZmVOdW1iZXJSZWFzb24sIGlzSW50ZWdlciwgaXNOdW1iZXIsIGlzU2FmZU51bWJlciwgdG9TYWZlTnVtYmVyT3JUaHJvdywgZ2V0VW5zYWZlTnVtYmVyUmVhc29uIH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseLosslessNumber: () => (/* binding */ parseLosslessNumber),\n/* harmony export */   parseNumberAndBigInt: () => (/* binding */ parseNumberAndBigInt)\n/* harmony export */ });\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\");\n\n\nfunction parseLosslessNumber(value) {\n  return new _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__.LosslessNumber(value);\n}\nfunction parseNumberAndBigInt(value) {\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(value) ? BigInt(value) : parseFloat(value);\n}\n//# sourceMappingURL=numberParsers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9udW1iZXJQYXJzZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBcUQ7QUFDZDtBQUNoQztBQUNQLGFBQWEsOERBQWM7QUFDM0I7QUFDTztBQUNQLFNBQVMsb0RBQVM7QUFDbEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzcy0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL251bWJlclBhcnNlcnMuanM/MjgzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb3NzbGVzc051bWJlciB9IGZyb20gJy4vTG9zc2xlc3NOdW1iZXIuanMnO1xuaW1wb3J0IHsgaXNJbnRlZ2VyIH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VMb3NzbGVzc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gbmV3IExvc3NsZXNzTnVtYmVyKHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU51bWJlckFuZEJpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSA/IEJpZ0ludCh2YWx1ZSkgOiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlclBhcnNlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/parse.js":
/*!***************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/parse.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codeLowercaseA: () => (/* binding */ codeLowercaseA),\n/* harmony export */   codeLowercaseE: () => (/* binding */ codeLowercaseE),\n/* harmony export */   codeLowercaseF: () => (/* binding */ codeLowercaseF),\n/* harmony export */   codeUppercaseA: () => (/* binding */ codeUppercaseA),\n/* harmony export */   codeUppercaseE: () => (/* binding */ codeUppercaseE),\n/* harmony export */   codeUppercaseF: () => (/* binding */ codeUppercaseF),\n/* harmony export */   isDeepEqual: () => (/* binding */ isDeepEqual),\n/* harmony export */   isValidStringCharacter: () => (/* binding */ isValidStringCharacter),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var _numberParsers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberParsers.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/numberParsers.js\");\n/* harmony import */ var _revive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./revive.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/revive.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nfunction parse(text, reviver) {\n  var parseNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _numberParsers_js__WEBPACK_IMPORTED_MODULE_0__.parseLosslessNumber;\n  var i = 0;\n  var value = parseValue();\n  expectValue(value);\n  expectEndOfInput();\n  return reviver ? (0,_revive_js__WEBPACK_IMPORTED_MODULE_1__.revive)(value, reviver) : value;\n  function parseObject() {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++;\n      skipWhitespace();\n      var object = {};\n      var initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma();\n          skipWhitespace();\n        } else {\n          initial = false;\n        }\n        var start = i;\n        var key = parseString();\n        if (key === undefined) {\n          throwObjectKeyExpected();\n        }\n        skipWhitespace();\n        eatColon();\n        var _value = parseValue();\n        if (_value === undefined) {\n          throwObjectValueExpected();\n        }\n\n        // TODO: test deep equal instead of strict equal\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(_value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1);\n        }\n        object[key] = _value;\n      }\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected();\n      }\n      i++;\n      return object;\n    }\n  }\n  function parseArray() {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++;\n      skipWhitespace();\n      var array = [];\n      var initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma();\n        } else {\n          initial = false;\n        }\n        var _value2 = parseValue();\n        expectArrayItem(_value2);\n        array.push(_value2);\n      }\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected();\n      }\n      i++;\n      return array;\n    }\n  }\n  function parseValue() {\n    var _ref, _ref2, _ref3, _ref4, _ref5, _parseString;\n    skipWhitespace();\n    var value = (_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_parseString = parseString()) !== null && _parseString !== void 0 ? _parseString : parseNumeric()) !== null && _ref5 !== void 0 ? _ref5 : parseObject()) !== null && _ref4 !== void 0 ? _ref4 : parseArray()) !== null && _ref3 !== void 0 ? _ref3 : parseKeyword('true', true)) !== null && _ref2 !== void 0 ? _ref2 : parseKeyword('false', false)) !== null && _ref !== void 0 ? _ref : parseKeyword('null', null);\n    skipWhitespace();\n    return value;\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length;\n      return value;\n    }\n  }\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++;\n    }\n  }\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++;\n      var result = '';\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          var char = text[i + 1];\n          var escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            result += escapeChar;\n            i++;\n          } else if (char === 'u') {\n            if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {\n              result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16));\n              i += 5;\n            } else {\n              throwInvalidUnicodeCharacter(i);\n            }\n          } else {\n            throwInvalidEscapeCharacter(i);\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i];\n          } else {\n            throwInvalidCharacter(text[i]);\n          }\n        }\n        i++;\n      }\n      expectEndOfString();\n      i++;\n      return result;\n    }\n  }\n  function parseNumeric() {\n    var start = i;\n    if (text.charCodeAt(i) === codeMinus) {\n      i++;\n      expectDigit(start);\n    }\n    if (text.charCodeAt(i) === codeZero) {\n      i++;\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++;\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeDot) {\n      i++;\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++;\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++;\n      }\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (i > start) {\n      return parseNumber(text.slice(start, i));\n    }\n  }\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(\"Comma ',' expected after value \".concat(gotAt()));\n    }\n    i++;\n  }\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(\"Colon ':' expected after property name \".concat(gotAt()));\n    }\n    i++;\n  }\n  function expectValue(value) {\n    if (value === undefined) {\n      throw new SyntaxError(\"JSON value expected \".concat(gotAt()));\n    }\n  }\n  function expectArrayItem(value) {\n    if (value === undefined) {\n      throw new SyntaxError(\"Array item expected \".concat(gotAt()));\n    }\n  }\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(\"Expected end of input \".concat(gotAt()));\n    }\n  }\n  function expectDigit(start) {\n    if (!isDigit(text.charCodeAt(i))) {\n      var numSoFar = text.slice(start, i);\n      throw new SyntaxError(\"Invalid number '\".concat(numSoFar, \"', expecting a digit \").concat(gotAt()));\n    }\n  }\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(\"End of string '\\\"' expected \".concat(gotAt()));\n    }\n  }\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(\"Quoted object key expected \".concat(gotAt()));\n  }\n  function throwDuplicateKey(key, pos) {\n    throw new SyntaxError(\"Duplicate key '\".concat(key, \"' encountered at position \").concat(pos));\n  }\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(\"Quoted object key or end of object '}' expected \".concat(gotAt()));\n  }\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(\"Array item or end of array ']' expected \".concat(gotAt()));\n  }\n  function throwInvalidCharacter(char) {\n    throw new SyntaxError(\"Invalid character '\".concat(char, \"' \").concat(pos()));\n  }\n  function throwInvalidEscapeCharacter(start) {\n    var chars = text.slice(start, start + 2);\n    throw new SyntaxError(\"Invalid escape character '\".concat(chars, \"' \").concat(pos()));\n  }\n  function throwObjectValueExpected() {\n    throw new SyntaxError(\"Object value expected after ':' \".concat(pos()));\n  }\n  function throwInvalidUnicodeCharacter(start) {\n    var end = start + 2;\n    while (/\\w/.test(text[end])) {\n      end++;\n    }\n    var chars = text.slice(start, end);\n    throw new SyntaxError(\"Invalid unicode character '\".concat(chars, \"' \").concat(pos()));\n  }\n\n  // zero based character position\n  function pos() {\n    return \"at position \".concat(i);\n  }\n  function got() {\n    return i < text.length ? \"but got '\".concat(text[i], \"'\") : 'but reached end of input';\n  }\n  function gotAt() {\n    return got() + ' ' + pos();\n  }\n}\nfunction isWhitespace(code) {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\nfunction isHex(code) {\n  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;\n}\nfunction isDigit(code) {\n  return code >= codeZero && code <= codeNine;\n}\nfunction isNonZeroDigit(code) {\n  return code >= codeOne && code <= codeNine;\n}\nfunction isValidStringCharacter(code) {\n  return code >= 0x20 && code <= 0x10ffff;\n}\nfunction isDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every(function (item, index) {\n      return isDeepEqual(item, b[index]);\n    });\n  }\n  if (isObject(a) && isObject(b)) {\n    var keys = _toConsumableArray(new Set([].concat(_toConsumableArray(Object.keys(a)), _toConsumableArray(Object.keys(b)))));\n    return keys.every(function (key) {\n      return isDeepEqual(a[key], b[key]);\n    });\n  }\n  return false;\n}\nfunction isObject(value) {\n  return _typeof(value) === 'object' && value !== null;\n}\n\n// map with all escape characters\nvar escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\n\nvar codeBackslash = 0x5c; // \"\\\"\nvar codeOpeningBrace = 0x7b; // \"{\"\nvar codeClosingBrace = 0x7d; // \"}\"\nvar codeOpeningBracket = 0x5b; // \"[\"\nvar codeClosingBracket = 0x5d; // \"]\"\nvar codeSpace = 0x20; // \" \"\nvar codeNewline = 0xa; // \"\\n\"\nvar codeTab = 0x9; // \"\\t\"\nvar codeReturn = 0xd; // \"\\r\"\nvar codeDoubleQuote = 0x0022; // \"\nvar codePlus = 0x2b; // \"+\"\nvar codeMinus = 0x2d; // \"-\"\nvar codeZero = 0x30;\nvar codeOne = 0x31;\nvar codeNine = 0x39;\nvar codeComma = 0x2c; // \",\"\nvar codeDot = 0x2e; // \".\" (dot, period)\nvar codeColon = 0x3a; // \":\"\nvar codeUppercaseA = 0x41; // \"A\"\nvar codeLowercaseA = 0x61; // \"a\"\nvar codeUppercaseE = 0x45; // \"E\"\nvar codeLowercaseE = 0x65; // \"e\"\nvar codeUppercaseF = 0x46; // \"F\"\nvar codeLowercaseF = 0x66; // \"f\"\n//# sourceMappingURL=parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLHdCQUF3QiwyQkFBMkIsc0dBQXNHLHFCQUFxQixtQkFBbUIsOEhBQThIO0FBQy9ULG1DQUFtQztBQUNuQyxnQ0FBZ0M7QUFDaEMsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7QUFDN1Msa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLHVCQUF1QjtBQUM1RztBQUNwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asd0ZBQXdGLGtFQUFtQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEUsbURBQW1ELElBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDZCQUE2QixLQUFLO0FBQ2xDLDZCQUE2QixLQUFLO0FBQ2xDLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0Isc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLDhCQUE4QjtBQUM5QixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ2YsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3MtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9wYXJzZS5qcz85NThjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5pbXBvcnQgeyBwYXJzZUxvc3NsZXNzTnVtYmVyIH0gZnJvbSAnLi9udW1iZXJQYXJzZXJzLmpzJztcbmltcG9ydCB7IHJldml2ZSB9IGZyb20gJy4vcmV2aXZlLmpzJztcbi8qKlxuICogVGhlIExvc3NsZXNzSlNPTi5wYXJzZSgpIG1ldGhvZCBwYXJzZXMgYSBzdHJpbmcgYXMgSlNPTiwgb3B0aW9uYWxseSB0cmFuc2Zvcm1pbmdcbiAqIHRoZSB2YWx1ZSBwcm9kdWNlZCBieSBwYXJzaW5nLlxuICpcbiAqIFRoZSBwYXJzZXIgaXMgYmFzZWQgb24gdGhlIHBhcnNlciBvZiBUYW4gTGkgSG91IHNoYXJlZCBpblxuICogaHR0cHM6Ly9saWhhdXRhbi5jb20vanNvbi1wYXJzZXItd2l0aC1qYXZhc2NyaXB0L1xuICpcbiAqIEBwYXJhbSB0ZXh0XG4gKiBUaGUgc3RyaW5nIHRvIHBhcnNlIGFzIEpTT04uIFNlZSB0aGUgSlNPTiBvYmplY3QgZm9yIGEgZGVzY3JpcHRpb24gb2YgSlNPTiBzeW50YXguXG4gKlxuICogQHBhcmFtIFtyZXZpdmVyXVxuICogSWYgYSBmdW5jdGlvbiwgcHJlc2NyaWJlcyBob3cgdGhlIHZhbHVlIG9yaWdpbmFsbHkgcHJvZHVjZWQgYnkgcGFyc2luZyBpc1xuICogdHJhbnNmb3JtZWQsIGJlZm9yZSBiZWluZyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gW3BhcnNlTnVtYmVyPXBhcnNlTG9zc2xlc3NOdW1iZXJdXG4gKiBQYXNzIGEgY3VzdG9tIG51bWJlciBwYXJzZXIuIElucHV0IGlzIGEgc3RyaW5nLCBhbmQgdGhlIG91dHB1dCBjYW4gYmUgdW5rbm93blxuICogbnVtZXJpYyB2YWx1ZTogbnVtYmVyLCBiaWdpbnQsIExvc3NsZXNzTnVtYmVyLCBvciBhIGN1c3RvbSBCaWdOdW1iZXIgbGlicmFyeS5cbiAqXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBPYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gSlNPTiB0ZXh0LlxuICpcbiAqIEB0aHJvd3MgVGhyb3dzIGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uIGlmIHRoZSBzdHJpbmcgdG8gcGFyc2UgaXMgbm90IHZhbGlkIEpTT04uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0LCByZXZpdmVyKSB7XG4gIHZhciBwYXJzZU51bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogcGFyc2VMb3NzbGVzc051bWJlcjtcbiAgdmFyIGkgPSAwO1xuICB2YXIgdmFsdWUgPSBwYXJzZVZhbHVlKCk7XG4gIGV4cGVjdFZhbHVlKHZhbHVlKTtcbiAgZXhwZWN0RW5kT2ZJbnB1dCgpO1xuICByZXR1cm4gcmV2aXZlciA/IHJldml2ZSh2YWx1ZSwgcmV2aXZlcikgOiB2YWx1ZTtcbiAgZnVuY3Rpb24gcGFyc2VPYmplY3QoKSB7XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gY29kZU9wZW5pbmdCcmFjZSkge1xuICAgICAgaSsrO1xuICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIHZhciBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChpIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkpICE9PSBjb2RlQ2xvc2luZ0JyYWNlKSB7XG4gICAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICAgIGVhdENvbW1hKCk7XG4gICAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0aWFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gaTtcbiAgICAgICAgdmFyIGtleSA9IHBhcnNlU3RyaW5nKCk7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93T2JqZWN0S2V5RXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICBlYXRDb2xvbigpO1xuICAgICAgICB2YXIgX3ZhbHVlID0gcGFyc2VWYWx1ZSgpO1xuICAgICAgICBpZiAoX3ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvd09iamVjdFZhbHVlRXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHRlc3QgZGVlcCBlcXVhbCBpbnN0ZWFkIG9mIHN0cmljdCBlcXVhbFxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiAhaXNEZWVwRXF1YWwoX3ZhbHVlLCBvYmplY3Rba2V5XSkpIHtcbiAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgY291bGQgYWxzbyB0ZXN0IGBpZihrZXkgaW4gb2JqZWN0KSB7Li4ufWBcbiAgICAgICAgICAvLyBvciBgaWYgKG9iamVjdFtrZXldICE9PSAndW5kZWZpbmVkJykgey4uLn1gLCBidXQgdGhhdCBpcyBzbG93ZXIuXG4gICAgICAgICAgdGhyb3dEdXBsaWNhdGVLZXkoa2V5LCBzdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gX3ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFjZSkge1xuICAgICAgICB0aHJvd09iamVjdEtleU9yRW5kRXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXkoKSB7XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gY29kZU9wZW5pbmdCcmFja2V0KSB7XG4gICAgICBpKys7XG4gICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICB2YXIgaW5pdGlhbCA9IHRydWU7XG4gICAgICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFja2V0KSB7XG4gICAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICAgIGVhdENvbW1hKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdmFsdWUyID0gcGFyc2VWYWx1ZSgpO1xuICAgICAgICBleHBlY3RBcnJheUl0ZW0oX3ZhbHVlMik7XG4gICAgICAgIGFycmF5LnB1c2goX3ZhbHVlMik7XG4gICAgICB9XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpICE9PSBjb2RlQ2xvc2luZ0JyYWNrZXQpIHtcbiAgICAgICAgdGhyb3dBcnJheUl0ZW1PckVuZEV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVmFsdWUoKSB7XG4gICAgdmFyIF9yZWYsIF9yZWYyLCBfcmVmMywgX3JlZjQsIF9yZWY1LCBfcGFyc2VTdHJpbmc7XG4gICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICB2YXIgdmFsdWUgPSAoX3JlZiA9IChfcmVmMiA9IChfcmVmMyA9IChfcmVmNCA9IChfcmVmNSA9IChfcGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZygpKSAhPT0gbnVsbCAmJiBfcGFyc2VTdHJpbmcgIT09IHZvaWQgMCA/IF9wYXJzZVN0cmluZyA6IHBhcnNlTnVtZXJpYygpKSAhPT0gbnVsbCAmJiBfcmVmNSAhPT0gdm9pZCAwID8gX3JlZjUgOiBwYXJzZU9iamVjdCgpKSAhPT0gbnVsbCAmJiBfcmVmNCAhPT0gdm9pZCAwID8gX3JlZjQgOiBwYXJzZUFycmF5KCkpICE9PSBudWxsICYmIF9yZWYzICE9PSB2b2lkIDAgPyBfcmVmMyA6IHBhcnNlS2V5d29yZCgndHJ1ZScsIHRydWUpKSAhPT0gbnVsbCAmJiBfcmVmMiAhPT0gdm9pZCAwID8gX3JlZjIgOiBwYXJzZUtleXdvcmQoJ2ZhbHNlJywgZmFsc2UpKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogcGFyc2VLZXl3b3JkKCdudWxsJywgbnVsbCk7XG4gICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VLZXl3b3JkKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRleHQuc2xpY2UoaSwgaSArIG5hbWUubGVuZ3RoKSA9PT0gbmFtZSkge1xuICAgICAgaSArPSBuYW1lLmxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKGlzV2hpdGVzcGFjZSh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKCkge1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgaSsrO1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgd2hpbGUgKGkgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQoaSkgIT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlQmFja3NsYXNoKSB7XG4gICAgICAgICAgdmFyIGNoYXIgPSB0ZXh0W2kgKyAxXTtcbiAgICAgICAgICB2YXIgZXNjYXBlQ2hhciA9IGVzY2FwZUNoYXJhY3RlcnNbY2hhcl07XG4gICAgICAgICAgaWYgKGVzY2FwZUNoYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUNoYXI7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAndScpIHtcbiAgICAgICAgICAgIGlmIChpc0hleCh0ZXh0LmNoYXJDb2RlQXQoaSArIDIpKSAmJiBpc0hleCh0ZXh0LmNoYXJDb2RlQXQoaSArIDMpKSAmJiBpc0hleCh0ZXh0LmNoYXJDb2RlQXQoaSArIDQpKSAmJiBpc0hleCh0ZXh0LmNoYXJDb2RlQXQoaSArIDUpKSkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh0ZXh0LnNsaWNlKGkgKyAyLCBpICsgNiksIDE2KSk7XG4gICAgICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93SW52YWxpZFVuaWNvZGVDaGFyYWN0ZXIoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93SW52YWxpZEVzY2FwZUNoYXJhY3RlcihpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRTdHJpbmdDaGFyYWN0ZXIodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRleHRbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93SW52YWxpZENoYXJhY3Rlcih0ZXh0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgZXhwZWN0RW5kT2ZTdHJpbmcoKTtcbiAgICAgIGkrKztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTnVtZXJpYygpIHtcbiAgICB2YXIgc3RhcnQgPSBpO1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVNaW51cykge1xuICAgICAgaSsrO1xuICAgICAgZXhwZWN0RGlnaXQoc3RhcnQpO1xuICAgIH1cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlWmVybykge1xuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoaXNOb25aZXJvRGlnaXQodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVEb3QpIHtcbiAgICAgIGkrKztcbiAgICAgIGV4cGVjdERpZ2l0KHN0YXJ0KTtcbiAgICAgIHdoaWxlIChpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlTG93ZXJjYXNlRSB8fCB0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVVcHBlcmNhc2VFKSB7XG4gICAgICBpKys7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlTWludXMgfHwgdGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlUGx1cykge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBleHBlY3REaWdpdChzdGFydCk7XG4gICAgICB3aGlsZSAoaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiBzdGFydCkge1xuICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyKHRleHQuc2xpY2Uoc3RhcnQsIGkpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZWF0Q29tbWEoKSB7XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNvbW1hKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJDb21tYSAnLCcgZXhwZWN0ZWQgYWZ0ZXIgdmFsdWUgXCIuY29uY2F0KGdvdEF0KCkpKTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIGZ1bmN0aW9uIGVhdENvbG9uKCkge1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgIT09IGNvZGVDb2xvbikge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQ29sb24gJzonIGV4cGVjdGVkIGFmdGVyIHByb3BlcnR5IG5hbWUgXCIuY29uY2F0KGdvdEF0KCkpKTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIGZ1bmN0aW9uIGV4cGVjdFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkpTT04gdmFsdWUgZXhwZWN0ZWQgXCIuY29uY2F0KGdvdEF0KCkpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXhwZWN0QXJyYXlJdGVtKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFycmF5IGl0ZW0gZXhwZWN0ZWQgXCIuY29uY2F0KGdvdEF0KCkpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXhwZWN0RW5kT2ZJbnB1dCgpIHtcbiAgICBpZiAoaSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJFeHBlY3RlZCBlbmQgb2YgaW5wdXQgXCIuY29uY2F0KGdvdEF0KCkpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXhwZWN0RGlnaXQoc3RhcnQpIHtcbiAgICBpZiAoIWlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgdmFyIG51bVNvRmFyID0gdGV4dC5zbGljZShzdGFydCwgaSk7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJJbnZhbGlkIG51bWJlciAnXCIuY29uY2F0KG51bVNvRmFyLCBcIicsIGV4cGVjdGluZyBhIGRpZ2l0IFwiKS5jb25jYXQoZ290QXQoKSkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHBlY3RFbmRPZlN0cmluZygpIHtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpICE9PSBjb2RlRG91YmxlUXVvdGUpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkVuZCBvZiBzdHJpbmcgJ1xcXCInIGV4cGVjdGVkIFwiLmNvbmNhdChnb3RBdCgpKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRocm93T2JqZWN0S2V5RXhwZWN0ZWQoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiUXVvdGVkIG9iamVjdCBrZXkgZXhwZWN0ZWQgXCIuY29uY2F0KGdvdEF0KCkpKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0R1cGxpY2F0ZUtleShrZXksIHBvcykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkR1cGxpY2F0ZSBrZXkgJ1wiLmNvbmNhdChrZXksIFwiJyBlbmNvdW50ZXJlZCBhdCBwb3NpdGlvbiBcIikuY29uY2F0KHBvcykpO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93T2JqZWN0S2V5T3JFbmRFeHBlY3RlZCgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJRdW90ZWQgb2JqZWN0IGtleSBvciBlbmQgb2Ygb2JqZWN0ICd9JyBleHBlY3RlZCBcIi5jb25jYXQoZ290QXQoKSkpO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93QXJyYXlJdGVtT3JFbmRFeHBlY3RlZCgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBcnJheSBpdGVtIG9yIGVuZCBvZiBhcnJheSAnXScgZXhwZWN0ZWQgXCIuY29uY2F0KGdvdEF0KCkpKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0ludmFsaWRDaGFyYWN0ZXIoY2hhcikge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkludmFsaWQgY2hhcmFjdGVyICdcIi5jb25jYXQoY2hhciwgXCInIFwiKS5jb25jYXQocG9zKCkpKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0ludmFsaWRFc2NhcGVDaGFyYWN0ZXIoc3RhcnQpIHtcbiAgICB2YXIgY2hhcnMgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIDIpO1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkludmFsaWQgZXNjYXBlIGNoYXJhY3RlciAnXCIuY29uY2F0KGNoYXJzLCBcIicgXCIpLmNvbmNhdChwb3MoKSkpO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93T2JqZWN0VmFsdWVFeHBlY3RlZCgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJPYmplY3QgdmFsdWUgZXhwZWN0ZWQgYWZ0ZXIgJzonIFwiLmNvbmNhdChwb3MoKSkpO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93SW52YWxpZFVuaWNvZGVDaGFyYWN0ZXIoc3RhcnQpIHtcbiAgICB2YXIgZW5kID0gc3RhcnQgKyAyO1xuICAgIHdoaWxlICgvXFx3Ly50ZXN0KHRleHRbZW5kXSkpIHtcbiAgICAgIGVuZCsrO1xuICAgIH1cbiAgICB2YXIgY2hhcnMgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkludmFsaWQgdW5pY29kZSBjaGFyYWN0ZXIgJ1wiLmNvbmNhdChjaGFycywgXCInIFwiKS5jb25jYXQocG9zKCkpKTtcbiAgfVxuXG4gIC8vIHplcm8gYmFzZWQgY2hhcmFjdGVyIHBvc2l0aW9uXG4gIGZ1bmN0aW9uIHBvcygpIHtcbiAgICByZXR1cm4gXCJhdCBwb3NpdGlvbiBcIi5jb25jYXQoaSk7XG4gIH1cbiAgZnVuY3Rpb24gZ290KCkge1xuICAgIHJldHVybiBpIDwgdGV4dC5sZW5ndGggPyBcImJ1dCBnb3QgJ1wiLmNvbmNhdCh0ZXh0W2ldLCBcIidcIikgOiAnYnV0IHJlYWNoZWQgZW5kIG9mIGlucHV0JztcbiAgfVxuICBmdW5jdGlvbiBnb3RBdCgpIHtcbiAgICByZXR1cm4gZ290KCkgKyAnICcgKyBwb3MoKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IGNvZGVTcGFjZSB8fCBjb2RlID09PSBjb2RlTmV3bGluZSB8fCBjb2RlID09PSBjb2RlVGFiIHx8IGNvZGUgPT09IGNvZGVSZXR1cm47XG59XG5mdW5jdGlvbiBpc0hleChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IGNvZGVaZXJvICYmIGNvZGUgPD0gY29kZU5pbmUgfHwgY29kZSA+PSBjb2RlVXBwZXJjYXNlQSAmJiBjb2RlIDw9IGNvZGVVcHBlcmNhc2VGIHx8IGNvZGUgPj0gY29kZUxvd2VyY2FzZUEgJiYgY29kZSA8PSBjb2RlTG93ZXJjYXNlRjtcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSBjb2RlWmVybyAmJiBjb2RlIDw9IGNvZGVOaW5lO1xufVxuZnVuY3Rpb24gaXNOb25aZXJvRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSBjb2RlT25lICYmIGNvZGUgPD0gY29kZU5pbmU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFN0cmluZ0NoYXJhY3Rlcihjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDB4MjAgJiYgY29kZSA8PSAweDEwZmZmZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBpc0RlZXBFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpKSB7XG4gICAgdmFyIGtleXMgPSBfdG9Db25zdW1hYmxlQXJyYXkobmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5rZXlzKGEpKSwgX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5rZXlzKGIpKSkpKTtcbiAgICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gaXNEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbi8vIG1hcCB3aXRoIGFsbCBlc2NhcGUgY2hhcmFjdGVyc1xudmFyIGVzY2FwZUNoYXJhY3RlcnMgPSB7XG4gICdcIic6ICdcIicsXG4gICdcXFxcJzogJ1xcXFwnLFxuICAnLyc6ICcvJyxcbiAgYjogJ1xcYicsXG4gIGY6ICdcXGYnLFxuICBuOiAnXFxuJyxcbiAgcjogJ1xccicsXG4gIHQ6ICdcXHQnXG4gIC8vIG5vdGUgdGhhdCBcXHUgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGluIHBhcnNlU3RyaW5nKClcbn07XG5cbnZhciBjb2RlQmFja3NsYXNoID0gMHg1YzsgLy8gXCJcXFwiXG52YXIgY29kZU9wZW5pbmdCcmFjZSA9IDB4N2I7IC8vIFwie1wiXG52YXIgY29kZUNsb3NpbmdCcmFjZSA9IDB4N2Q7IC8vIFwifVwiXG52YXIgY29kZU9wZW5pbmdCcmFja2V0ID0gMHg1YjsgLy8gXCJbXCJcbnZhciBjb2RlQ2xvc2luZ0JyYWNrZXQgPSAweDVkOyAvLyBcIl1cIlxudmFyIGNvZGVTcGFjZSA9IDB4MjA7IC8vIFwiIFwiXG52YXIgY29kZU5ld2xpbmUgPSAweGE7IC8vIFwiXFxuXCJcbnZhciBjb2RlVGFiID0gMHg5OyAvLyBcIlxcdFwiXG52YXIgY29kZVJldHVybiA9IDB4ZDsgLy8gXCJcXHJcIlxudmFyIGNvZGVEb3VibGVRdW90ZSA9IDB4MDAyMjsgLy8gXCJcbnZhciBjb2RlUGx1cyA9IDB4MmI7IC8vIFwiK1wiXG52YXIgY29kZU1pbnVzID0gMHgyZDsgLy8gXCItXCJcbnZhciBjb2RlWmVybyA9IDB4MzA7XG52YXIgY29kZU9uZSA9IDB4MzE7XG52YXIgY29kZU5pbmUgPSAweDM5O1xudmFyIGNvZGVDb21tYSA9IDB4MmM7IC8vIFwiLFwiXG52YXIgY29kZURvdCA9IDB4MmU7IC8vIFwiLlwiIChkb3QsIHBlcmlvZClcbnZhciBjb2RlQ29sb24gPSAweDNhOyAvLyBcIjpcIlxuZXhwb3J0IHZhciBjb2RlVXBwZXJjYXNlQSA9IDB4NDE7IC8vIFwiQVwiXG5leHBvcnQgdmFyIGNvZGVMb3dlcmNhc2VBID0gMHg2MTsgLy8gXCJhXCJcbmV4cG9ydCB2YXIgY29kZVVwcGVyY2FzZUUgPSAweDQ1OyAvLyBcIkVcIlxuZXhwb3J0IHZhciBjb2RlTG93ZXJjYXNlRSA9IDB4NjU7IC8vIFwiZVwiXG5leHBvcnQgdmFyIGNvZGVVcHBlcmNhc2VGID0gMHg0NjsgLy8gXCJGXCJcbmV4cG9ydCB2YXIgY29kZUxvd2VyY2FzZUYgPSAweDY2OyAvLyBcImZcIlxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/revive.js":
/*!****************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/revive.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   revive: () => (/* binding */ revive)\n/* harmony export */ });\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/LosslessNumber.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */\nfunction revive(json, reviver) {\n  return reviveValue({\n    '': json\n  }, '', json, reviver);\n}\n\n/**\n * Revive a value\n */\nfunction reviveValue(context, key, value, reviver) {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver));\n  } else if (value && _typeof(value) === 'object' && !(0,_LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__.isLosslessNumber)(value)) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value, reviver));\n  } else {\n    return reviver.call(context, key, value);\n  }\n}\n\n/**\n * Revive the properties of an object\n */\nfunction reviveObject(object, reviver) {\n  Object.keys(object).forEach(function (key) {\n    var value = reviveValue(object, key, object[key], reviver);\n    if (value !== undefined) {\n      object[key] = value;\n    } else {\n      delete object[key];\n    }\n  });\n  return object;\n}\n\n/**\n * Revive the properties of an Array\n */\nfunction reviveArray(array, reviver) {\n  for (var i = 0; i < array.length; i++) {\n    array[i] = reviveValue(array, i + '', array[i], reviver);\n  }\n  return array;\n}\n//# sourceMappingURL=revive.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9yZXZpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx3QkFBd0IsMkJBQTJCLHNHQUFzRyxxQkFBcUIsbUJBQW1CLDhIQUE4SDtBQUN4UTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFrRCxvRUFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzcy0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL3Jldml2ZS5qcz80YThjIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbmltcG9ydCB7IGlzTG9zc2xlc3NOdW1iZXIgfSBmcm9tICcuL0xvc3NsZXNzTnVtYmVyLmpzJztcbi8qKlxuICogUmV2aXZlIGEganNvbiBvYmplY3QuXG4gKiBBcHBsaWVzIHRoZSByZXZpdmVyIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5IG9uIGFsbCB2YWx1ZXMgaW4gdGhlIEpTT04gb2JqZWN0LlxuICogQHBhcmFtIGpzb24gICBBIEpTT04gT2JqZWN0LCBBcnJheSwgb3IgdmFsdWVcbiAqIEBwYXJhbSByZXZpdmVyXG4gKiAgICAgICAgICAgICAgQSByZXZpdmVyIGZ1bmN0aW9uIGludm9rZWQgd2l0aCBhcmd1bWVudHMgYGtleWAgYW5kIGB2YWx1ZWAsXG4gKiAgICAgICAgICAgICAgd2hpY2ggbXVzdCByZXR1cm4gYSByZXBsYWNlbWVudCB2YWx1ZS4gVGhlIGZ1bmN0aW9uIGNvbnRleHRcbiAqICAgICAgICAgICAgICAoYHRoaXNgKSBpcyB0aGUgT2JqZWN0IG9yIEFycmF5IHRoYXQgY29udGFpbnMgdGhlIGN1cnJlbnRseVxuICogICAgICAgICAgICAgIGhhbmRsZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZpdmUoanNvbiwgcmV2aXZlcikge1xuICByZXR1cm4gcmV2aXZlVmFsdWUoe1xuICAgICcnOiBqc29uXG4gIH0sICcnLCBqc29uLCByZXZpdmVyKTtcbn1cblxuLyoqXG4gKiBSZXZpdmUgYSB2YWx1ZVxuICovXG5mdW5jdGlvbiByZXZpdmVWYWx1ZShjb250ZXh0LCBrZXksIHZhbHVlLCByZXZpdmVyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiByZXZpdmVyLmNhbGwoY29udGV4dCwga2V5LCByZXZpdmVBcnJheSh2YWx1ZSwgcmV2aXZlcikpO1xuICB9IGVsc2UgaWYgKHZhbHVlICYmIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiAhaXNMb3NzbGVzc051bWJlcih2YWx1ZSkpIHtcbiAgICAvLyBub3RlIHRoZSBzcGVjaWFsIGNhc2UgZm9yIExvc3NsZXNzTnVtYmVyLFxuICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBpbnRlcm5hbHMgb2YgYSBMb3NzbGVzc051bWJlclxuICAgIHJldHVybiByZXZpdmVyLmNhbGwoY29udGV4dCwga2V5LCByZXZpdmVPYmplY3QodmFsdWUsIHJldml2ZXIpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV2aXZlci5jYWxsKGNvbnRleHQsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogUmV2aXZlIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiByZXZpdmVPYmplY3Qob2JqZWN0LCByZXZpdmVyKSB7XG4gIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gcmV2aXZlVmFsdWUob2JqZWN0LCBrZXksIG9iamVjdFtrZXldLCByZXZpdmVyKTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogUmV2aXZlIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIEFycmF5XG4gKi9cbmZ1bmN0aW9uIHJldml2ZUFycmF5KGFycmF5LCByZXZpdmVyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IHJldml2ZVZhbHVlKGFycmF5LCBpICsgJycsIGFycmF5W2ldLCByZXZpdmVyKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXZpdmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/revive.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/reviveDate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/reviveDate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reviveDate: () => (/* binding */ reviveDate)\n/* harmony export */ });\n/**\n * Revive a string containing an ISO 8601 date string into a JavaScript `Date` object\n */\nfunction reviveDate(key, value) {\n  return typeof value === 'string' && isoDateRegex.test(value) ? new Date(value) : value;\n}\n\n// Matches strings like \"2022-08-25T09:39:19.288Z\"\nvar isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;\n//# sourceMappingURL=reviveDate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9yZXZpdmVEYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzcy0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL3Jldml2ZURhdGUuanM/OTU1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJldml2ZSBhIHN0cmluZyBjb250YWluaW5nIGFuIElTTyA4NjAxIGRhdGUgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IGBEYXRlYCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldml2ZURhdGUoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBpc29EYXRlUmVnZXgudGVzdCh2YWx1ZSkgPyBuZXcgRGF0ZSh2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuLy8gTWF0Y2hlcyBzdHJpbmdzIGxpa2UgXCIyMDIyLTA4LTI1VDA5OjM5OjE5LjI4OFpcIlxudmFyIGlzb0RhdGVSZWdleCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn1cXC5cXGR7M31aJC87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXZpdmVEYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/reviveDate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/stringify.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/stringify.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param value\n * The value to convert to a JSON string.\n *\n * @param [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @param [numberStringifiers]\n * An optional list with additional number stringifiers, for example to serialize\n * a BigNumber. The output of the function must be valid stringified JSON.\n * When `undefined` is returned, the property will be deleted from the object.\n * The difference with using a `replacer` is that the output of a `replacer`\n * must be JSON and will be stringified afterwards, whereas the output of the\n * `numberStringifiers` is already stringified JSON.\n *\n * @returns Returns the string representation of the JSON object.\n */\nfunction stringify(value, replacer, space, numberStringifiers) {\n  var resolvedSpace = resolveSpace(space);\n  var replacedValue = typeof replacer === 'function' ? replacer.call({\n    '': value\n  }, '', value) : value;\n  return stringifyValue(replacedValue, '');\n\n  /**\n   * Stringify a value\n   */\n  function stringifyValue(value, indent) {\n    if (Array.isArray(numberStringifiers)) {\n      var stringifier = numberStringifiers.find(function (item) {\n        return item.test(value);\n      });\n      if (stringifier) {\n        var str = stringifier.stringify(value);\n        if (typeof str !== 'string' || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(str)) {\n          throw new Error('Invalid JSON number: ' + 'output of a number stringifier must be a string containing a JSON number ' + \"(output: \".concat(str, \")\"));\n        }\n        return str;\n      }\n    }\n\n    // boolean, null, number, string, or date\n    if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || value === null || value instanceof Date || value instanceof Boolean || value instanceof Number || value instanceof String) {\n      return JSON.stringify(value);\n    }\n\n    // lossless number, the secret ingredient :)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (value && value.isLosslessNumber) {\n      return value.toString();\n    }\n\n    // BigInt\n    if (typeof value === 'bigint') {\n      return value.toString();\n    }\n\n    // Array\n    if (Array.isArray(value)) {\n      return stringifyArray(value, indent);\n    }\n\n    // Object (test lastly!)\n    if (value && _typeof(value) === 'object') {\n      return stringifyObject(value, indent);\n    }\n    return undefined;\n  }\n\n  /**\n   * Stringify an array\n   */\n  function stringifyArray(array, indent) {\n    if (array.length === 0) {\n      return '[]';\n    }\n    var childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    var str = resolvedSpace ? '[\\n' : '[';\n    for (var i = 0; i < array.length; i++) {\n      var item = typeof replacer === 'function' ? replacer.call(array, String(i), array[i]) : array[i];\n      if (resolvedSpace) {\n        str += childIndent;\n      }\n      if (typeof item !== 'undefined' && typeof item !== 'function') {\n        str += stringifyValue(item, childIndent);\n      } else {\n        str += 'null';\n      }\n      if (i < array.length - 1) {\n        str += resolvedSpace ? ',\\n' : ',';\n      }\n    }\n    str += resolvedSpace ? '\\n' + indent + ']' : ']';\n    return str;\n  }\n\n  /**\n   * Stringify an object\n   */\n  function stringifyObject(object, indent) {\n    if (typeof object.toJSON === 'function') {\n      return stringify(object.toJSON(), replacer, space, undefined);\n    }\n    var keys = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object);\n    if (keys.length === 0) {\n      return '{}';\n    }\n    var childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    var first = true;\n    var str = resolvedSpace ? '{\\n' : '{';\n    keys.forEach(function (key) {\n      var value = typeof replacer === 'function' ? replacer.call(object, key, object[key]) : object[key];\n      if (includeProperty(key, value)) {\n        if (first) {\n          first = false;\n        } else {\n          str += resolvedSpace ? ',\\n' : ',';\n        }\n        var keyStr = JSON.stringify(key);\n        str += resolvedSpace ? childIndent + keyStr + ': ' : keyStr + ':';\n        str += stringifyValue(value, childIndent);\n      }\n    });\n    str += resolvedSpace ? '\\n' + indent + '}' : '}';\n    return str;\n  }\n\n  /**\n   * Test whether to include a property in a stringified object or not.\n   */\n  function includeProperty(key, value) {\n    return typeof value !== 'undefined' && typeof value !== 'function' && _typeof(value) !== 'symbol';\n  }\n}\n\n/**\n * Resolve a JSON stringify space:\n * replace a number with a string containing that number of spaces\n */\nfunction resolveSpace(space) {\n  if (typeof space === 'number') {\n    return ' '.repeat(space);\n  }\n  if (typeof space === 'string' && space !== '') {\n    return space;\n  }\n  return undefined;\n}\n//# sourceMappingURL=stringify.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9zdHJpbmdpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx3QkFBd0IsMkJBQTJCLHNHQUFzRyxxQkFBcUIsbUJBQW1CLDhIQUE4SDtBQUN6Ujs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3Q0FBd0MsbURBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHNzLTIvbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vc3RyaW5naWZ5LmpzPzExYmYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBUaGUgTG9zc2xlc3NKU09OLnN0cmluZ2lmeSgpIG1ldGhvZCBjb252ZXJ0cyBhIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBKU09OIHN0cmluZyxcbiAqIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHZhbHVlcyBpZiBhIHJlcGxhY2VyIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgb3JcbiAqIG9wdGlvbmFsbHkgaW5jbHVkaW5nIG9ubHkgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGlmIGEgcmVwbGFjZXIgYXJyYXkgaXMgc3BlY2lmaWVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBKU09OIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gW3JlcGxhY2VyXVxuICogQSBmdW5jdGlvbiB0aGF0IGFsdGVycyB0aGUgYmVoYXZpb3Igb2YgdGhlIHN0cmluZ2lmaWNhdGlvbiBwcm9jZXNzLFxuICogb3IgYW4gYXJyYXkgb2YgU3RyaW5nIGFuZCBOdW1iZXIgb2JqZWN0cyB0aGF0IHNlcnZlIGFzIGEgd2hpdGVsaXN0IGZvclxuICogc2VsZWN0aW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2YWx1ZSBvYmplY3QgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIEpTT04gc3RyaW5nLlxuICogSWYgdGhpcyB2YWx1ZSBpcyBudWxsIG9yIG5vdCBwcm92aWRlZCwgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBhcmVcbiAqIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgSlNPTiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIFtzcGFjZV1cbiAqIEEgU3RyaW5nIG9yIE51bWJlciBvYmplY3QgdGhhdCdzIHVzZWQgdG8gaW5zZXJ0IHdoaXRlIHNwYWNlIGludG8gdGhlIG91dHB1dFxuICogSlNPTiBzdHJpbmcgZm9yIHJlYWRhYmlsaXR5IHB1cnBvc2VzLiBJZiB0aGlzIGlzIGEgTnVtYmVyLCBpdCBpbmRpY2F0ZXMgdGhlXG4gKiBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycyB0byB1c2UgYXMgd2hpdGUgc3BhY2U7IHRoaXMgbnVtYmVyIGlzIGNhcHBlZCBhdCAxMFxuICogaWYgaXQncyBsYXJnZXIgdGhhbiB0aGF0LiBWYWx1ZXMgbGVzcyB0aGFuIDEgaW5kaWNhdGUgdGhhdCBubyBzcGFjZSBzaG91bGQgYmVcbiAqIHVzZWQuIElmIHRoaXMgaXMgYSBTdHJpbmcsIHRoZSBzdHJpbmcgKG9yIHRoZSBmaXJzdCAxMCBjaGFyYWN0ZXJzIG9mIHRoZSBzdHJpbmcsXG4gKiBpZiBpdCdzIGxvbmdlciB0aGFuIHRoYXQpIGlzIHVzZWQgYXMgd2hpdGUgc3BhY2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG5vdFxuICogcHJvdmlkZWQgKG9yIGlzIG51bGwpLCBubyB3aGl0ZSBzcGFjZSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbbnVtYmVyU3RyaW5naWZpZXJzXVxuICogQW4gb3B0aW9uYWwgbGlzdCB3aXRoIGFkZGl0aW9uYWwgbnVtYmVyIHN0cmluZ2lmaWVycywgZm9yIGV4YW1wbGUgdG8gc2VyaWFsaXplXG4gKiBhIEJpZ051bWJlci4gVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24gbXVzdCBiZSB2YWxpZCBzdHJpbmdpZmllZCBKU09OLlxuICogV2hlbiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCwgdGhlIHByb3BlcnR5IHdpbGwgYmUgZGVsZXRlZCBmcm9tIHRoZSBvYmplY3QuXG4gKiBUaGUgZGlmZmVyZW5jZSB3aXRoIHVzaW5nIGEgYHJlcGxhY2VyYCBpcyB0aGF0IHRoZSBvdXRwdXQgb2YgYSBgcmVwbGFjZXJgXG4gKiBtdXN0IGJlIEpTT04gYW5kIHdpbGwgYmUgc3RyaW5naWZpZWQgYWZ0ZXJ3YXJkcywgd2hlcmVhcyB0aGUgb3V0cHV0IG9mIHRoZVxuICogYG51bWJlclN0cmluZ2lmaWVyc2AgaXMgYWxyZWFkeSBzdHJpbmdpZmllZCBKU09OLlxuICpcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKSB7XG4gIHZhciByZXNvbHZlZFNwYWNlID0gcmVzb2x2ZVNwYWNlKHNwYWNlKTtcbiAgdmFyIHJlcGxhY2VkVmFsdWUgPSB0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlci5jYWxsKHtcbiAgICAnJzogdmFsdWVcbiAgfSwgJycsIHZhbHVlKSA6IHZhbHVlO1xuICByZXR1cm4gc3RyaW5naWZ5VmFsdWUocmVwbGFjZWRWYWx1ZSwgJycpO1xuXG4gIC8qKlxuICAgKiBTdHJpbmdpZnkgYSB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWUodmFsdWUsIGluZGVudCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG51bWJlclN0cmluZ2lmaWVycykpIHtcbiAgICAgIHZhciBzdHJpbmdpZmllciA9IG51bWJlclN0cmluZ2lmaWVycy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnRlc3QodmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBpZiAoc3RyaW5naWZpZXIpIHtcbiAgICAgICAgdmFyIHN0ciA9IHN0cmluZ2lmaWVyLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCAhaXNOdW1iZXIoc3RyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIG51bWJlcjogJyArICdvdXRwdXQgb2YgYSBudW1iZXIgc3RyaW5naWZpZXIgbXVzdCBiZSBhIHN0cmluZyBjb250YWluaW5nIGEgSlNPTiBudW1iZXIgJyArIFwiKG91dHB1dDogXCIuY29uY2F0KHN0ciwgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJvb2xlYW4sIG51bGwsIG51bWJlciwgc3RyaW5nLCBvciBkYXRlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIGxvc3NsZXNzIG51bWJlciwgdGhlIHNlY3JldCBpbmdyZWRpZW50IDopXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNMb3NzbGVzc051bWJlcikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gQmlnSW50XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8vIEFycmF5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUsIGluZGVudCk7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0ICh0ZXN0IGxhc3RseSEpXG4gICAgaWYgKHZhbHVlICYmIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSwgaW5kZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZnkgYW4gYXJyYXlcbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFycmF5LCBpbmRlbnQpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1tdJztcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5kZW50ID0gcmVzb2x2ZWRTcGFjZSA/IGluZGVudCArIHJlc29sdmVkU3BhY2UgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHN0ciA9IHJlc29sdmVkU3BhY2UgPyAnW1xcbicgOiAnWyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSB0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlci5jYWxsKGFycmF5LCBTdHJpbmcoaSksIGFycmF5W2ldKSA6IGFycmF5W2ldO1xuICAgICAgaWYgKHJlc29sdmVkU3BhY2UpIHtcbiAgICAgICAgc3RyICs9IGNoaWxkSW5kZW50O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaXRlbSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdHIgKz0gc3RyaW5naWZ5VmFsdWUoaXRlbSwgY2hpbGRJbmRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9ICdudWxsJztcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgICBzdHIgKz0gcmVzb2x2ZWRTcGFjZSA/ICcsXFxuJyA6ICcsJztcbiAgICAgIH1cbiAgICB9XG4gICAgc3RyICs9IHJlc29sdmVkU3BhY2UgPyAnXFxuJyArIGluZGVudCArICddJyA6ICddJztcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmluZ2lmeSBhbiBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmplY3QsIGluZGVudCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0LnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeShvYmplY3QudG9KU09OKCksIHJlcGxhY2VyLCBzcGFjZSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBBcnJheS5pc0FycmF5KHJlcGxhY2VyKSA/IHJlcGxhY2VyLm1hcChTdHJpbmcpIDogT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAne30nO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbmRlbnQgPSByZXNvbHZlZFNwYWNlID8gaW5kZW50ICsgcmVzb2x2ZWRTcGFjZSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgIHZhciBzdHIgPSByZXNvbHZlZFNwYWNlID8gJ3tcXG4nIDogJ3snO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSB0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlci5jYWxsKG9iamVjdCwga2V5LCBvYmplY3Rba2V5XSkgOiBvYmplY3Rba2V5XTtcbiAgICAgIGlmIChpbmNsdWRlUHJvcGVydHkoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gcmVzb2x2ZWRTcGFjZSA/ICcsXFxuJyA6ICcsJztcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5U3RyID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgc3RyICs9IHJlc29sdmVkU3BhY2UgPyBjaGlsZEluZGVudCArIGtleVN0ciArICc6ICcgOiBrZXlTdHIgKyAnOic7XG4gICAgICAgIHN0ciArPSBzdHJpbmdpZnlWYWx1ZSh2YWx1ZSwgY2hpbGRJbmRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN0ciArPSByZXNvbHZlZFNwYWNlID8gJ1xcbicgKyBpbmRlbnQgKyAnfScgOiAnfSc7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdG8gaW5jbHVkZSBhIHByb3BlcnR5IGluIGEgc3RyaW5naWZpZWQgb2JqZWN0IG9yIG5vdC5cbiAgICovXG4gIGZ1bmN0aW9uIGluY2x1ZGVQcm9wZXJ0eShrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIF90eXBlb2YodmFsdWUpICE9PSAnc3ltYm9sJztcbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgYSBKU09OIHN0cmluZ2lmeSBzcGFjZTpcbiAqIHJlcGxhY2UgYSBudW1iZXIgd2l0aCBhIHN0cmluZyBjb250YWluaW5nIHRoYXQgbnVtYmVyIG9mIHNwYWNlc1xuICovXG5mdW5jdGlvbiByZXNvbHZlU3BhY2Uoc3BhY2UpIHtcbiAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJyAnLnJlcGVhdChzcGFjZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycgJiYgc3BhY2UgIT09ICcnKSB7XG4gICAgcmV0dXJuIHNwYWNlO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdpZnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/types.js":
/*!***************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/types.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL0Bzcy0yL25leHRqcy8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL3R5cGVzLmpzP2NhM2MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnsafeNumberReason: () => (/* binding */ UnsafeNumberReason),\n/* harmony export */   extractSignificantDigits: () => (/* binding */ extractSignificantDigits),\n/* harmony export */   getUnsafeNumberReason: () => (/* binding */ getUnsafeNumberReason),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isSafeNumber: () => (/* binding */ isSafeNumber),\n/* harmony export */   toSafeNumberOrThrow: () => (/* binding */ toSafeNumberOrThrow)\n/* harmony export */ });\n/**\n * Test whether a string contains an integer number\n */\nfunction isInteger(value) {\n  return INTEGER_REGEX.test(value);\n}\nvar INTEGER_REGEX = /^-?[0-9]+$/;\n\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */\nfunction isNumber(value) {\n  return NUMBER_REGEX.test(value);\n}\nvar NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/;\n\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */\nfunction isSafeNumber(value, config) {\n  var num = parseFloat(value);\n  var str = String(num);\n  var v = extractSignificantDigits(value);\n  var s = extractSignificantDigits(str);\n  if (v === s) {\n    return true;\n  }\n  if ((config === null || config === void 0 ? void 0 : config.approx) === true) {\n    // A value is approximately equal when:\n    // 1. it is a floating point number, not an integer\n    // 2. it has at least 14 digits\n    // 3. the first 14 digits are equal\n    var requiredDigits = 14;\n    if (!isInteger(value) && s.length >= requiredDigits && v.startsWith(s.substring(0, requiredDigits))) {\n      return true;\n    }\n  }\n  return false;\n}\nvar UnsafeNumberReason = /*#__PURE__*/function (UnsafeNumberReason) {\n  UnsafeNumberReason[\"underflow\"] = \"underflow\";\n  UnsafeNumberReason[\"overflow\"] = \"overflow\";\n  UnsafeNumberReason[\"truncate_integer\"] = \"truncate_integer\";\n  UnsafeNumberReason[\"truncate_float\"] = \"truncate_float\";\n  return UnsafeNumberReason;\n}({});\n\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */\nfunction getUnsafeNumberReason(value) {\n  if (isSafeNumber(value, {\n    approx: false\n  })) {\n    return undefined;\n  }\n  if (isInteger(value)) {\n    return UnsafeNumberReason.truncate_integer;\n  }\n  var num = parseFloat(value);\n  if (!isFinite(num)) {\n    return UnsafeNumberReason.overflow;\n  }\n  if (num === 0) {\n    return UnsafeNumberReason.underflow;\n  }\n  return UnsafeNumberReason.truncate_float;\n}\n\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */\nfunction toSafeNumberOrThrow(value, config) {\n  var number = parseFloat(value);\n  var unsafeReason = getUnsafeNumberReason(value);\n  if ((config === null || config === void 0 ? void 0 : config.approx) === true ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float : unsafeReason) {\n    var unsafeReasonText = unsafeReason.replace(/_\\w+$/, '');\n    throw new Error('Cannot safely convert to number: ' + \"the value '\".concat(value, \"' would \").concat(unsafeReasonText, \" and become \").concat(number));\n  }\n  return number;\n}\n\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/\nfunction extractSignificantDigits(value) {\n  return value\n  // from \"-0.250e+30\" to \"-0.250\"\n  .replace(EXPONENTIAL_PART_REGEX, '')\n\n  // from \"-0.250\" to \"-0250\"\n  .replace(DOT_REGEX, '')\n\n  // from \"-0250\" to \"-025\"\n  .replace(TRAILING_ZEROS_REGEX, '')\n\n  // from \"-025\" to \"25\"\n  .replace(LEADING_MINUS_AND_ZEROS_REGEX, '');\n}\nvar EXPONENTIAL_PART_REGEX = /[eE][+-]?\\d+$/;\nvar LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/;\nvar DOT_REGEX = /\\./;\nvar TRAILING_ZEROS_REGEX = /0+$/;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3MtMi9uZXh0anMvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS91dGlscy5qcz85YjA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdCB3aGV0aGVyIGEgc3RyaW5nIGNvbnRhaW5zIGFuIGludGVnZXIgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIElOVEVHRVJfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG52YXIgSU5URUdFUl9SRUdFWCA9IC9eLT9bMC05XSskLztcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYSBzdHJpbmcgY29udGFpbnMgYSBudW1iZXJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMzNDA3MTcvanNvbi1udW1iZXJzLXJlZ3VsYXItZXhwcmVzc2lvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIE5VTUJFUl9SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbnZhciBOVU1CRVJfUkVHRVggPSAvXi0/KD86MHxbMS05XVxcZCopKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/JC87XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgc3RyaW5nIGNhbiBiZSBzYWZlbHkgcmVwcmVzZW50ZWQgd2l0aCBhIG51bWJlclxuICogd2l0aG91dCBpbmZvcm1hdGlvbiBsb3NzLlxuICpcbiAqIFdoZW4gYXBwcm94IGlzIHRydWUsIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgdGhhdCBsb3NlIGEgZmV3IGRpZ2l0cyBidXRcbiAqIGFyZSBzdGlsbCBhcHByb3hpbWF0ZWx5IGVxdWFsIGluIHZhbHVlIGFyZSBjb25zaWRlcmVkIHNhZmUgdG9vLlxuICogSW50ZWdlciBudW1iZXJzIG11c3Qgc3RpbGwgYmUgZXhhY3RseSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmZU51bWJlcih2YWx1ZSwgY29uZmlnKSB7XG4gIHZhciBudW0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgdmFyIHN0ciA9IFN0cmluZyhudW0pO1xuICB2YXIgdiA9IGV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh2YWx1ZSk7XG4gIHZhciBzID0gZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKHN0cik7XG4gIGlmICh2ID09PSBzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXBwcm94KSA9PT0gdHJ1ZSkge1xuICAgIC8vIEEgdmFsdWUgaXMgYXBwcm94aW1hdGVseSBlcXVhbCB3aGVuOlxuICAgIC8vIDEuIGl0IGlzIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCBub3QgYW4gaW50ZWdlclxuICAgIC8vIDIuIGl0IGhhcyBhdCBsZWFzdCAxNCBkaWdpdHNcbiAgICAvLyAzLiB0aGUgZmlyc3QgMTQgZGlnaXRzIGFyZSBlcXVhbFxuICAgIHZhciByZXF1aXJlZERpZ2l0cyA9IDE0O1xuICAgIGlmICghaXNJbnRlZ2VyKHZhbHVlKSAmJiBzLmxlbmd0aCA+PSByZXF1aXJlZERpZ2l0cyAmJiB2LnN0YXJ0c1dpdGgocy5zdWJzdHJpbmcoMCwgcmVxdWlyZWREaWdpdHMpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCB2YXIgVW5zYWZlTnVtYmVyUmVhc29uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChVbnNhZmVOdW1iZXJSZWFzb24pIHtcbiAgVW5zYWZlTnVtYmVyUmVhc29uW1widW5kZXJmbG93XCJdID0gXCJ1bmRlcmZsb3dcIjtcbiAgVW5zYWZlTnVtYmVyUmVhc29uW1wib3ZlcmZsb3dcIl0gPSBcIm92ZXJmbG93XCI7XG4gIFVuc2FmZU51bWJlclJlYXNvbltcInRydW5jYXRlX2ludGVnZXJcIl0gPSBcInRydW5jYXRlX2ludGVnZXJcIjtcbiAgVW5zYWZlTnVtYmVyUmVhc29uW1widHJ1bmNhdGVfZmxvYXRcIl0gPSBcInRydW5jYXRlX2Zsb2F0XCI7XG4gIHJldHVybiBVbnNhZmVOdW1iZXJSZWFzb247XG59KHt9KTtcblxuLyoqXG4gKiBXaGVuIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhbiB1bnNhZmUgbnVtYmVyLCBkZXNjcmliZSB3aGF0IHRoZSByZWFzb24gaXM6XG4gKiBvdmVyZmxvdywgdW5kZXJmbG93LCB0cnVuY2F0ZV9pbnRlZ2VyLCBvciB0cnVuY2F0ZV9mbG9hdC5cbiAqIFJldHVybnMgdW5kZWZpbmVkIHdoZW4gdGhlIHZhbHVlIGlzIHNhZmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbnNhZmVOdW1iZXJSZWFzb24odmFsdWUpIHtcbiAgaWYgKGlzU2FmZU51bWJlcih2YWx1ZSwge1xuICAgIGFwcHJveDogZmFsc2VcbiAgfSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc0ludGVnZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi50cnVuY2F0ZV9pbnRlZ2VyO1xuICB9XG4gIHZhciBudW0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgaWYgKCFpc0Zpbml0ZShudW0pKSB7XG4gICAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi5vdmVyZmxvdztcbiAgfVxuICBpZiAobnVtID09PSAwKSB7XG4gICAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi51bmRlcmZsb3c7XG4gIH1cbiAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi50cnVuY2F0ZV9mbG9hdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGludG8gYSBudW1iZXIgd2hlbiBpdCBpcyBzYWZlIHRvIGRvIHNvLlxuICogVGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZSwgZXhwbGFpbmluZyB0aGUgcmVhc29uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TYWZlTnVtYmVyT3JUaHJvdyh2YWx1ZSwgY29uZmlnKSB7XG4gIHZhciBudW1iZXIgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgdmFyIHVuc2FmZVJlYXNvbiA9IGdldFVuc2FmZU51bWJlclJlYXNvbih2YWx1ZSk7XG4gIGlmICgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmFwcHJveCkgPT09IHRydWUgPyB1bnNhZmVSZWFzb24gJiYgdW5zYWZlUmVhc29uICE9PSBVbnNhZmVOdW1iZXJSZWFzb24udHJ1bmNhdGVfZmxvYXQgOiB1bnNhZmVSZWFzb24pIHtcbiAgICB2YXIgdW5zYWZlUmVhc29uVGV4dCA9IHVuc2FmZVJlYXNvbi5yZXBsYWNlKC9fXFx3KyQvLCAnJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2FmZWx5IGNvbnZlcnQgdG8gbnVtYmVyOiAnICsgXCJ0aGUgdmFsdWUgJ1wiLmNvbmNhdCh2YWx1ZSwgXCInIHdvdWxkIFwiKS5jb25jYXQodW5zYWZlUmVhc29uVGV4dCwgXCIgYW5kIGJlY29tZSBcIikuY29uY2F0KG51bWJlcikpO1xuICB9XG4gIHJldHVybiBudW1iZXI7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaWduaWZpY2FudCBkaWdpdHMgb2YgYSBudW1iZXIuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKiAgICcyLjM0JyByZXR1cm5zICcyMzQnXG4gKiAgICctNzcnIHJldHVybnMgJzc3J1xuICogICAnMC4wMDM0MDAnIHJldHVybnMgJzM0J1xuICogICAnMTIwLjVlKzMwJyByZXR1cm5zICcxMjA1J1xuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVcbiAgLy8gZnJvbSBcIi0wLjI1MGUrMzBcIiB0byBcIi0wLjI1MFwiXG4gIC5yZXBsYWNlKEVYUE9ORU5USUFMX1BBUlRfUkVHRVgsICcnKVxuXG4gIC8vIGZyb20gXCItMC4yNTBcIiB0byBcIi0wMjUwXCJcbiAgLnJlcGxhY2UoRE9UX1JFR0VYLCAnJylcblxuICAvLyBmcm9tIFwiLTAyNTBcIiB0byBcIi0wMjVcIlxuICAucmVwbGFjZShUUkFJTElOR19aRVJPU19SRUdFWCwgJycpXG5cbiAgLy8gZnJvbSBcIi0wMjVcIiB0byBcIjI1XCJcbiAgLnJlcGxhY2UoTEVBRElOR19NSU5VU19BTkRfWkVST1NfUkVHRVgsICcnKTtcbn1cbnZhciBFWFBPTkVOVElBTF9QQVJUX1JFR0VYID0gL1tlRV1bKy1dP1xcZCskLztcbnZhciBMRUFESU5HX01JTlVTX0FORF9aRVJPU19SRUdFWCA9IC9eLT8oMCopPy87XG52YXIgRE9UX1JFR0VYID0gL1xcLi87XG52YXIgVFJBSUxJTkdfWkVST1NfUkVHRVggPSAvMCskLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/node_modules/lossless-json/lib/esm/utils.js\n");

/***/ })

};
;